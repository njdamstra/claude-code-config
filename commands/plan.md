---
allowed-tools: Task
argument-hint: <task-description> [--workflow=name]
description: Intelligent planning orchestrator - Analyzes task and selects optimal workflow (Hypothesis-Driven, Discovery-First, Documentation-First, Quick-Scan, Iterative-Refinement) then outputs step-by-step agent execution instructions for main chat to follow
---

# Plan Orchestrator Command

**Intelligent multi-agent planning with adaptive workflows**

**Usage:** `/plan <task-description> [--workflow=name]`

---

## What This Does

Invokes the `plan-orchestrator` agent which:

1. **Analyzes your task** - Complexity, domain, keywords, goals
2. **Selects optimal workflow** - From 5 adaptive patterns
3. **Outputs execution instructions** - Step-by-step plan for which agents to spawn
4. **Designs parallel strategies** - Specifies which investigations can run simultaneously
5. **Provides synthesis guidance** - Tells main chat how to aggregate findings
6. **Structures evidence-based planning** - Clear dependencies and expected outcomes

**Then main chat:**
- Follows the orchestrator's instructions
- Spawns specialist agents (code-scout, code-qa, doc-searcher, plan-master)
- Synthesizes findings between steps
- Generates comprehensive plan based on evidence

---

## Available Workflows

The orchestrator automatically selects from these patterns:

### 1. Hypothesis-Driven (for bugs/investigations)
- **Best for:** Debugging, crashes, unexpected behavior
- **Pattern:** Generate hypotheses → Test in parallel → Find root cause
- **Agents:** code-scout → code-qa × N (parallel) → plan-master
- **Example:** "Auth crash on expired token"

### 2. Discovery-First (default for new features)
- **Best for:** New implementations, adding functionality
- **Pattern:** Broad discovery → Targeted questions → Documentation → Plan
- **Agents:** code-scout → code-qa × N (gaps) → doc-searcher → plan-master
- **Example:** "Create user profile component"

### 3. Documentation-First (for framework-heavy)
- **Best for:** Framework integration, library usage, official patterns
- **Pattern:** Research docs → Apply to codebase → Verify → Plan
- **Agents:** doc-searcher → code-scout → code-qa → plan-master
- **Example:** "OAuth integration with Appwrite"

### 4. Quick-Scan (for simple changes)
- **Best for:** Trivial modifications, single-file changes
- **Pattern:** Targeted scan → Optional verification → Minimal plan
- **Agents:** code-scout (narrow) → code-qa (optional) → plan-master
- **Example:** "Add loading spinner to button"

### 5. Iterative-Refinement (for refactoring)
- **Best for:** Code consolidation, optimization, removing duplication
- **Pattern:** Map duplications → Parallel analysis → Research → Incremental plan
- **Agents:** code-scout (deep) → code-qa × N (duplications) → doc-searcher → plan-master
- **Example:** "Consolidate FormInput components"

---

## Usage Examples

### Let Orchestrator Choose (Recommended)

```bash
# Bug investigation - will select Hypothesis-Driven
/plan "Fix: Component crashes when user logs out"

# New feature - will select Discovery-First
/plan "Create user settings page with profile editing"

# Framework integration - will select Documentation-First
/plan "Implement OAuth2 authentication with Appwrite"

# Simple change - will select Quick-Scan
/plan "Add dark mode toggle to header"

# Refactoring - will select Iterative-Refinement
/plan "Consolidate duplicate validation logic across forms"
```

### Force Specific Workflow

```bash
# Override selection
/plan "Task description" --workflow=hypothesis-driven
/plan "Task description" --workflow=discovery-first
/plan "Task description" --workflow=documentation-first
/plan "Task description" --workflow=quick-scan
/plan "Task description" --workflow=iterative-refinement
```

---

## What You Get

### 1. Workflow Selection Report
- Which workflow was selected and why
- Keyword matches and complexity assessment
- Alternative workflows considered
- Confidence in selection

### 2. Investigation Results
- Findings from all spawned agents
- Files examined and patterns found
- Evidence aggregation with citations
- Confidence ratings (High/Medium/Low)

### 3. Evidence Summary
- High confidence findings (verified in source)
- Medium confidence findings (inferred from patterns)
- Investigation gaps (needs verification)
- Reusability analysis (REUSE/EXTEND/CREATE)

### 4. Implementation Plan
- Generated by plan-master with full context
- All recommendations backed by evidence
- Task breakdown with agent assignments
- Success criteria and validation checkpoints
- Risk mitigation strategies

---

## Workflow Selection Logic

**The orchestrator analyzes:**

1. **Keywords** (high priority)
   - Bug indicators: bug, crash, error, debug, investigate
   - Framework: OAuth, SSR, authentication, framework, library
   - Simplicity: simple, quick, add, change, small
   - Refactor: refactor, optimize, consolidate, duplicate

2. **Complexity**
   - Simple: 1-2 files, single change
   - Medium: 3-8 files, multiple changes
   - Complex: 9+ files, architectural

3. **Domain**
   - Frontend, backend, full-stack, infrastructure

**Selection priority:**
1. Hypothesis-Driven IF bug/crash/error keywords
2. Documentation-First IF OAuth/SSR/framework keywords
3. Quick-Scan IF simple/quick/trivial keywords
4. Iterative-Refinement IF refactor/optimize/consolidate keywords
5. Discovery-First (default for everything else)

---

## Execution

**When you run this command:**

```bash
# Arguments from command
TASK_DESCRIPTION="$ARGUMENTS"

# Parse workflow override (if provided)
WORKFLOW_OVERRIDE=$(echo "$ARGUMENTS" | grep -oP '(?<=--workflow=)[a-z-]+' || echo "")

# Build prompt
PROMPT="Task: $TASK_DESCRIPTION"

if [ -n "$WORKFLOW_OVERRIDE" ]; then
  PROMPT="$PROMPT

Workflow override: Use $WORKFLOW_OVERRIDE workflow pattern.
User explicitly requested this workflow - honor the request."
fi

# Invoke plan-orchestrator agent
Task(
  subagent_type: "plan-orchestrator",
  description: "Create implementation plan for: $TASK_DESCRIPTION",
  prompt: """$PROMPT"""
)
```

---

## Benefits

✅ **Intelligent workflow selection** - Right pattern for each task type
✅ **Clear execution instructions** - Step-by-step agent spawning guide
✅ **Parallel execution strategy** - Orchestrator designs which agents run simultaneously
✅ **Evidence-based planning** - Every claim cited with file:line
✅ **Confidence ratings** - Know what's verified vs inferred
✅ **Honest gap reporting** - Clear about what needs verification
✅ **Comprehensive synthesis** - Main chat aggregates all findings
✅ **Optimized efficiency** - Minimal investigation overhead for simple tasks

---

## When to Use

**Use /plan when:**
- Complex task needs systematic investigation
- Want evidence-based recommendations
- Multiple unknowns need parallel investigation
- Bug requires root cause analysis
- Framework integration needs pattern research
- Refactoring needs duplication analysis

**Don't use /plan when:**
- Task is trivial and obvious (just implement directly)
- Already have complete context (no investigation needed)
- Rapid prototyping (planning overhead not worth it)

---

## Examples by Task Type

### Bug Investigation
```bash
/plan "User authentication fails with 401 error on token refresh"
# → Hypothesis-Driven workflow
# → Generates 3-5 hypotheses
# → Tests each in parallel with code-qa
# → Identifies root cause
# → Creates fix plan
```

### New Feature
```bash
/plan "Create social media sharing component with Twitter and Facebook"
# → Discovery-First workflow
# → Maps existing social components
# → Investigates sharing APIs
# → Searches for share patterns
# → Creates implementation plan
```

### Framework Integration
```bash
/plan "Integrate Appwrite realtime subscriptions for chat"
# → Documentation-First workflow
# → Searches Appwrite docs
# → Finds realtime patterns in codebase
# → Verifies WebSocket compatibility
# → Creates integration plan
```

### Simple Change
```bash
/plan "Add tooltip to profile edit button"
# → Quick-Scan workflow
# → Finds button component
# → Checks existing tooltip pattern
# → Creates minimal plan
```

### Refactoring
```bash
/plan "Extract duplicate form validation into shared composable"
# → Iterative-Refinement workflow
# → Maps all validation duplications
# → Analyzes each pattern in parallel
# → Creates incremental refactor plan
```

---

## Advanced Usage

### Sequential Planning
```bash
# Create plan, review, then implement
/plan "Complex feature description"
# Review generated plan...
# Then implement manually or with specialist agents
```

### Iterative Investigation
```bash
# First pass
/plan "Investigate performance issues in dashboard"
# Review findings...

# Second pass with more context
/plan "Optimize dashboard based on findings: [specific bottlenecks]"
```

### Workflow Experimentation
```bash
# Try different workflows to see different perspectives
/plan "Task" --workflow=hypothesis-driven
/plan "Task" --workflow=discovery-first
# Compare approaches
```

---

## Output Location

The orchestrator creates workspace documents:
- **PRE_ANALYSIS.md** - code-scout findings
- **QA_REPORT_*.md** - code-qa investigations
- **DOC_SEARCH.md** - doc-searcher results (if used)
- **INVESTIGATION_SYNTHESIS.md** - Aggregated evidence
- **PLAN.md** or **MASTER_PLAN.md** - Final plan

Location: Current directory or `.temp/` workspace

---

## Key Differences from /frontend

**`/plan` (this command):**
- Strategic planning and investigation design
- Multi-workflow selection (5 patterns)
- Orchestrator outputs execution instructions
- Main chat spawns 4 specialist agents
- Outputs plan, not implementation
- Used before implementation

**`/frontend`:**
- Full workflow: Analysis → Plan → Implementation → Validation
- Frontend-specific
- Executes implementation
- Includes build/test validation
- Used for complete feature delivery

**Relationship:**
```
/plan → Generates comprehensive plan
        ↓
        Review plan
        ↓
/frontend → Executes plan (or implement manually)
```

---

## Tips

**For best results:**
1. Be specific in task description - more detail = better workflow selection
2. Include context - "Fix X because Y happens when Z"
3. Mention domain - "Backend API" vs "Vue component" helps selection
4. Trust the workflow selection - it's optimized for each task type
5. Use --workflow override only when you know better approach exists

**Task description quality:**
- ❌ "Fix bug" (too vague)
- ✅ "Fix: Profile component crashes on null user data"

- ❌ "Add feature" (no detail)
- ✅ "Add OAuth Google login with Appwrite integration"

- ❌ "Refactor" (what specifically?)
- ✅ "Consolidate duplicate error handling across API routes"

---

**Invoke plan-orchestrator agent with task description.**

**The orchestrator will:**
1. Analyze task and select optimal workflow
2. Output step-by-step execution instructions for main chat
3. Specify which agents to spawn (code-scout, code-qa, doc-searcher, plan-master)
4. Design parallel vs sequential execution strategy
5. Provide synthesis guidance

**Main chat will then:**
1. Follow orchestrator's instructions
2. Spawn specialist agents as directed
3. Synthesize evidence between steps
4. Generate comprehensive plan
5. Report findings with confidence ratings
