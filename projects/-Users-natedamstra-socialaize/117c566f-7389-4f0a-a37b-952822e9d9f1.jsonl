{"type":"file-history-snapshot","messageId":"48e46b9f-4cfb-4a6a-9248-52f8174cf426","snapshot":{"messageId":"48e46b9f-4cfb-4a6a-9248-52f8174cf426","trackedFileBackups":{},"timestamp":"2025-09-30T20:30:42.557Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":"Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."},"isMeta":true,"uuid":"f3875586-b49d-4eda-bfef-4d4ba5bda097","timestamp":"2025-09-30T20:30:42.553Z"}
{"parentUuid":"f3875586-b49d-4eda-bfef-4d4ba5bda097","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":"<command-name>/clear</command-name>\n            <command-message>clear</command-message>\n            <command-args></command-args>"},"uuid":"48e46b9f-4cfb-4a6a-9248-52f8174cf426","timestamp":"2025-09-30T20:30:42.484Z"}
{"parentUuid":"48e46b9f-4cfb-4a6a-9248-52f8174cf426","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":"<local-command-stdout></local-command-stdout>"},"uuid":"fc20d97f-d6bd-4c1d-bb45-3d684e0a4e98","timestamp":"2025-09-30T20:30:42.550Z"}
{"type":"file-history-snapshot","messageId":"5c08f8cc-c1a4-4ffc-ae95-8afd527b2f85","snapshot":{"messageId":"5c08f8cc-c1a4-4ffc-ae95-8afd527b2f85","trackedFileBackups":{},"timestamp":"2025-09-30T20:35:19.383Z"},"isSnapshotUpdate":false}
{"parentUuid":"fc20d97f-d6bd-4c1d-bb45-3d684e0a4e98","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":"Rewrite @AI_ACTIONS_REFERENCE.md to include dedicated sections for ai actions used in the frontend workflows (workflow action nodes, there config, etc.), used in @functions/WorkflowManager/ , and in @functions/AI_API/ . remove all documentation of bugs, but take note of inconsistencies and issues (verifying schemas and explaining differences in logic between the actions for each of these parts of the codebase). Visually and in writing explain how they all relate to one another. ultrathink"},"uuid":"5c08f8cc-c1a4-4ffc-ae95-8afd527b2f85","timestamp":"2025-09-30T20:35:19.372Z","thinkingMetadata":{"level":"high","disabled":false,"triggers":[{"start":483,"end":493,"text":"ultrathink"}]}}
{"parentUuid":"5c08f8cc-c1a4-4ffc-ae95-8afd527b2f85","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01Drpd7Fi3v7surn1a4zWY8r","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"thinking","thinking":"The user wants me to rewrite the AI_ACTIONS_REFERENCE.md file to:\n1. Create dedicated sections for:\n   - Frontend workflows (workflow action nodes, their config, etc.)\n   - WorkflowManager function\n   - AI_API function\n2. Remove all bug documentation but note inconsistencies and issues\n3. Verify schemas and explain differences in logic between actions\n4. Visually and in writing explain how they all relate to one another\n5. \"ultrathink\" - this suggests I should think deeply about this\n\nThis is a complex task that requires:\n1. Reading the current AI_ACTIONS_REFERENCE.md (already done)\n2. Reading the frontend workflow utils\n3. Reading the WorkflowManager implementation\n4. Reading the AI_API implementation\n5. Understanding the schemas and data flow\n6. Creating a comprehensive document that shows how they relate\n\nThis is a multi-step analysis and documentation task. I should use the TodoWrite tool to plan this out, then execute systematically.\n\nLet me start by creating a todo list for this task.","signature":"EpcJCkYICBgCKkD8Ep0Sh6zYUhVsgz/mI2HBterP9xuTmn8VLpJ1GArUHJPLpSY3lRIwBD8Nmtf5f29fS9+4elrAP+UEyIGN5YTSEgyLhvSaXKptAYNFM9MaDDkaWpvB5xgXI/us6iIwUpWAO5sa710YLzOB/H/+EMQnZfkkIP+Ak2vvLsccwanJraN4clCtHbxg6WdWUdNmKv4HZEuXcK5G0dljX92ZuXfp1miUte52nS3X2hrR4iBH1aW9YxghsyK3Snz5MTv5XnIXGxPTts8i4XlxWbm1PH5iYOP7A0VBsh7dZzCXm9jvJ6LoRQcTe+lgA+d6Od9p9HcN4vcO+yd8LW3efAR+SUkmapqGlXGXhcbIB0rRLqv/FHFvWVzMFpP1IKkdrJFJfICQVsye+4Sk+4LwxkBYCuOkM6bpcxoOtOwwOfxYVZ5OfqrcwSzhvCaB6+0pywaOmG2u5keFRHP3Ocjketl0MbJzRCcMnIYvjNY0/ktlhh/DcWahfaIiX+hgAtDyvAAll6R9baekuSVrgFGJQfLXL0A1U+60F+hU3jqoowls5f4G5pTD8UMquLZ54UCB9A1D876engd7/mrdKUlh+Ib26IioJHf+VYwdwhgOJCeMJegG9gn8EWyxbBRb+cYCGvgKvRrommJuVFKFjqE/wslVOojyu4BUR2kDa525PjWw0Uj+EGxQ+f5YJWr/J7TyRge8E8+6dcMdjlxVPbKkYsWXBGERxYdMdYpbG6i70TQSz8ZswbccsX3lInVSqpCmqqBgZheHXKlQSynv8eXJxCRpj/2AbZIEjLA3pcUi6Si66vMhIKLrZ/+9KbE5bqIHhP7tsNIqNjg+olR0s9UOozjnTUEu92SE/pjIg3+4Fxqz68I/Zrvjt8cKS94xePLEDYX+7mqNTOhewedhGFVgJVxAdh3qRn2xhQIg5qHEyD5C/X+NMye4V80Wrf0JWzjJBauee95lX9LCaBWZ24Z+m2j4Aq6eznPPUcBGSqPQIxZZ6M1n5fWft7MP4SK4etB/YwV260PM88soK1Dr2xijJr9mKyXbK+5ZtD8vxqEFL0p4evJkz8O3RA/nTiRaHNqwGkcJE32lSfXRfj9okodPD60Kp7mOYyVuS283TtRcRlndggnxUOTuF43Aw7sGicmQlCWk26cxyVpIuqMCYVbGpIQAmZaiKgX0mcI+ZB43iytHKjDf/g9GKPA0WFEKRM+pB4iK/h4Q9yXAKZoD3ST+52QpU2t8ygM4/taxOMglw5lPs0TpzTZ7+gsozG4E6/qZMtWvgrK+CbjvGQqNUFSpMELUVswy+Y613FE5vwuPSz16ebMtzewYSdJ2l76r6yPqmGmCGrOClFJS5aLwqtNHTEsxw58HTIEYr52bWY8/n/Vi2hJGSRYcxZzQbVQJJOQj9se/6nGoo9hFwSmI1S2O8LU6LAVuyZ4SshWTpW9YzgZnMkE3FYu5Frxu0wHL9MTUHr/M4JlG9oh4WP+xcJmkYMGD4+y6sZb684MP82bqLd2IBq1Ur0HI8ICLNqlpIPJZ+tWK+MAGOzdGexv37vpNrfnJzs8YAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":31574,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":31574,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CTfE2foXxg1PPztRHp618","type":"assistant","uuid":"9db702d8-a9d3-477c-8fb8-acf5f0facb62","timestamp":"2025-09-30T20:35:26.475Z"}
{"parentUuid":"9db702d8-a9d3-477c-8fb8-acf5f0facb62","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01Drpd7Fi3v7surn1a4zWY8r","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"text","text":"I'll rewrite the AI_ACTIONS_REFERENCE.md to provide a comprehensive view of AI actions across the frontend, WorkflowManager, and AI_API. Let me start by analyzing each part of the system."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":31574,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":31574,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CTfE2foXxg1PPztRHp618","type":"assistant","uuid":"91dd21d7-b542-4b6c-8bee-9078dfc4d71b","timestamp":"2025-09-30T20:35:27.620Z"}
{"parentUuid":"91dd21d7-b542-4b6c-8bee-9078dfc4d71b","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01Drpd7Fi3v7surn1a4zWY8r","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_013ZNyu6yybDJD7935YpWzAB","name":"TodoWrite","input":{"todos":[{"content":"Read frontend workflow utilities to understand action nodes and configs","activeForm":"Reading frontend workflow utilities","status":"in_progress"},{"content":"Read WorkflowManager AI action handlers","activeForm":"Reading WorkflowManager AI action handlers","status":"pending"},{"content":"Read AI_API implementation and schemas","activeForm":"Reading AI_API implementation","status":"pending"},{"content":"Analyze schemas and data flow between all three layers","activeForm":"Analyzing schemas and data flow","status":"pending"},{"content":"Create comprehensive rewritten documentation with visual diagrams","activeForm":"Creating comprehensive documentation","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":31574,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":31574,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CTfE2foXxg1PPztRHp618","type":"assistant","uuid":"59f56c12-a04b-4e83-af6f-37f3ff353df7","timestamp":"2025-09-30T20:35:30.551Z"}
{"parentUuid":"59f56c12-a04b-4e83-af6f-37f3ff353df7","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013ZNyu6yybDJD7935YpWzAB","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"3ee54587-8a4f-4c0e-ac0e-f9bdcaf6d226","timestamp":"2025-09-30T20:35:30.665Z","toolUseResult":{"oldTodos":[],"newTodos":[{"content":"Read frontend workflow utilities to understand action nodes and configs","status":"in_progress","activeForm":"Reading frontend workflow utilities"},{"content":"Read WorkflowManager AI action handlers","status":"pending","activeForm":"Reading WorkflowManager AI action handlers"},{"content":"Read AI_API implementation and schemas","status":"pending","activeForm":"Reading AI_API implementation"},{"content":"Analyze schemas and data flow between all three layers","status":"pending","activeForm":"Analyzing schemas and data flow"},{"content":"Create comprehensive rewritten documentation with visual diagrams","status":"pending","activeForm":"Creating comprehensive documentation"}]}}
{"parentUuid":"3ee54587-8a4f-4c0e-ac0e-f9bdcaf6d226","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01NDsV4866MFa33Fydc69iu7","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"thinking","thinking":"Good, I've created the todo list. Now let me start reading the files I need:\n\n1. First, the frontend workflow utilities\n2. Then WorkflowManager\n3. Then AI_API\n\nLet me read these files in parallel to be efficient.","signature":"Ev4CCkYICBgCKkCetFAlwRV6qxgzqT3yyAnjcWLBaOjVP6gVlOMy5O0gJsnyqAdh6R5LZVktq1Wrp9UPgz8Rann/2ShS+cBR6IO5EgwnGh/vft/p7P2SMhkaDAIsBNzhslXGB2tXviIwznJZjyR+tlRng2J9xa++WfR0ckGsuE7T6Gqpci6bAhcJTFsO5hARaHvEY1dxUbrpKuUBu6rkjQIx2yfzbmiEubxX2DhjAhSdGMMUcPnyu8XB43U9nDTj94/tq6sc8qgkkjfqaFa7yONW7Rg16bhbUO8YlSnCfmtnlNce97UjES7Q+CAAfg+tfnFTCB5KI3C0fSQWNu1+tgaDFJaea1yKp0ZtTF3dUBsjNUWcKAlmoHjwJvhfFoV7VwFBfelOkqspWYT4V+hx4PRPEeD6jJcIgA9/lyriY2jTt1NVR0xdCM3w6fgLdXUrmJBaWe3DpMqitkfAB1icha/ClwvYH7wXZ8AVj8auqj+mEPRMnvdanqoeK6lVVVTSFhgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":553,"cache_read_input_tokens":31574,"cache_creation":{"ephemeral_5m_input_tokens":553,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CTfE3VpYLY1VhZ74q1oyT","type":"assistant","uuid":"85c51c69-f374-4b16-991c-7de8dc4a28df","timestamp":"2025-09-30T20:35:34.954Z"}
{"parentUuid":"85c51c69-f374-4b16-991c-7de8dc4a28df","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01NDsV4866MFa33Fydc69iu7","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_01LjMNLYmBBsZ3gaKXw7xZcd","name":"Read","input":{"file_path":"/Users/natedamstra/socialaize/src/utils/workflowUtils.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":553,"cache_read_input_tokens":31574,"cache_creation":{"ephemeral_5m_input_tokens":553,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CTfE3VpYLY1VhZ74q1oyT","type":"assistant","uuid":"2be34f5c-ddd9-4cf4-99fd-0b6348119589","timestamp":"2025-09-30T20:35:35.991Z"}
{"parentUuid":"2be34f5c-ddd9-4cf4-99fd-0b6348119589","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01NDsV4866MFa33Fydc69iu7","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_012GSwERGGZeT7cs8TEh7Jsz","name":"Read","input":{"file_path":"/Users/natedamstra/socialaize/src/schemas/workflows/actionSchemas.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":553,"cache_read_input_tokens":31574,"cache_creation":{"ephemeral_5m_input_tokens":553,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CTfE3VpYLY1VhZ74q1oyT","type":"assistant","uuid":"5bb84a49-1f13-4d46-a72c-e338ffb5b82e","timestamp":"2025-09-30T20:35:36.829Z"}
{"parentUuid":"5bb84a49-1f13-4d46-a72c-e338ffb5b82e","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01NDsV4866MFa33Fydc69iu7","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_01YAZrawJVGieM69WpdTGvzq","name":"Glob","input":{"pattern":"functions/WorkflowManager/src/handlers/actions/aiActions.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":553,"cache_read_input_tokens":31574,"cache_creation":{"ephemeral_5m_input_tokens":553,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CTfE3VpYLY1VhZ74q1oyT","type":"assistant","uuid":"36d91e99-2acb-4f25-bc43-4d323f23015b","timestamp":"2025-09-30T20:35:37.493Z"}
{"parentUuid":"36d91e99-2acb-4f25-bc43-4d323f23015b","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01NDsV4866MFa33Fydc69iu7","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_01RD6mVbanpUthUFCDYaUD7B","name":"Glob","input":{"pattern":"functions/AI_API/**/*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":553,"cache_read_input_tokens":31574,"cache_creation":{"ephemeral_5m_input_tokens":553,"ephemeral_1h_input_tokens":0},"output_tokens":289,"service_tier":"standard"}},"requestId":"req_011CTfE3VpYLY1VhZ74q1oyT","type":"assistant","uuid":"cd3d64e4-ff0f-497d-99b1-c50fcac69527","timestamp":"2025-09-30T20:35:37.881Z"}
{"parentUuid":"cd3d64e4-ff0f-497d-99b1-c50fcac69527","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LjMNLYmBBsZ3gaKXw7xZcd","type":"tool_result","content":"     1→import type { Workflow } from \"@appwrite/schemas/workflow\";\n     2→import type { WorkflowNode } from \"@appwrite/schemas/workflowNode\";\n     3→import type {\n     4→  AIAddTagsActionConfig,\n     5→  AIAddTitleActionConfig,\n     6→  AIGenerateContentActionConfig,\n     7→  AIRewriteActionConfig,\n     8→  AISummarizeActionConfig,\n     9→  TranslateActionConfig,\n    10→} from \"@/schemas/workflows/actionSchemas\";\n    11→\n    12→export interface ActionOption {\n    13→  value: WorkflowNode[\"action\"];\n    14→  label: string;\n    15→  enabled: boolean;\n    16→  description?: string;\n    17→  needsTarget?: boolean;\n    18→  nodeType?: \"ACTION\" | \"SWITCH\" | \"FORK\" | \"JOIN\";\n    19→}\n    20→\n    21→export interface ActionCategory {\n    22→  name: string;\n    23→  icon: string;\n    24→  actions: ActionOption[];\n    25→}\n    26→\n    27→export const getDefaultConfig = (actionType: string) => {\n    28→  // Base config that all AI actions inherit from BaseActionSchema\n    29→  const baseConfig = {\n    30→    user_instructions: \"\",\n    31→    conditions: [],\n    32→  };\n    33→\n    34→  switch (actionType) {\n    35→    case \"ai_gen_content\":\n    36→      return {\n    37→        ...baseConfig,\n    38→        length: \"same\",\n    39→        tone: \"match\",\n    40→        style: \"match\",\n    41→        format: \"paragraph\",\n    42→        content: \"\",\n    43→      } as AIGenerateContentActionConfig;\n    44→\n    45→    case \"ai_generate_content\":\n    46→      return {\n    47→        ...baseConfig,\n    48→        length: \"same\",\n    49→        tone: \"match\",\n    50→        style: \"match\",\n    51→        format: \"paragraph\",\n    52→        content: \"\",\n    53→      } as AIGenerateContentActionConfig;\n    54→\n    55→    case \"ai_translate\":\n    56→      return {\n    57→        ...baseConfig,\n    58→        content: \"\",\n    59→        language: \"en\",\n    60→        preserve_formatting: true,\n    61→      } as TranslateActionConfig;\n    62→\n    63→    case \"ai_rewrite\":\n    64→      return {\n    65→        ...baseConfig,\n    66→        style: \"professional\",\n    67→        tone: \"neutral\",\n    68→        length: \"same\",\n    69→        content: \"\",\n    70→      } as AIRewriteActionConfig;\n    71→\n    72→    case \"ai_summarize\":\n    73→      return {\n    74→        ...baseConfig,\n    75→        max_length: undefined,\n    76→        format: \"paragraph\",\n    77→        content: \"\",\n    78→      } as AISummarizeActionConfig;\n    79→\n    80→    case \"ai_gen_title\":\n    81→      return {\n    82→        ...baseConfig,\n    83→        content: \"\",\n    84→        style: \"professional\",\n    85→        max_length: undefined,\n    86→      } as AIAddTitleActionConfig;\n    87→\n    88→    case \"ai_add_title\":\n    89→      return {\n    90→        ...baseConfig,\n    91→        content: \"\",\n    92→        style: \"professional\",\n    93→        max_length: undefined,\n    94→      } as AIAddTitleActionConfig;\n    95→\n    96→    case \"ai_gen_tags\":\n    97→      return {\n    98→        ...baseConfig,\n    99→        content: \"\",\n   100→        maxTags: undefined,\n   101→        categories: [],\n   102→      } as AIAddTagsActionConfig;\n   103→\n   104→    case \"ai_add_tags\":\n   105→      return {\n   106→        ...baseConfig,\n   107→        content: \"\",\n   108→      } as AIAddTagsActionConfig;\n   109→\n   110→    // Non-AI actions don't need the baseConfig\n   111→    case \"wait\":\n   112→      return {\n   113→        duration: 5,\n   114→        unit: \"minutes\",\n   115→      };\n   116→\n   117→    case \"publish_content\":\n   118→      return {\n   119→        schedule_time: null,\n   120→        platform_specific: {},\n   121→      };\n   122→\n   123→    case \"set_content\":\n   124→      return {\n   125→        content: \"\",\n   126→      };\n   127→\n   128→    case \"set_tags\":\n   129→      return {\n   130→        tags: [],\n   131→      };\n   132→\n   133→    case \"set_title\":\n   134→      return {\n   135→        title: \"\",\n   136→      };\n   137→\n   138→    case \"if_condition\":\n   139→      return {\n   140→        conditions: [\n   141→          {\n   142→            type: \"post_type_is\",\n   143→            value: \"\",\n   144→          },\n   145→        ],\n   146→      };\n   147→\n   148→    default:\n   149→      return {};\n   150→  }\n   151→};\n   152→\n   153→export const getActionIcon = (action?: string, nodeType?: string) => {\n   154→  if (!action) {\n   155→    // Default icons for special node types\n   156→    const nodeTypeIcons: Record<string, string> = {\n   157→      SWITCH: \"mdi:call-split\",\n   158→      FORK: \"mdi:source-fork\",\n   159→      JOIN: \"mdi:source-merge\",\n   160→    };\n   161→    return nodeTypeIcons[nodeType || \"\"] || \"mdi:cog\";\n   162→  }\n   163→\n   164→  const iconMap: Record<string, string> = {\n   165→    ai_gen_title: \"mdi:format-title\",\n   166→    ai_gen_tags: \"mdi:tag-multiple\",\n   167→    ai_gen_content: \"mdi:robot\",\n   168→    ai_generate_content: \"mdi:robot\",\n   169→    ai_summarize: \"mdi:text-box\",\n   170→    ai_translate: \"mdi:translate\",\n   171→    ai_rewrite: \"mdi:robot\",\n   172→    ai_add_title: \"mdi:format-title\",\n   173→    ai_add_tags: \"mdi:tag-multiple\",\n   174→    set_title: \"mdi:format-title\",\n   175→    set_content: \"mdi:pencil\",\n   176→    set_tags: \"mdi:tag-multiple\",\n   177→    schedule_post: \"mdi:clock\",\n   178→    publish_content: \"mdi:send\",\n   179→    add_image: \"mdi:image\",\n   180→    fetch_content: \"mdi:download\",\n   181→    reply_to_comment: \"mdi:reply\",\n   182→    reply_to_message: \"mdi:message-reply\",\n   183→    wait: \"mdi:timer\",\n   184→    if_condition: \"mdi:code-brackets\",\n   185→  };\n   186→\n   187→  return iconMap[action] || \"mdi:cog\";\n   188→};\n   189→\n   190→export const getIconColorClass = (nodeType?: string) => {\n   191→  switch (nodeType) {\n   192→    case \"SWITCH\":\n   193→      return \"text-blue-500\";\n   194→    case \"FORK\":\n   195→      return \"text-green-500\";\n   196→    case \"JOIN\":\n   197→      return \"text-yellow-500\";\n   198→    default:\n   199→      return \"text-gray-500\";\n   200→  }\n   201→};\n   202→\n   203→export const isEndNode = (node: WorkflowNode, nodes: WorkflowNode[]) => {\n   204→  const connections = JSON.parse(node.connections || \"{}\");\n   205→\n   206→  switch (node.nodeType) {\n   207→    case \"SWITCH\":\n   208→      // A SWITCH is an end node if it has no cases and no default path\n   209→      return !connections.cases?.length && !connections.default;\n   210→\n   211→    case \"FORK\":\n   212→      // A FORK is an end node if it has no branches\n   213→      return !connections.branches?.length;\n   214→\n   215→    case \"JOIN\":\n   216→      // A JOIN is an end node if it has no next connection\n   217→      return !connections.next;\n   218→\n   219→    default: // ACTION\n   220→      // An ACTION is an end node if it has no next connection AND\n   221→      // no other nodes point to anything after it\n   222→      if (!connections.next) {\n   223→        // Check if any other node points to something after this one\n   224→        return !nodes.some((otherNode) => {\n   225→          if (otherNode.$id === node.$id) return false;\n   226→          const otherConnections = JSON.parse(otherNode.connections || \"{}\");\n   227→\n   228→          switch (otherNode.nodeType) {\n   229→            case \"SWITCH\":\n   230→              return (\n   231→                otherConnections.cases?.some(\n   232→                  (c: any) => c.nodeId === node.$id\n   233→                ) || otherConnections.default === node.$id\n   234→              );\n   235→            case \"FORK\":\n   236→              return otherConnections.branches?.includes(node.$id);\n   237→            case \"JOIN\":\n   238→              return (\n   239→                otherConnections.requiredBranches?.includes(node.$id) ||\n   240→                otherConnections.next === node.$id\n   241→              );\n   242→            default:\n   243→              return otherConnections.next === node.$id;\n   244→          }\n   245→        });\n   246→      }\n   247→      return false;\n   248→  }\n   249→};\n   250→\n   251→export const ACTION_CATEGORIES: Record<string, ActionCategory> = {\n   252→  PUBLISHING: {\n   253→    name: \"Publishing\",\n   254→    icon: \"mdi:send\",\n   255→    actions: [\n   256→      {\n   257→        value: \"publish_content\",\n   258→        label: \"Publish Content\",\n   259→        enabled: true,\n   260→        needsTarget: true,\n   261→        description:\n   262→          \"Schedule or immediately publish your content to the selected platform\",\n   263→      },\n   264→    ],\n   265→  },\n   266→  CONTROL: {\n   267→    name: \"Flow Control\",\n   268→    icon: \"mdi:flow\",\n   269→    actions: [\n   270→      {\n   271→        value: \"switch\",\n   272→        label: \"Switch\",\n   273→        nodeType: \"SWITCH\",\n   274→        enabled: false,\n   275→        description: \"Branch workflow based on conditions\",\n   276→      },\n   277→      {\n   278→        value: \"fork\",\n   279→        label: \"Fork\",\n   280→        nodeType: \"FORK\",\n   281→        enabled: false,\n   282→        description: \"Split workflow into parallel branches\",\n   283→      },\n   284→      {\n   285→        value: \"join\",\n   286→        label: \"Join\",\n   287→        nodeType: \"JOIN\",\n   288→        enabled: false,\n   289→        description: \"Merge parallel branches back together\",\n   290→      },\n   291→      {\n   292→        value: \"wait\",\n   293→        label: \"Wait\",\n   294→        enabled: false,\n   295→        description: \"Pause the workflow for a specified duration\",\n   296→      },\n   297→      {\n   298→        value: \"if_condition\",\n   299→        label: \"If Condition\",\n   300→        enabled: false,\n   301→        description: \"Add conditional logic to your workflow\",\n   302→      },\n   303→    ],\n   304→  },\n   305→  AI: {\n   306→    name: \"AI Actions\",\n   307→    icon: \"mdi:robot\",\n   308→    actions: [\n   309→      {\n   310→        value: \"ai_rewrite\",\n   311→        label: \"AI Rewrite Content\",\n   312→        enabled: true,\n   313→        description:\n   314→          \"Rewrite your content using AI while maintaining the same meaning\",\n   315→      },\n   316→      {\n   317→        value: \"ai_translate\",\n   318→        label: \"AI Translate Content\",\n   319→        enabled: true,\n   320→        description: \"Translate your content to different languages using AI\",\n   321→      },\n   322→      {\n   323→        value: \"ai_summarize\",\n   324→        label: \"AI Summarize Content\",\n   325→        enabled: false,\n   326→        description: \"Create a concise summary of your content using AI\",\n   327→      },\n   328→      {\n   329→        value: \"ai_add_title\",\n   330→        label: \"AI Add Title\",\n   331→        enabled: true,\n   332→        description: \"Add a title to your content using AI\",\n   333→      },\n   334→      {\n   335→        value: \"ai_gen_title\",\n   336→        label: \"AI Generate Title\",\n   337→        enabled: true,\n   338→        description: \"Generate an engaging title for your content using AI\",\n   339→      },\n   340→      {\n   341→        value: \"ai_add_tags\",\n   342→        label: \"AI Generate Tags\",\n   343→        enabled: true,\n   344→        description: \"Generate relevant tags for your content using AI\",\n   345→      },\n   346→      {\n   347→        value: \"ai_gen_tags\",\n   348→        label: \"AI Generate Tags\",\n   349→        enabled: true,\n   350→        description: \"Generate relevant tags for your content using AI\",\n   351→      },\n   352→      {\n   353→        value: \"ai_gen_content\",\n   354→        label: \"AI Generate Content\",\n   355→        enabled: true,\n   356→        description: \"Generate new content from scratch using AI\",\n   357→      },\n   358→    ],\n   359→  },\n   360→  CONTENT: {\n   361→    name: \"Content Management\",\n   362→    icon: \"mdi:file-document-edit\",\n   363→    actions: [\n   364→      {\n   365→        value: \"set_title\",\n   366→        label: \"Set Title\",\n   367→        enabled: true,\n   368→        description: \"Manually set the title of your content\",\n   369→      },\n   370→      {\n   371→        value: \"set_content\",\n   372→        label: \"Set Content\",\n   373→        enabled: true,\n   374→        description: \"Manually set or edit the main content\",\n   375→      },\n   376→      {\n   377→        value: \"set_tags\",\n   378→        label: \"Set Tags\",\n   379→        enabled: true,\n   380→        description: \"Manually add or edit content tags\",\n   381→      },\n   382→      {\n   383→        value: \"fetch_content\",\n   384→        label: \"Fetch Content\",\n   385→        enabled: false,\n   386→        description: \"Import content from an external URL\",\n   387→      },\n   388→    ],\n   389→  },\n   390→  INTERACTION: {\n   391→    name: \"Interaction\",\n   392→    icon: \"mdi:reply\",\n   393→    actions: [\n   394→      {\n   395→        value: \"reply_to_comment\",\n   396→        label: \"Reply to Comment\",\n   397→        enabled: false,\n   398→        description: \"Automatically respond to comments on your content\",\n   399→      },\n   400→      {\n   401→        value: \"reply_to_message\",\n   402→        label: \"Reply to Message\",\n   403→        enabled: false,\n   404→        description: \"Automatically respond to direct messages\",\n   405→      },\n   406→    ],\n   407→  },\n   408→};\n   409→\n   410→export const formatTriggerAction = (action?: string) => {\n   411→  if (!action) return \"\";\n   412→  if (action === \"on_new_post\") return \"When I Create a New Post\";\n   413→  if (action === \"on_new_comment\") return \"When I Receive a New Comment\";\n   414→  if (action === \"on_new_message\") return \"When I Receive a New Message\";\n   415→  if (action === \"on_new_follower\") return \"When I Gain a New Follower\";\n   416→  if (action === \"on_new_like\") return \"When I Receive a New Like\";\n   417→  if (action === \"on_new_view\") return \"When I Receive a New View\";\n   418→};\n   419→\n   420→export const formatAction = (action?: string) => {\n   421→  if (!action) return \"\";\n   422→  return action\n   423→    .replace(/_/g, \" \")\n   424→    .replace(/\\b\\w/g, (l) => l.toUpperCase())\n   425→    .replace(/Ai/g, \"AI\");\n   426→};\n   427→\n   428→export const formatPostType = (postType?: string) => {\n   429→  if (!postType) return \"\";\n   430→  switch (postType.toLowerCase()) {\n   431→    case \"text\":\n   432→      return \"Text posts\";\n   433→    case \"caption image\":\n   434→      return \"Images with or without a caption\";\n   435→    case \"image\":\n   436→      return \"Image posts\";\n   437→    case \"video\":\n   438→      return \"Video posts\";\n   439→    case \"caption video\":\n   440→      return \"Videos with or without a caption\";\n   441→    case \"story\":\n   442→      return \"Story posts\";\n   443→    case \"carousel\":\n   444→      return \"Carousel posts\";\n   445→  }\n   446→};\n   447→\n   448→export const isLastNode = (node: WorkflowNode, nodes: WorkflowNode[]) => {\n   449→  const connections = JSON.parse(node.connections || \"{}\");\n   450→  return !connections.next && nodes.indexOf(node) === nodes.length - 1;\n   451→};\n   452→\n   453→export const getActionDescription = (action: string) => {\n   454→  const allActions = Object.values(ACTION_CATEGORIES).flatMap((c) => c.actions);\n   455→  return allActions.find((a) => a.value === action)?.description;\n   456→};\n   457→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"ec5b264a-89da-415d-b5d8-0743a3b431dd","timestamp":"2025-09-30T20:35:38.018Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/natedamstra/socialaize/src/utils/workflowUtils.ts","content":"import type { Workflow } from \"@appwrite/schemas/workflow\";\nimport type { WorkflowNode } from \"@appwrite/schemas/workflowNode\";\nimport type {\n  AIAddTagsActionConfig,\n  AIAddTitleActionConfig,\n  AIGenerateContentActionConfig,\n  AIRewriteActionConfig,\n  AISummarizeActionConfig,\n  TranslateActionConfig,\n} from \"@/schemas/workflows/actionSchemas\";\n\nexport interface ActionOption {\n  value: WorkflowNode[\"action\"];\n  label: string;\n  enabled: boolean;\n  description?: string;\n  needsTarget?: boolean;\n  nodeType?: \"ACTION\" | \"SWITCH\" | \"FORK\" | \"JOIN\";\n}\n\nexport interface ActionCategory {\n  name: string;\n  icon: string;\n  actions: ActionOption[];\n}\n\nexport const getDefaultConfig = (actionType: string) => {\n  // Base config that all AI actions inherit from BaseActionSchema\n  const baseConfig = {\n    user_instructions: \"\",\n    conditions: [],\n  };\n\n  switch (actionType) {\n    case \"ai_gen_content\":\n      return {\n        ...baseConfig,\n        length: \"same\",\n        tone: \"match\",\n        style: \"match\",\n        format: \"paragraph\",\n        content: \"\",\n      } as AIGenerateContentActionConfig;\n\n    case \"ai_generate_content\":\n      return {\n        ...baseConfig,\n        length: \"same\",\n        tone: \"match\",\n        style: \"match\",\n        format: \"paragraph\",\n        content: \"\",\n      } as AIGenerateContentActionConfig;\n\n    case \"ai_translate\":\n      return {\n        ...baseConfig,\n        content: \"\",\n        language: \"en\",\n        preserve_formatting: true,\n      } as TranslateActionConfig;\n\n    case \"ai_rewrite\":\n      return {\n        ...baseConfig,\n        style: \"professional\",\n        tone: \"neutral\",\n        length: \"same\",\n        content: \"\",\n      } as AIRewriteActionConfig;\n\n    case \"ai_summarize\":\n      return {\n        ...baseConfig,\n        max_length: undefined,\n        format: \"paragraph\",\n        content: \"\",\n      } as AISummarizeActionConfig;\n\n    case \"ai_gen_title\":\n      return {\n        ...baseConfig,\n        content: \"\",\n        style: \"professional\",\n        max_length: undefined,\n      } as AIAddTitleActionConfig;\n\n    case \"ai_add_title\":\n      return {\n        ...baseConfig,\n        content: \"\",\n        style: \"professional\",\n        max_length: undefined,\n      } as AIAddTitleActionConfig;\n\n    case \"ai_gen_tags\":\n      return {\n        ...baseConfig,\n        content: \"\",\n        maxTags: undefined,\n        categories: [],\n      } as AIAddTagsActionConfig;\n\n    case \"ai_add_tags\":\n      return {\n        ...baseConfig,\n        content: \"\",\n      } as AIAddTagsActionConfig;\n\n    // Non-AI actions don't need the baseConfig\n    case \"wait\":\n      return {\n        duration: 5,\n        unit: \"minutes\",\n      };\n\n    case \"publish_content\":\n      return {\n        schedule_time: null,\n        platform_specific: {},\n      };\n\n    case \"set_content\":\n      return {\n        content: \"\",\n      };\n\n    case \"set_tags\":\n      return {\n        tags: [],\n      };\n\n    case \"set_title\":\n      return {\n        title: \"\",\n      };\n\n    case \"if_condition\":\n      return {\n        conditions: [\n          {\n            type: \"post_type_is\",\n            value: \"\",\n          },\n        ],\n      };\n\n    default:\n      return {};\n  }\n};\n\nexport const getActionIcon = (action?: string, nodeType?: string) => {\n  if (!action) {\n    // Default icons for special node types\n    const nodeTypeIcons: Record<string, string> = {\n      SWITCH: \"mdi:call-split\",\n      FORK: \"mdi:source-fork\",\n      JOIN: \"mdi:source-merge\",\n    };\n    return nodeTypeIcons[nodeType || \"\"] || \"mdi:cog\";\n  }\n\n  const iconMap: Record<string, string> = {\n    ai_gen_title: \"mdi:format-title\",\n    ai_gen_tags: \"mdi:tag-multiple\",\n    ai_gen_content: \"mdi:robot\",\n    ai_generate_content: \"mdi:robot\",\n    ai_summarize: \"mdi:text-box\",\n    ai_translate: \"mdi:translate\",\n    ai_rewrite: \"mdi:robot\",\n    ai_add_title: \"mdi:format-title\",\n    ai_add_tags: \"mdi:tag-multiple\",\n    set_title: \"mdi:format-title\",\n    set_content: \"mdi:pencil\",\n    set_tags: \"mdi:tag-multiple\",\n    schedule_post: \"mdi:clock\",\n    publish_content: \"mdi:send\",\n    add_image: \"mdi:image\",\n    fetch_content: \"mdi:download\",\n    reply_to_comment: \"mdi:reply\",\n    reply_to_message: \"mdi:message-reply\",\n    wait: \"mdi:timer\",\n    if_condition: \"mdi:code-brackets\",\n  };\n\n  return iconMap[action] || \"mdi:cog\";\n};\n\nexport const getIconColorClass = (nodeType?: string) => {\n  switch (nodeType) {\n    case \"SWITCH\":\n      return \"text-blue-500\";\n    case \"FORK\":\n      return \"text-green-500\";\n    case \"JOIN\":\n      return \"text-yellow-500\";\n    default:\n      return \"text-gray-500\";\n  }\n};\n\nexport const isEndNode = (node: WorkflowNode, nodes: WorkflowNode[]) => {\n  const connections = JSON.parse(node.connections || \"{}\");\n\n  switch (node.nodeType) {\n    case \"SWITCH\":\n      // A SWITCH is an end node if it has no cases and no default path\n      return !connections.cases?.length && !connections.default;\n\n    case \"FORK\":\n      // A FORK is an end node if it has no branches\n      return !connections.branches?.length;\n\n    case \"JOIN\":\n      // A JOIN is an end node if it has no next connection\n      return !connections.next;\n\n    default: // ACTION\n      // An ACTION is an end node if it has no next connection AND\n      // no other nodes point to anything after it\n      if (!connections.next) {\n        // Check if any other node points to something after this one\n        return !nodes.some((otherNode) => {\n          if (otherNode.$id === node.$id) return false;\n          const otherConnections = JSON.parse(otherNode.connections || \"{}\");\n\n          switch (otherNode.nodeType) {\n            case \"SWITCH\":\n              return (\n                otherConnections.cases?.some(\n                  (c: any) => c.nodeId === node.$id\n                ) || otherConnections.default === node.$id\n              );\n            case \"FORK\":\n              return otherConnections.branches?.includes(node.$id);\n            case \"JOIN\":\n              return (\n                otherConnections.requiredBranches?.includes(node.$id) ||\n                otherConnections.next === node.$id\n              );\n            default:\n              return otherConnections.next === node.$id;\n          }\n        });\n      }\n      return false;\n  }\n};\n\nexport const ACTION_CATEGORIES: Record<string, ActionCategory> = {\n  PUBLISHING: {\n    name: \"Publishing\",\n    icon: \"mdi:send\",\n    actions: [\n      {\n        value: \"publish_content\",\n        label: \"Publish Content\",\n        enabled: true,\n        needsTarget: true,\n        description:\n          \"Schedule or immediately publish your content to the selected platform\",\n      },\n    ],\n  },\n  CONTROL: {\n    name: \"Flow Control\",\n    icon: \"mdi:flow\",\n    actions: [\n      {\n        value: \"switch\",\n        label: \"Switch\",\n        nodeType: \"SWITCH\",\n        enabled: false,\n        description: \"Branch workflow based on conditions\",\n      },\n      {\n        value: \"fork\",\n        label: \"Fork\",\n        nodeType: \"FORK\",\n        enabled: false,\n        description: \"Split workflow into parallel branches\",\n      },\n      {\n        value: \"join\",\n        label: \"Join\",\n        nodeType: \"JOIN\",\n        enabled: false,\n        description: \"Merge parallel branches back together\",\n      },\n      {\n        value: \"wait\",\n        label: \"Wait\",\n        enabled: false,\n        description: \"Pause the workflow for a specified duration\",\n      },\n      {\n        value: \"if_condition\",\n        label: \"If Condition\",\n        enabled: false,\n        description: \"Add conditional logic to your workflow\",\n      },\n    ],\n  },\n  AI: {\n    name: \"AI Actions\",\n    icon: \"mdi:robot\",\n    actions: [\n      {\n        value: \"ai_rewrite\",\n        label: \"AI Rewrite Content\",\n        enabled: true,\n        description:\n          \"Rewrite your content using AI while maintaining the same meaning\",\n      },\n      {\n        value: \"ai_translate\",\n        label: \"AI Translate Content\",\n        enabled: true,\n        description: \"Translate your content to different languages using AI\",\n      },\n      {\n        value: \"ai_summarize\",\n        label: \"AI Summarize Content\",\n        enabled: false,\n        description: \"Create a concise summary of your content using AI\",\n      },\n      {\n        value: \"ai_add_title\",\n        label: \"AI Add Title\",\n        enabled: true,\n        description: \"Add a title to your content using AI\",\n      },\n      {\n        value: \"ai_gen_title\",\n        label: \"AI Generate Title\",\n        enabled: true,\n        description: \"Generate an engaging title for your content using AI\",\n      },\n      {\n        value: \"ai_add_tags\",\n        label: \"AI Generate Tags\",\n        enabled: true,\n        description: \"Generate relevant tags for your content using AI\",\n      },\n      {\n        value: \"ai_gen_tags\",\n        label: \"AI Generate Tags\",\n        enabled: true,\n        description: \"Generate relevant tags for your content using AI\",\n      },\n      {\n        value: \"ai_gen_content\",\n        label: \"AI Generate Content\",\n        enabled: true,\n        description: \"Generate new content from scratch using AI\",\n      },\n    ],\n  },\n  CONTENT: {\n    name: \"Content Management\",\n    icon: \"mdi:file-document-edit\",\n    actions: [\n      {\n        value: \"set_title\",\n        label: \"Set Title\",\n        enabled: true,\n        description: \"Manually set the title of your content\",\n      },\n      {\n        value: \"set_content\",\n        label: \"Set Content\",\n        enabled: true,\n        description: \"Manually set or edit the main content\",\n      },\n      {\n        value: \"set_tags\",\n        label: \"Set Tags\",\n        enabled: true,\n        description: \"Manually add or edit content tags\",\n      },\n      {\n        value: \"fetch_content\",\n        label: \"Fetch Content\",\n        enabled: false,\n        description: \"Import content from an external URL\",\n      },\n    ],\n  },\n  INTERACTION: {\n    name: \"Interaction\",\n    icon: \"mdi:reply\",\n    actions: [\n      {\n        value: \"reply_to_comment\",\n        label: \"Reply to Comment\",\n        enabled: false,\n        description: \"Automatically respond to comments on your content\",\n      },\n      {\n        value: \"reply_to_message\",\n        label: \"Reply to Message\",\n        enabled: false,\n        description: \"Automatically respond to direct messages\",\n      },\n    ],\n  },\n};\n\nexport const formatTriggerAction = (action?: string) => {\n  if (!action) return \"\";\n  if (action === \"on_new_post\") return \"When I Create a New Post\";\n  if (action === \"on_new_comment\") return \"When I Receive a New Comment\";\n  if (action === \"on_new_message\") return \"When I Receive a New Message\";\n  if (action === \"on_new_follower\") return \"When I Gain a New Follower\";\n  if (action === \"on_new_like\") return \"When I Receive a New Like\";\n  if (action === \"on_new_view\") return \"When I Receive a New View\";\n};\n\nexport const formatAction = (action?: string) => {\n  if (!action) return \"\";\n  return action\n    .replace(/_/g, \" \")\n    .replace(/\\b\\w/g, (l) => l.toUpperCase())\n    .replace(/Ai/g, \"AI\");\n};\n\nexport const formatPostType = (postType?: string) => {\n  if (!postType) return \"\";\n  switch (postType.toLowerCase()) {\n    case \"text\":\n      return \"Text posts\";\n    case \"caption image\":\n      return \"Images with or without a caption\";\n    case \"image\":\n      return \"Image posts\";\n    case \"video\":\n      return \"Video posts\";\n    case \"caption video\":\n      return \"Videos with or without a caption\";\n    case \"story\":\n      return \"Story posts\";\n    case \"carousel\":\n      return \"Carousel posts\";\n  }\n};\n\nexport const isLastNode = (node: WorkflowNode, nodes: WorkflowNode[]) => {\n  const connections = JSON.parse(node.connections || \"{}\");\n  return !connections.next && nodes.indexOf(node) === nodes.length - 1;\n};\n\nexport const getActionDescription = (action: string) => {\n  const allActions = Object.values(ACTION_CATEGORIES).flatMap((c) => c.actions);\n  return allActions.find((a) => a.value === action)?.description;\n};\n","numLines":457,"startLine":1,"totalLines":457}}}
{"parentUuid":"ec5b264a-89da-415d-b5d8-0743a3b431dd","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012GSwERGGZeT7cs8TEh7Jsz","type":"tool_result","content":"     1→import { z } from \"zod\";\n     2→import { ENABLED_PROVIDERS } from \"@constants/providerConstants\";\n     3→import { type WorkflowNode } from \"@appwrite/schemas/workflowNode\";\n     4→type ActionType = WorkflowNode[\"action\"];\n     5→\n     6→export const ACTION_TYPES = [\n     7→  \"wait\",\n     8→  \"ai_translate\",\n     9→  \"publish_content\",\n    10→  \"ai_rewrite\",\n    11→  \"ai_summarize\",\n    12→  \"ai_gen_content\",\n    13→  \"reply_to_comment\",\n    14→  \"reply_to_message\",\n    15→  \"set_title\",\n    16→  \"set_tags\",\n    17→  \"set_content\",\n    18→  \"fetch_content\",\n    19→  \"ai_gen_title\",\n    20→  \"ai_gen_tags\",\n    21→] as const satisfies ActionType[];\n    22→\n    23→export const ActionTypeSchema = z.enum(ACTION_TYPES);\n    24→\n    25→export const StyleEnumSchema = z.enum([\n    26→  \"professional\",\n    27→  \"casual\",\n    28→  \"formal\",\n    29→  \"friendly\",\n    30→  \"match\",\n    31→]);\n    32→export type StyleEnum = z.infer<typeof StyleEnumSchema>;\n    33→\n    34→export const ToneEnumSchema = z.enum([\n    35→  \"positive\",\n    36→  \"neutral\",\n    37→  \"negative\",\n    38→  \"match\",\n    39→]);\n    40→export type ToneEnum = z.infer<typeof ToneEnumSchema>;\n    41→\n    42→export const LengthEnumSchema = z.enum([\"shorter\", \"same\", \"longer\"]);\n    43→export type LengthEnum = z.infer<typeof LengthEnumSchema>;\n    44→\n    45→export const FormatEnumSchema = z.enum([\n    46→  \"bullet_points\",\n    47→  \"paragraph\",\n    48→  \"key_points\",\n    49→]);\n    50→export type FormatEnum = z.infer<typeof FormatEnumSchema>;\n    51→\n    52→// Base schemas for common patterns\n    53→export const DurationSchema = z.object({\n    54→  duration: z.number().min(0).max(2592000), // max 30 days in seconds\n    55→});\n    56→\n    57→export const LanguageSchema = z.object({\n    58→  content: z.string(),\n    59→  language: z.string(),\n    60→  preserve_formatting: z.boolean().default(true),\n    61→});\n    62→\n    63→export const ContentSchema = z.object({\n    64→  content: z.string(),\n    65→  format: z.enum([\"markdown\", \"html\", \"plain\"]).default(\"plain\"),\n    66→});\n    67→\n    68→export const TitleSchema = z.object({\n    69→  title: z.string().min(1).max(200),\n    70→});\n    71→\n    72→export const TagsSchema = z.object({\n    73→  tags: z.array(z.string()),\n    74→  max_tags: z.number().optional(),\n    75→});\n    76→\n    77→export const ConditionSchema = z.discriminatedUnion(\"type\", [\n    78→  z.object({\n    79→    type: z.literal(\"content_contains\"),\n    80→    value: z.string(),\n    81→  }),\n    82→  z.object({\n    83→    type: z.literal(\"content_matches\"),\n    84→    value: z.string(),\n    85→  }),\n    86→  z.object({\n    87→    type: z.literal(\"hashtags_contain\"),\n    88→    value: z.string(),\n    89→  }),\n    90→  z.object({\n    91→    type: z.literal(\"platform_is\"),\n    92→    value: z.string(),\n    93→  }),\n    94→  z.object({\n    95→    type: z.literal(\"post_type_is\"),\n    96→    value: z.string(),\n    97→  }),\n    98→  z.object({\n    99→    type: z.literal(\"video_duration\"),\n   100→    operator: z.enum([\"greater_than\", \"less_than\"]),\n   101→    value: z.number().min(0),\n   102→  }),\n   103→  // Logical tokens for chaining conditions left-to-right\n   104→  z.object({\n   105→    type: z.literal(\"AND\"),\n   106→  }),\n   107→  z.object({\n   108→    type: z.literal(\"OR\"),\n   109→  }),\n   110→]);\n   111→\n   112→export type Condition = z.infer<typeof ConditionSchema>;\n   113→\n   114→// Base action schema that includes conditions\n   115→export const BaseActionSchema = z.object({\n   116→  user_instructions: z.string().optional(),\n   117→  conditions: z.array(ConditionSchema).nullable().optional(),\n   118→});\n   119→\n   120→export const PublishContentActionSchema = BaseActionSchema.merge(\n   121→  z.object({\n   122→    platform: z.enum(ENABLED_PROVIDERS).optional(),\n   123→    accountId: z.string().optional(),\n   124→    schedule: z\n   125→      .string()\n   126→      .or(z.number())\n   127→      .optional()\n   128→      .describe(\n   129→        \"If ISO -- scheduled AT date, if number -- scheduled relative to now\"\n   130→      ),\n   131→    isRelative: z.boolean().optional(),\n   132→    platformOptions: z.record(z.any()).optional(),\n   133→    autoPostToStory: z.boolean().optional(), // If supported, can be set to true to auto-post to story\n   134→  })\n   135→);\n   136→\n   137→// Action-specific schemas\n   138→export const WaitActionSchema = BaseActionSchema.merge(DurationSchema);\n   139→\n   140→export const TranslateActionSchema = BaseActionSchema.merge(LanguageSchema);\n   141→\n   142→export const AIRewriteActionSchema = BaseActionSchema.merge(\n   143→  z.object({\n   144→    title: z.string().nullish(),\n   145→    content: z.string(),\n   146→    style: StyleEnumSchema,\n   147→    tone: ToneEnumSchema,\n   148→    length: LengthEnumSchema,\n   149→  })\n   150→);\n   151→\n   152→export const AISummarizeActionSchema = BaseActionSchema.merge(\n   153→  z.object({\n   154→    title: z.string().nullish(),\n   155→    content: z.string(),\n   156→    max_length: z.number().optional(),\n   157→    format: FormatEnumSchema,\n   158→  })\n   159→);\n   160→\n   161→export const AIGenerateContentActionSchema = BaseActionSchema.merge(\n   162→  z.object({\n   163→    title: z.string().nullish(),\n   164→    content: z.string(),\n   165→    length: LengthEnumSchema,\n   166→    tone: ToneEnumSchema,\n   167→    style: StyleEnumSchema,\n   168→  })\n   169→);\n   170→\n   171→export const ReplyActionSchema = BaseActionSchema.merge(\n   172→  z.object({\n   173→    title: z.string().nullish(),\n   174→    template: z.string(),\n   175→    variables: z.record(z.string()).optional(),\n   176→    max_length: z.number().optional(),\n   177→    content: z.string(),\n   178→  })\n   179→);\n   180→\n   181→// Content Management Action Schemas\n   182→export const SetTitleActionSchema = BaseActionSchema.merge(TitleSchema);\n   183→\n   184→export const SetTagsActionSchema = BaseActionSchema.merge(TagsSchema);\n   185→\n   186→export const SetContentActionSchema = BaseActionSchema.merge(ContentSchema);\n   187→\n   188→export const FetchContentActionSchema = BaseActionSchema.merge(\n   189→  z.object({\n   190→    url: z.string().url(),\n   191→    extractRules: z\n   192→      .object({\n   193→        title: z.boolean().default(true),\n   194→        content: z.boolean().default(true),\n   195→        tags: z.boolean().default(false),\n   196→      })\n   197→      .optional(),\n   198→  })\n   199→);\n   200→\n   201→// AI Title and Tags Schemas\n   202→export const AIAddTitleActionSchema = BaseActionSchema.merge(\n   203→  z.object({\n   204→    title: z.string().nullish(),\n   205→    content: z.string(),\n   206→    style: StyleEnumSchema.optional(),\n   207→    max_length: z.number().optional(),\n   208→  })\n   209→);\n   210→\n   211→export const AIAddTagsActionSchema = BaseActionSchema.merge(\n   212→  z.object({\n   213→    title: z.string().nullish(),\n   214→    content: z.string(),\n   215→    max_tags: z.number().optional(),\n   216→    categories: z.array(z.string()).optional(),\n   217→  })\n   218→);\n   219→\n   220→// Union type of all possible action configs\n   221→export const ActionConfigSchema = z.preprocess(\n   222→  (data) => {\n   223→    // Handle string input\n   224→    let parsed = typeof data === \"string\" ? JSON.parse(data) : data;\n   225→    let parsedConfig = parsed;\n   226→    if (parsed.config) {\n   227→      // console.log(\"Config found, parsing\", parsed.config);\n   228→      parsedConfig =\n   229→        typeof parsed.config === \"string\" ? JSON.parse(parsed.config) : parsed;\n   230→    }\n   231→\n   232→    // If we receive a raw config object, wrap it with its action type\n   233→    if (!(\"config\" in parsedConfig)) {\n   234→      const finalParsed = {\n   235→        action: parsed.action,\n   236→        ...parsedConfig,\n   237→      };\n   238→      // console.log(\"Final parsed:\", finalParsed);\n   239→      return finalParsed;\n   240→    }\n   241→\n   242→    return parsedConfig;\n   243→  },\n   244→  z.discriminatedUnion(\"action\", [\n   245→    z.object({\n   246→      action: z.literal(\"wait\"),\n   247→      ...WaitActionSchema.shape, // Spread the inner schema shape\n   248→    }),\n   249→    z.object({\n   250→      action: z.literal(\"ai_translate\"),\n   251→      ...TranslateActionSchema.shape,\n   252→    }),\n   253→    z.object({\n   254→      action: z.literal(\"publish_content\"),\n   255→      ...PublishContentActionSchema.shape,\n   256→    }),\n   257→    z.object({\n   258→      action: z.literal(\"ai_rewrite\"),\n   259→      ...AIRewriteActionSchema.shape,\n   260→    }),\n   261→    z.object({\n   262→      action: z.literal(\"ai_summarize\"),\n   263→      ...AISummarizeActionSchema.shape,\n   264→    }),\n   265→    z.object({\n   266→      action: z.literal(\"ai_generate_content\"),\n   267→      ...AIGenerateContentActionSchema.shape,\n   268→    }),\n   269→    z.object({\n   270→      action: z.literal(\"ai_gen_content\"),\n   271→      ...AIGenerateContentActionSchema.shape,\n   272→    }),\n   273→    z.object({\n   274→      action: z.literal(\"reply_to_comment\"),\n   275→      ...ReplyActionSchema.shape,\n   276→    }),\n   277→    z.object({\n   278→      action: z.literal(\"reply_to_message\"),\n   279→      ...ReplyActionSchema.shape,\n   280→    }),\n   281→    z.object({ action: z.literal(\"set_title\"), ...SetTitleActionSchema.shape }),\n   282→    z.object({ action: z.literal(\"set_tags\"), ...SetTagsActionSchema.shape }),\n   283→    z.object({\n   284→      action: z.literal(\"set_content\"),\n   285→      ...SetContentActionSchema.shape,\n   286→    }),\n   287→    z.object({\n   288→      action: z.literal(\"fetch_content\"),\n   289→      ...FetchContentActionSchema.shape,\n   290→    }),\n   291→    z.object({\n   292→      action: z.literal(\"ai_gen_title\"),\n   293→      ...AIAddTitleActionSchema.shape,\n   294→    }),\n   295→    z.object({\n   296→      action: z.literal(\"ai_add_title\"),\n   297→      ...AIAddTitleActionSchema.shape,\n   298→    }),\n   299→    z.object({\n   300→      action: z.literal(\"ai_add_content\"),\n   301→      ...AIGenerateContentActionSchema.shape,\n   302→    }),\n   303→    z.object({\n   304→      action: z.literal(\"ai_gen_tags\"),\n   305→      ...AIAddTagsActionSchema.shape,\n   306→    }),\n   307→    z.object({\n   308→      action: z.literal(\"ai_add_tags\"),\n   309→      ...AIAddTagsActionSchema.shape,\n   310→    }),\n   311→  ])\n   312→);\n   313→// Infer TypeScript types from schemas\n   314→export type WaitActionConfig = z.infer<typeof WaitActionSchema>;\n   315→export type TranslateActionConfig = z.infer<typeof TranslateActionSchema>;\n   316→export type PublishContentActionConfig = z.infer<\n   317→  typeof PublishContentActionSchema\n   318→>;\n   319→export type AIRewriteActionConfig = z.infer<typeof AIRewriteActionSchema>;\n   320→export type AISummarizeActionConfig = z.infer<typeof AISummarizeActionSchema>;\n   321→export type AIGenerateContentActionConfig = z.infer<\n   322→  typeof AIGenerateContentActionSchema\n   323→>;\n   324→export type ReplyActionConfig = z.infer<typeof ReplyActionSchema>;\n   325→export type SetTitleActionConfig = z.infer<typeof SetTitleActionSchema>;\n   326→export type SetTagsActionConfig = z.infer<typeof SetTagsActionSchema>;\n   327→export type SetContentActionConfig = z.infer<typeof SetContentActionSchema>;\n   328→export type FetchContentActionConfig = z.infer<typeof FetchContentActionSchema>;\n   329→export type AIAddTitleActionConfig = z.infer<typeof AIAddTitleActionSchema>;\n   330→export type AIAddTagsActionConfig = z.infer<typeof AIAddTagsActionSchema>;\n   331→export type ActionConfig = z.infer<typeof ActionConfigSchema>;\n   332→\n   333→// Helper function to validate action configs\n   334→export const validateActionConfig = (action: string, config: unknown) => {\n   335→  const actionConfig = { action, config };\n   336→  return ActionConfigSchema.safeParse(actionConfig);\n   337→};\n   338→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"31eb0482-8af1-4dd6-b354-255ecdc7b5d5","timestamp":"2025-09-30T20:35:38.018Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/natedamstra/socialaize/src/schemas/workflows/actionSchemas.ts","content":"import { z } from \"zod\";\nimport { ENABLED_PROVIDERS } from \"@constants/providerConstants\";\nimport { type WorkflowNode } from \"@appwrite/schemas/workflowNode\";\ntype ActionType = WorkflowNode[\"action\"];\n\nexport const ACTION_TYPES = [\n  \"wait\",\n  \"ai_translate\",\n  \"publish_content\",\n  \"ai_rewrite\",\n  \"ai_summarize\",\n  \"ai_gen_content\",\n  \"reply_to_comment\",\n  \"reply_to_message\",\n  \"set_title\",\n  \"set_tags\",\n  \"set_content\",\n  \"fetch_content\",\n  \"ai_gen_title\",\n  \"ai_gen_tags\",\n] as const satisfies ActionType[];\n\nexport const ActionTypeSchema = z.enum(ACTION_TYPES);\n\nexport const StyleEnumSchema = z.enum([\n  \"professional\",\n  \"casual\",\n  \"formal\",\n  \"friendly\",\n  \"match\",\n]);\nexport type StyleEnum = z.infer<typeof StyleEnumSchema>;\n\nexport const ToneEnumSchema = z.enum([\n  \"positive\",\n  \"neutral\",\n  \"negative\",\n  \"match\",\n]);\nexport type ToneEnum = z.infer<typeof ToneEnumSchema>;\n\nexport const LengthEnumSchema = z.enum([\"shorter\", \"same\", \"longer\"]);\nexport type LengthEnum = z.infer<typeof LengthEnumSchema>;\n\nexport const FormatEnumSchema = z.enum([\n  \"bullet_points\",\n  \"paragraph\",\n  \"key_points\",\n]);\nexport type FormatEnum = z.infer<typeof FormatEnumSchema>;\n\n// Base schemas for common patterns\nexport const DurationSchema = z.object({\n  duration: z.number().min(0).max(2592000), // max 30 days in seconds\n});\n\nexport const LanguageSchema = z.object({\n  content: z.string(),\n  language: z.string(),\n  preserve_formatting: z.boolean().default(true),\n});\n\nexport const ContentSchema = z.object({\n  content: z.string(),\n  format: z.enum([\"markdown\", \"html\", \"plain\"]).default(\"plain\"),\n});\n\nexport const TitleSchema = z.object({\n  title: z.string().min(1).max(200),\n});\n\nexport const TagsSchema = z.object({\n  tags: z.array(z.string()),\n  max_tags: z.number().optional(),\n});\n\nexport const ConditionSchema = z.discriminatedUnion(\"type\", [\n  z.object({\n    type: z.literal(\"content_contains\"),\n    value: z.string(),\n  }),\n  z.object({\n    type: z.literal(\"content_matches\"),\n    value: z.string(),\n  }),\n  z.object({\n    type: z.literal(\"hashtags_contain\"),\n    value: z.string(),\n  }),\n  z.object({\n    type: z.literal(\"platform_is\"),\n    value: z.string(),\n  }),\n  z.object({\n    type: z.literal(\"post_type_is\"),\n    value: z.string(),\n  }),\n  z.object({\n    type: z.literal(\"video_duration\"),\n    operator: z.enum([\"greater_than\", \"less_than\"]),\n    value: z.number().min(0),\n  }),\n  // Logical tokens for chaining conditions left-to-right\n  z.object({\n    type: z.literal(\"AND\"),\n  }),\n  z.object({\n    type: z.literal(\"OR\"),\n  }),\n]);\n\nexport type Condition = z.infer<typeof ConditionSchema>;\n\n// Base action schema that includes conditions\nexport const BaseActionSchema = z.object({\n  user_instructions: z.string().optional(),\n  conditions: z.array(ConditionSchema).nullable().optional(),\n});\n\nexport const PublishContentActionSchema = BaseActionSchema.merge(\n  z.object({\n    platform: z.enum(ENABLED_PROVIDERS).optional(),\n    accountId: z.string().optional(),\n    schedule: z\n      .string()\n      .or(z.number())\n      .optional()\n      .describe(\n        \"If ISO -- scheduled AT date, if number -- scheduled relative to now\"\n      ),\n    isRelative: z.boolean().optional(),\n    platformOptions: z.record(z.any()).optional(),\n    autoPostToStory: z.boolean().optional(), // If supported, can be set to true to auto-post to story\n  })\n);\n\n// Action-specific schemas\nexport const WaitActionSchema = BaseActionSchema.merge(DurationSchema);\n\nexport const TranslateActionSchema = BaseActionSchema.merge(LanguageSchema);\n\nexport const AIRewriteActionSchema = BaseActionSchema.merge(\n  z.object({\n    title: z.string().nullish(),\n    content: z.string(),\n    style: StyleEnumSchema,\n    tone: ToneEnumSchema,\n    length: LengthEnumSchema,\n  })\n);\n\nexport const AISummarizeActionSchema = BaseActionSchema.merge(\n  z.object({\n    title: z.string().nullish(),\n    content: z.string(),\n    max_length: z.number().optional(),\n    format: FormatEnumSchema,\n  })\n);\n\nexport const AIGenerateContentActionSchema = BaseActionSchema.merge(\n  z.object({\n    title: z.string().nullish(),\n    content: z.string(),\n    length: LengthEnumSchema,\n    tone: ToneEnumSchema,\n    style: StyleEnumSchema,\n  })\n);\n\nexport const ReplyActionSchema = BaseActionSchema.merge(\n  z.object({\n    title: z.string().nullish(),\n    template: z.string(),\n    variables: z.record(z.string()).optional(),\n    max_length: z.number().optional(),\n    content: z.string(),\n  })\n);\n\n// Content Management Action Schemas\nexport const SetTitleActionSchema = BaseActionSchema.merge(TitleSchema);\n\nexport const SetTagsActionSchema = BaseActionSchema.merge(TagsSchema);\n\nexport const SetContentActionSchema = BaseActionSchema.merge(ContentSchema);\n\nexport const FetchContentActionSchema = BaseActionSchema.merge(\n  z.object({\n    url: z.string().url(),\n    extractRules: z\n      .object({\n        title: z.boolean().default(true),\n        content: z.boolean().default(true),\n        tags: z.boolean().default(false),\n      })\n      .optional(),\n  })\n);\n\n// AI Title and Tags Schemas\nexport const AIAddTitleActionSchema = BaseActionSchema.merge(\n  z.object({\n    title: z.string().nullish(),\n    content: z.string(),\n    style: StyleEnumSchema.optional(),\n    max_length: z.number().optional(),\n  })\n);\n\nexport const AIAddTagsActionSchema = BaseActionSchema.merge(\n  z.object({\n    title: z.string().nullish(),\n    content: z.string(),\n    max_tags: z.number().optional(),\n    categories: z.array(z.string()).optional(),\n  })\n);\n\n// Union type of all possible action configs\nexport const ActionConfigSchema = z.preprocess(\n  (data) => {\n    // Handle string input\n    let parsed = typeof data === \"string\" ? JSON.parse(data) : data;\n    let parsedConfig = parsed;\n    if (parsed.config) {\n      // console.log(\"Config found, parsing\", parsed.config);\n      parsedConfig =\n        typeof parsed.config === \"string\" ? JSON.parse(parsed.config) : parsed;\n    }\n\n    // If we receive a raw config object, wrap it with its action type\n    if (!(\"config\" in parsedConfig)) {\n      const finalParsed = {\n        action: parsed.action,\n        ...parsedConfig,\n      };\n      // console.log(\"Final parsed:\", finalParsed);\n      return finalParsed;\n    }\n\n    return parsedConfig;\n  },\n  z.discriminatedUnion(\"action\", [\n    z.object({\n      action: z.literal(\"wait\"),\n      ...WaitActionSchema.shape, // Spread the inner schema shape\n    }),\n    z.object({\n      action: z.literal(\"ai_translate\"),\n      ...TranslateActionSchema.shape,\n    }),\n    z.object({\n      action: z.literal(\"publish_content\"),\n      ...PublishContentActionSchema.shape,\n    }),\n    z.object({\n      action: z.literal(\"ai_rewrite\"),\n      ...AIRewriteActionSchema.shape,\n    }),\n    z.object({\n      action: z.literal(\"ai_summarize\"),\n      ...AISummarizeActionSchema.shape,\n    }),\n    z.object({\n      action: z.literal(\"ai_generate_content\"),\n      ...AIGenerateContentActionSchema.shape,\n    }),\n    z.object({\n      action: z.literal(\"ai_gen_content\"),\n      ...AIGenerateContentActionSchema.shape,\n    }),\n    z.object({\n      action: z.literal(\"reply_to_comment\"),\n      ...ReplyActionSchema.shape,\n    }),\n    z.object({\n      action: z.literal(\"reply_to_message\"),\n      ...ReplyActionSchema.shape,\n    }),\n    z.object({ action: z.literal(\"set_title\"), ...SetTitleActionSchema.shape }),\n    z.object({ action: z.literal(\"set_tags\"), ...SetTagsActionSchema.shape }),\n    z.object({\n      action: z.literal(\"set_content\"),\n      ...SetContentActionSchema.shape,\n    }),\n    z.object({\n      action: z.literal(\"fetch_content\"),\n      ...FetchContentActionSchema.shape,\n    }),\n    z.object({\n      action: z.literal(\"ai_gen_title\"),\n      ...AIAddTitleActionSchema.shape,\n    }),\n    z.object({\n      action: z.literal(\"ai_add_title\"),\n      ...AIAddTitleActionSchema.shape,\n    }),\n    z.object({\n      action: z.literal(\"ai_add_content\"),\n      ...AIGenerateContentActionSchema.shape,\n    }),\n    z.object({\n      action: z.literal(\"ai_gen_tags\"),\n      ...AIAddTagsActionSchema.shape,\n    }),\n    z.object({\n      action: z.literal(\"ai_add_tags\"),\n      ...AIAddTagsActionSchema.shape,\n    }),\n  ])\n);\n// Infer TypeScript types from schemas\nexport type WaitActionConfig = z.infer<typeof WaitActionSchema>;\nexport type TranslateActionConfig = z.infer<typeof TranslateActionSchema>;\nexport type PublishContentActionConfig = z.infer<\n  typeof PublishContentActionSchema\n>;\nexport type AIRewriteActionConfig = z.infer<typeof AIRewriteActionSchema>;\nexport type AISummarizeActionConfig = z.infer<typeof AISummarizeActionSchema>;\nexport type AIGenerateContentActionConfig = z.infer<\n  typeof AIGenerateContentActionSchema\n>;\nexport type ReplyActionConfig = z.infer<typeof ReplyActionSchema>;\nexport type SetTitleActionConfig = z.infer<typeof SetTitleActionSchema>;\nexport type SetTagsActionConfig = z.infer<typeof SetTagsActionSchema>;\nexport type SetContentActionConfig = z.infer<typeof SetContentActionSchema>;\nexport type FetchContentActionConfig = z.infer<typeof FetchContentActionSchema>;\nexport type AIAddTitleActionConfig = z.infer<typeof AIAddTitleActionSchema>;\nexport type AIAddTagsActionConfig = z.infer<typeof AIAddTagsActionSchema>;\nexport type ActionConfig = z.infer<typeof ActionConfigSchema>;\n\n// Helper function to validate action configs\nexport const validateActionConfig = (action: string, config: unknown) => {\n  const actionConfig = { action, config };\n  return ActionConfigSchema.safeParse(actionConfig);\n};\n","numLines":338,"startLine":1,"totalLines":338}}}
{"parentUuid":"31eb0482-8af1-4dd6-b354-255ecdc7b5d5","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YAZrawJVGieM69WpdTGvzq","type":"tool_result","content":"/Users/natedamstra/socialaize/functions/WorkflowManager/src/handlers/actions/aiActions.ts"}]},"uuid":"0550a244-aa67-4475-ae65-aa442f6bcc3c","timestamp":"2025-09-30T20:35:38.078Z","toolUseResult":{"filenames":["/Users/natedamstra/socialaize/functions/WorkflowManager/src/handlers/actions/aiActions.ts"],"durationMs":78,"numFiles":1,"truncated":false}}
{"parentUuid":"0550a244-aa67-4475-ae65-aa442f6bcc3c","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RD6mVbanpUthUFCDYaUD7B","type":"tool_result","content":"/Users/natedamstra/socialaize/functions/AI_API/src/services/conversation_cache.py\n/Users/natedamstra/socialaize/functions/AI_API/src/services/debug_billing.py\n/Users/natedamstra/socialaize/functions/AI_API/src/services/billing_utils.py\n/Users/natedamstra/socialaize/functions/AI_API/src/utils/billing_setup.py\n/Users/natedamstra/socialaize/functions/AI_API/src/config/__init__.py\n/Users/natedamstra/socialaize/functions/AI_API/src/config/billing.py\n/Users/natedamstra/socialaize/functions/AI_API/src/examples/actionable_ai_example.py\n/Users/natedamstra/socialaize/functions/AI_API/src/schemas/action_responses.py\n/Users/natedamstra/socialaize/functions/AI_API/src/schemas/billing.py\n/Users/natedamstra/socialaize/functions/AI_API/src/schemas/requests.py\n/Users/natedamstra/socialaize/functions/AI_API/src/services/appwrite_client.py\n/Users/natedamstra/socialaize/functions/AI_API/src/services/billing_service.py\n/Users/natedamstra/socialaize/functions/AI_API/src/services/post_generation_service.py\n/Users/natedamstra/socialaize/functions/AI_API/src/services/user_data_service.py\n/Users/natedamstra/socialaize/functions/AI_API/src/workflows/ai_workflow.py\n/Users/natedamstra/socialaize/functions/AI_API/src/main.py\n/Users/natedamstra/socialaize/functions/AI_API/src/workflows/chat_workflow.py\n/Users/natedamstra/socialaize/functions/AI_API/src/workflows/enhanced_chat_workflow.py\n/Users/natedamstra/socialaize/functions/AI_API/src/schemas/responses.py\n/Users/natedamstra/socialaize/functions/AI_API/src/services/ai_service.py"}]},"uuid":"fd23576a-0e13-43da-b4e4-37832090ee17","timestamp":"2025-09-30T20:35:38.123Z","toolUseResult":{"filenames":["/Users/natedamstra/socialaize/functions/AI_API/src/services/conversation_cache.py","/Users/natedamstra/socialaize/functions/AI_API/src/services/debug_billing.py","/Users/natedamstra/socialaize/functions/AI_API/src/services/billing_utils.py","/Users/natedamstra/socialaize/functions/AI_API/src/utils/billing_setup.py","/Users/natedamstra/socialaize/functions/AI_API/src/config/__init__.py","/Users/natedamstra/socialaize/functions/AI_API/src/config/billing.py","/Users/natedamstra/socialaize/functions/AI_API/src/examples/actionable_ai_example.py","/Users/natedamstra/socialaize/functions/AI_API/src/schemas/action_responses.py","/Users/natedamstra/socialaize/functions/AI_API/src/schemas/billing.py","/Users/natedamstra/socialaize/functions/AI_API/src/schemas/requests.py","/Users/natedamstra/socialaize/functions/AI_API/src/services/appwrite_client.py","/Users/natedamstra/socialaize/functions/AI_API/src/services/billing_service.py","/Users/natedamstra/socialaize/functions/AI_API/src/services/post_generation_service.py","/Users/natedamstra/socialaize/functions/AI_API/src/services/user_data_service.py","/Users/natedamstra/socialaize/functions/AI_API/src/workflows/ai_workflow.py","/Users/natedamstra/socialaize/functions/AI_API/src/main.py","/Users/natedamstra/socialaize/functions/AI_API/src/workflows/chat_workflow.py","/Users/natedamstra/socialaize/functions/AI_API/src/workflows/enhanced_chat_workflow.py","/Users/natedamstra/socialaize/functions/AI_API/src/schemas/responses.py","/Users/natedamstra/socialaize/functions/AI_API/src/services/ai_service.py"],"durationMs":119,"numFiles":20,"truncated":false}}
{"parentUuid":"fd23576a-0e13-43da-b4e4-37832090ee17","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01LYbqXazqyagDWWZimFnHKa","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"thinking","thinking":"Good! Now let me read the WorkflowManager AI actions handler and the AI_API key files to understand the flow.","signature":"EpcCCkYICBgCKkCSL9eWeuTowP1O471jxIf0TqGs1YdeorYEoSi1I4XhPbsXrgK/qb/DXa2/jG6V1/LjZy9y75ckscxFMcPSOFHyEgzZlxn9v0qgm+eeGvEaDDSy/cOIvr4FqnjTxCIwuBdGOU31+kZk9AZXU/6+ilbB5NgFxsmdtXZ61uWJnqCw68yOOTOzb56LKL1oP1eEKn+sOea3NjXnkW29DYdF0sTrr/CvdMsxQ2gTJvooQaSupzSWPuX5bDX6/cHzeZ/0NP6gSzSfAevN8FRWGILj5+DFR1zAdy+2YZLfXJIPm57/njdPcCJ64Twi20JG2TCcOaxKuNhMnJdmTUbT5pBIXVEuRceqIs/tBKoXkri6AjKyGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":9993,"cache_read_input_tokens":32127,"cache_creation":{"ephemeral_5m_input_tokens":9993,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CTfE45ky85HTGAVz1W4dh","type":"assistant","uuid":"ee2b3db7-0d1b-4cd9-afc0-a9ed2a71ba5f","timestamp":"2025-09-30T20:35:56.598Z"}
{"parentUuid":"ee2b3db7-0d1b-4cd9-afc0-a9ed2a71ba5f","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01LYbqXazqyagDWWZimFnHKa","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_01H6NDoAPhF9rCzLmDsxX8Rk","name":"Read","input":{"file_path":"/Users/natedamstra/socialaize/functions/WorkflowManager/src/handlers/actions/aiActions.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":9993,"cache_read_input_tokens":32127,"cache_creation":{"ephemeral_5m_input_tokens":9993,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CTfE45ky85HTGAVz1W4dh","type":"assistant","uuid":"f142d2c2-b39d-43fa-abd9-c224055db157","timestamp":"2025-09-30T20:35:58.256Z"}
{"parentUuid":"f142d2c2-b39d-43fa-abd9-c224055db157","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01LYbqXazqyagDWWZimFnHKa","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_011jKriZx9gdZgyjACw6T7DQ","name":"Read","input":{"file_path":"/Users/natedamstra/socialaize/functions/AI_API/src/main.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":9993,"cache_read_input_tokens":32127,"cache_creation":{"ephemeral_5m_input_tokens":9993,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CTfE45ky85HTGAVz1W4dh","type":"assistant","uuid":"1a5a5659-3631-4f7a-8cec-4565291d5d67","timestamp":"2025-09-30T20:35:59.355Z"}
{"parentUuid":"1a5a5659-3631-4f7a-8cec-4565291d5d67","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01LYbqXazqyagDWWZimFnHKa","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_0148s39Rn3sWidzK97jth1ro","name":"Read","input":{"file_path":"/Users/natedamstra/socialaize/functions/AI_API/src/schemas/requests.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":9993,"cache_read_input_tokens":32127,"cache_creation":{"ephemeral_5m_input_tokens":9993,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CTfE45ky85HTGAVz1W4dh","type":"assistant","uuid":"5553959c-85d4-4cc8-88cd-ca0a5036a755","timestamp":"2025-09-30T20:36:01.551Z"}
{"parentUuid":"5553959c-85d4-4cc8-88cd-ca0a5036a755","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01LYbqXazqyagDWWZimFnHKa","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_01Q7VRdaw7bpM8sqFNs3hML5","name":"Read","input":{"file_path":"/Users/natedamstra/socialaize/functions/AI_API/src/schemas/action_responses.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":9993,"cache_read_input_tokens":32127,"cache_creation":{"ephemeral_5m_input_tokens":9993,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CTfE45ky85HTGAVz1W4dh","type":"assistant","uuid":"db28579f-4640-43a2-a121-e55efe72bcd1","timestamp":"2025-09-30T20:36:02.314Z"}
{"parentUuid":"db28579f-4640-43a2-a121-e55efe72bcd1","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01H6NDoAPhF9rCzLmDsxX8Rk","type":"tool_result","content":"     1→import {\n     2→  type AIAddTitleActionConfig,\n     3→  type AIAddTagsActionConfig,\n     4→  type AIGenerateContentActionConfig,\n     5→  type AISummarizeActionConfig,\n     6→  type AIRewriteActionConfig,\n     7→  type TranslateActionConfig,\n     8→  FormatEnum,\n     9→  ActionConfig,\n    10→  StyleEnum,\n    11→} from '../../schema/actionSchemas.js';\n    12→import { PostContainer } from '../../types/database/postContainer.js';\n    13→import { AppwriteManager } from '../appwriteManager.js';\n    14→\n    15→interface ActionData {\n    16→  config: any;\n    17→  postData: PostContainer;\n    18→}\n    19→\n    20→// Helper function to create AI API request body\n    21→async function createAIRequest(\n    22→  appwriteManager: AppwriteManager,\n    23→  userId: string,\n    24→  actionConfig: ActionConfig\n    25→) {\n    26→  // Create JWT for authentication\n    27→  const jwt = await appwriteManager.users.createJWT(userId);\n    28→  \n    29→  return {\n    30→    user_id: userId,\n    31→    jwt: jwt.jwt,\n    32→    action_config: actionConfig\n    33→  };\n    34→}\n    35→\n    36→export async function handleAiRewrite(\n    37→  data: ActionData,\n    38→  appwriteManager: AppwriteManager\n    39→) {\n    40→  const { config, postData } = data;\n    41→  const genericPost =\n    42→    typeof postData.postData === 'string'\n    43→      ? JSON.parse(postData.postData)\n    44→      : postData.postData;\n    45→\n    46→  appwriteManager.log(\n    47→    `Processing AI rewrite with params: ${JSON.stringify(config, null, 4)} and content: ${genericPost.text}`\n    48→  );\n    49→\n    50→  let baseInstructions: string | undefined;\n    51→  if (genericPost.platform === 'bluesky') {\n    52→    baseInstructions =\n    53→      'The post is for Bluesky, so the maximum length is 300 characters\\n';\n    54→  }\n    55→  const userInstructions = baseInstructions\n    56→    ? `${baseInstructions} ${config.user_instructions || ''}`\n    57→    : config.user_instructions || undefined;\n    58→\n    59→  const requestData = {\n    60→    ...(genericPost.title ? { title: genericPost.title } : {}),\n    61→    content: `${genericPost.text}`,\n    62→    style: config.style || 'professional',\n    63→    tone: config.tone || 'match',\n    64→    length: config.length || 'same',\n    65→    user_instructions: userInstructions,\n    66→  } satisfies AIRewriteActionConfig;\n    67→\n    68→  appwriteManager.log(`Request data: ${JSON.stringify(requestData, null, 4)}`);\n    69→\n    70→  const actionConfig = {\n    71→    action: 'ai_rewrite',\n    72→    ...requestData,\n    73→  } satisfies ActionConfig;\n    74→\n    75→  const aiRequestBody = await createAIRequest(\n    76→    appwriteManager,\n    77→    postData.userId,\n    78→    actionConfig\n    79→  );\n    80→\n    81→  const response = await appwriteManager.executeAIFunction(aiRequestBody);\n    82→\n    83→  appwriteManager.log(\n    84→    `AI rewrite response: ${JSON.stringify(response, null, 4)}`\n    85→  );\n    86→\n    87→  if (!response?.result?.content && !response?.result?.title) {\n    88→    appwriteManager.log('Error: AI response missing content and title');\n    89→    return postData; // Return original if AI response is invalid\n    90→  }\n    91→\n    92→  appwriteManager.log(`Original text: ${genericPost.text}`);\n    93→  appwriteManager.log(`AI response: ${JSON.stringify(response, null, 4)}`);\n    94→\n    95→  // Only update if we got valid content back\n    96→  if (response.result.title) {\n    97→    genericPost.title = response.result.title;\n    98→  }\n    99→  if (response.result.content) {\n   100→    genericPost.text = response.result.content;\n   101→  }\n   102→  const updatedPost = {\n   103→    ...postData,\n   104→    postData: JSON.stringify(genericPost),\n   105→  };\n   106→\n   107→  appwriteManager.log(\n   108→    `Final updated text: ${JSON.parse(updatedPost.postData).text}`\n   109→  );\n   110→  return updatedPost;\n   111→}\n   112→\n   113→export async function handleAiTranslate(\n   114→  data: ActionData,\n   115→  appwriteManager: AppwriteManager\n   116→) {\n   117→  const { config, postData } = data;\n   118→  const genericPost = JSON.parse(postData.postData);\n   119→\n   120→  appwriteManager.log(\n   121→    `Processing AI translation to language: ${config.language}`\n   122→  );\n   123→\n   124→  let baseInstructions: string | undefined;\n   125→  if (genericPost.platform === 'bluesky') {\n   126→    baseInstructions =\n   127→      'The post is for Bluesky, so the maximum length is 300 characters\\n';\n   128→  }\n   129→  const userInstructions = baseInstructions\n   130→    ? `${baseInstructions} ${config.user_instructions || ''}`\n   131→    : config.user_instructions || undefined;\n   132→\n   133→  const requestData = {\n   134→    ...(genericPost.title && { title: genericPost.title }),\n   135→    content: `${genericPost.text}`,\n   136→    target_language: config.language,\n   137→    preserve_formatting: config.preserve_formatting ?? true,\n   138→    user_instructions: userInstructions,\n   139→  } satisfies TranslateActionConfig;\n   140→\n   141→  const actionConfig = {\n   142→    action: 'ai_translate',\n   143→    ...requestData,\n   144→  } satisfies ActionConfig;\n   145→\n   146→  const aiRequestBody = await createAIRequest(\n   147→    appwriteManager,\n   148→    postData.userId,\n   149→    actionConfig\n   150→  );\n   151→\n   152→  const response = await appwriteManager.executeAIFunction(aiRequestBody);\n   153→\n   154→  appwriteManager.log(\n   155→    `AI translate response: ${JSON.stringify(response, null, 4)}`\n   156→  );\n   157→\n   158→  if (!response.result.content && !response.result.title) {\n   159→    appwriteManager.log('Error: AI response missing content and title');\n   160→    return postData; // Return original if AI response is invalid\n   161→  }\n   162→\n   163→  if (response.result.title) {\n   164→    genericPost.title = response.result.title;\n   165→  }\n   166→  if (response.result.content) {\n   167→    genericPost.text = response.result.content;\n   168→  }\n   169→\n   170→  const updatedPost = {\n   171→    ...postData,\n   172→    postData: JSON.stringify(genericPost),\n   173→  };\n   174→\n   175→  appwriteManager.log(\n   176→    `Final updated text: ${JSON.parse(updatedPost.postData).text}`\n   177→  );\n   178→  return updatedPost;\n   179→}\n   180→\n   181→export async function handleAiSummarize(\n   182→  data: ActionData,\n   183→  appwriteManager: AppwriteManager\n   184→) {\n   185→  const { config, postData } = data;\n   186→  const genericPost = JSON.parse(postData.postData);\n   187→\n   188→  appwriteManager.log(`Processing AI summarize with format: ${config.format}`);\n   189→\n   190→  let baseInstructions: string | undefined;\n   191→  if (genericPost.platform === 'bluesky') {\n   192→    baseInstructions =\n   193→      'The post is for Bluesky, so the maximum length is 300 characters\\n';\n   194→  }\n   195→  const userInstructions = baseInstructions\n   196→    ? `${baseInstructions} ${config.user_instructions || ''}`\n   197→    : config.user_instructions || undefined;\n   198→\n   199→  const requestData = {\n   200→    ...(genericPost.title && { title: genericPost.title }),\n   201→    content: `${genericPost.text}`,\n   202→    max_length: config.maxLength,\n   203→    format: config.format as FormatEnum,\n   204→    user_instructions: userInstructions,\n   205→  } satisfies AISummarizeActionConfig;\n   206→\n   207→  const actionConfig = {\n   208→    action: 'ai_summarize',\n   209→    ...requestData,\n   210→  } satisfies ActionConfig;\n   211→\n   212→  const aiRequestBody = await createAIRequest(\n   213→    appwriteManager,\n   214→    postData.userId,\n   215→    actionConfig\n   216→  );\n   217→\n   218→  const response = await appwriteManager.executeAIFunction(aiRequestBody);\n   219→\n   220→  appwriteManager.log(\n   221→    `AI summarize response: ${JSON.stringify(response, null, 4)}`\n   222→  );\n   223→\n   224→  if (!response.result.content) {\n   225→    appwriteManager.log('Error: AI response missing content');\n   226→    return postData; // Return original if AI response is invalid\n   227→  }\n   228→\n   229→  if (response.result.title) {\n   230→    genericPost.title = response.result.title;\n   231→  }\n   232→  if (response.result.content) {\n   233→    genericPost.text = response.result.content;\n   234→  }\n   235→  const updatedPost = {\n   236→    ...postData,\n   237→    postData: JSON.stringify(genericPost),\n   238→  };\n   239→\n   240→  appwriteManager.log(\n   241→    `Final updated text: ${JSON.parse(updatedPost.postData).text}`\n   242→  );\n   243→  return updatedPost;\n   244→}\n   245→\n   246→export async function handleAiAddHashtags(\n   247→  data: ActionData,\n   248→  appwriteManager: AppwriteManager\n   249→) {\n   250→  const { config, postData } = data;\n   251→  const genericPost = JSON.parse(postData.postData);\n   252→\n   253→  appwriteManager.log(`Generating AI hashtags`);\n   254→\n   255→  let baseInstructions: string | undefined;\n   256→  if (genericPost.platform === 'bluesky') {\n   257→    baseInstructions =\n   258→      'The post is for Bluesky, so the maximum length is 300 characters\\n';\n   259→  }\n   260→  const userInstructions = baseInstructions\n   261→    ? `${baseInstructions} ${config.user_instructions || ''}`\n   262→    : config.user_instructions || undefined;\n   263→\n   264→  const requestData = {\n   265→    ...(genericPost.title && { title: genericPost.title }),\n   266→    content: `${genericPost.text}`,\n   267→    max_tags: config.max_tags,\n   268→    categories: config.categories,\n   269→    user_instructions: userInstructions,\n   270→  } satisfies AIAddTagsActionConfig;\n   271→\n   272→  const actionConfig = {\n   273→    action: 'ai_gen_tags',\n   274→    ...requestData,\n   275→  } satisfies ActionConfig;\n   276→\n   277→  const aiRequestBody = await createAIRequest(\n   278→    appwriteManager,\n   279→    postData.userId,\n   280→    actionConfig\n   281→  );\n   282→\n   283→  const response = await appwriteManager.executeAIFunction(aiRequestBody);\n   284→\n   285→  appwriteManager.log(\n   286→    `AI add hashtags response: ${JSON.stringify(response, null, 4)}`\n   287→  );\n   288→\n   289→  if (!response.result.tags) {\n   290→    appwriteManager.log('Error: AI response missing tags');\n   291→    return postData; // Return original if AI response is invalid\n   292→  }\n   293→\n   294→  if (!response.result.tags?.length) {\n   295→    appwriteManager.log('Error: AI response missing tags');\n   296→    return postData; // Return original if AI response is invalid\n   297→  }\n   298→\n   299→  if (response.result.tags) {\n   300→    genericPost.text = `${genericPost.text} ${response.result.tags?.join(' ') || ''}`;\n   301→  }\n   302→  const updatedPost = {\n   303→    ...postData,\n   304→    postData: JSON.stringify(genericPost),\n   305→  };\n   306→\n   307→  appwriteManager.log(\n   308→    `Final updated text: ${JSON.parse(updatedPost.postData).text}`\n   309→  );\n   310→  return updatedPost;\n   311→}\n   312→\n   313→export async function handleAiGenerateTitle(\n   314→  data: ActionData,\n   315→  appwriteManager: AppwriteManager\n   316→) {\n   317→  const { config, postData } = data;\n   318→  const genericPost = JSON.parse(postData.postData);\n   319→\n   320→  appwriteManager.log('Generating AI title');\n   321→\n   322→  let baseInstructions: string | undefined;\n   323→  if (genericPost.platform === 'bluesky') {\n   324→    baseInstructions =\n   325→      'The post is for Bluesky, so the maximum length is 300 characters\\n';\n   326→  }\n   327→  const userInstructions = baseInstructions\n   328→    ? `${baseInstructions} ${config.user_instructions || ''}`\n   329→    : config.user_instructions || undefined;\n   330→\n   331→  const requestData = {\n   332→    ...(genericPost.title && { title: genericPost.title }),\n   333→    content: `${genericPost.text}`,\n   334→    style: config.style as StyleEnum | 'professional',\n   335→    max_length: config.max_length,\n   336→    user_instructions: userInstructions,\n   337→  } satisfies AIAddTitleActionConfig;\n   338→\n   339→  const actionConfig = {\n   340→    action: 'ai_gen_title',\n   341→    ...requestData,\n   342→  } satisfies ActionConfig;\n   343→\n   344→  const aiRequestBody = await createAIRequest(\n   345→    appwriteManager,\n   346→    postData.userId,\n   347→    actionConfig\n   348→  );\n   349→\n   350→  const response = await appwriteManager.executeAIFunction(aiRequestBody);\n   351→\n   352→  appwriteManager.log(\n   353→    `AI add title response: ${JSON.stringify(response, null, 4)}`\n   354→  );\n   355→\n   356→  if (!response.result.title) {\n   357→    appwriteManager.log('Error: AI response missing title');\n   358→    return postData; // Return original if AI response is invalid\n   359→  }\n   360→\n   361→  if (response.result.title) {\n   362→    genericPost.title = response.result.title;\n   363→  }\n   364→  const updatedPost = {\n   365→    ...postData,\n   366→    postData: JSON.stringify(genericPost),\n   367→  };\n   368→\n   369→  appwriteManager.log(\n   370→    `Final updated text: ${JSON.parse(updatedPost.postData).text}`\n   371→  );\n   372→  return updatedPost;\n   373→}\n   374→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b90a8239-a488-4032-af37-9f6dfd42705d","timestamp":"2025-09-30T20:36:03.599Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/natedamstra/socialaize/functions/WorkflowManager/src/handlers/actions/aiActions.ts","content":"import {\n  type AIAddTitleActionConfig,\n  type AIAddTagsActionConfig,\n  type AIGenerateContentActionConfig,\n  type AISummarizeActionConfig,\n  type AIRewriteActionConfig,\n  type TranslateActionConfig,\n  FormatEnum,\n  ActionConfig,\n  StyleEnum,\n} from '../../schema/actionSchemas.js';\nimport { PostContainer } from '../../types/database/postContainer.js';\nimport { AppwriteManager } from '../appwriteManager.js';\n\ninterface ActionData {\n  config: any;\n  postData: PostContainer;\n}\n\n// Helper function to create AI API request body\nasync function createAIRequest(\n  appwriteManager: AppwriteManager,\n  userId: string,\n  actionConfig: ActionConfig\n) {\n  // Create JWT for authentication\n  const jwt = await appwriteManager.users.createJWT(userId);\n  \n  return {\n    user_id: userId,\n    jwt: jwt.jwt,\n    action_config: actionConfig\n  };\n}\n\nexport async function handleAiRewrite(\n  data: ActionData,\n  appwriteManager: AppwriteManager\n) {\n  const { config, postData } = data;\n  const genericPost =\n    typeof postData.postData === 'string'\n      ? JSON.parse(postData.postData)\n      : postData.postData;\n\n  appwriteManager.log(\n    `Processing AI rewrite with params: ${JSON.stringify(config, null, 4)} and content: ${genericPost.text}`\n  );\n\n  let baseInstructions: string | undefined;\n  if (genericPost.platform === 'bluesky') {\n    baseInstructions =\n      'The post is for Bluesky, so the maximum length is 300 characters\\n';\n  }\n  const userInstructions = baseInstructions\n    ? `${baseInstructions} ${config.user_instructions || ''}`\n    : config.user_instructions || undefined;\n\n  const requestData = {\n    ...(genericPost.title ? { title: genericPost.title } : {}),\n    content: `${genericPost.text}`,\n    style: config.style || 'professional',\n    tone: config.tone || 'match',\n    length: config.length || 'same',\n    user_instructions: userInstructions,\n  } satisfies AIRewriteActionConfig;\n\n  appwriteManager.log(`Request data: ${JSON.stringify(requestData, null, 4)}`);\n\n  const actionConfig = {\n    action: 'ai_rewrite',\n    ...requestData,\n  } satisfies ActionConfig;\n\n  const aiRequestBody = await createAIRequest(\n    appwriteManager,\n    postData.userId,\n    actionConfig\n  );\n\n  const response = await appwriteManager.executeAIFunction(aiRequestBody);\n\n  appwriteManager.log(\n    `AI rewrite response: ${JSON.stringify(response, null, 4)}`\n  );\n\n  if (!response?.result?.content && !response?.result?.title) {\n    appwriteManager.log('Error: AI response missing content and title');\n    return postData; // Return original if AI response is invalid\n  }\n\n  appwriteManager.log(`Original text: ${genericPost.text}`);\n  appwriteManager.log(`AI response: ${JSON.stringify(response, null, 4)}`);\n\n  // Only update if we got valid content back\n  if (response.result.title) {\n    genericPost.title = response.result.title;\n  }\n  if (response.result.content) {\n    genericPost.text = response.result.content;\n  }\n  const updatedPost = {\n    ...postData,\n    postData: JSON.stringify(genericPost),\n  };\n\n  appwriteManager.log(\n    `Final updated text: ${JSON.parse(updatedPost.postData).text}`\n  );\n  return updatedPost;\n}\n\nexport async function handleAiTranslate(\n  data: ActionData,\n  appwriteManager: AppwriteManager\n) {\n  const { config, postData } = data;\n  const genericPost = JSON.parse(postData.postData);\n\n  appwriteManager.log(\n    `Processing AI translation to language: ${config.language}`\n  );\n\n  let baseInstructions: string | undefined;\n  if (genericPost.platform === 'bluesky') {\n    baseInstructions =\n      'The post is for Bluesky, so the maximum length is 300 characters\\n';\n  }\n  const userInstructions = baseInstructions\n    ? `${baseInstructions} ${config.user_instructions || ''}`\n    : config.user_instructions || undefined;\n\n  const requestData = {\n    ...(genericPost.title && { title: genericPost.title }),\n    content: `${genericPost.text}`,\n    target_language: config.language,\n    preserve_formatting: config.preserve_formatting ?? true,\n    user_instructions: userInstructions,\n  } satisfies TranslateActionConfig;\n\n  const actionConfig = {\n    action: 'ai_translate',\n    ...requestData,\n  } satisfies ActionConfig;\n\n  const aiRequestBody = await createAIRequest(\n    appwriteManager,\n    postData.userId,\n    actionConfig\n  );\n\n  const response = await appwriteManager.executeAIFunction(aiRequestBody);\n\n  appwriteManager.log(\n    `AI translate response: ${JSON.stringify(response, null, 4)}`\n  );\n\n  if (!response.result.content && !response.result.title) {\n    appwriteManager.log('Error: AI response missing content and title');\n    return postData; // Return original if AI response is invalid\n  }\n\n  if (response.result.title) {\n    genericPost.title = response.result.title;\n  }\n  if (response.result.content) {\n    genericPost.text = response.result.content;\n  }\n\n  const updatedPost = {\n    ...postData,\n    postData: JSON.stringify(genericPost),\n  };\n\n  appwriteManager.log(\n    `Final updated text: ${JSON.parse(updatedPost.postData).text}`\n  );\n  return updatedPost;\n}\n\nexport async function handleAiSummarize(\n  data: ActionData,\n  appwriteManager: AppwriteManager\n) {\n  const { config, postData } = data;\n  const genericPost = JSON.parse(postData.postData);\n\n  appwriteManager.log(`Processing AI summarize with format: ${config.format}`);\n\n  let baseInstructions: string | undefined;\n  if (genericPost.platform === 'bluesky') {\n    baseInstructions =\n      'The post is for Bluesky, so the maximum length is 300 characters\\n';\n  }\n  const userInstructions = baseInstructions\n    ? `${baseInstructions} ${config.user_instructions || ''}`\n    : config.user_instructions || undefined;\n\n  const requestData = {\n    ...(genericPost.title && { title: genericPost.title }),\n    content: `${genericPost.text}`,\n    max_length: config.maxLength,\n    format: config.format as FormatEnum,\n    user_instructions: userInstructions,\n  } satisfies AISummarizeActionConfig;\n\n  const actionConfig = {\n    action: 'ai_summarize',\n    ...requestData,\n  } satisfies ActionConfig;\n\n  const aiRequestBody = await createAIRequest(\n    appwriteManager,\n    postData.userId,\n    actionConfig\n  );\n\n  const response = await appwriteManager.executeAIFunction(aiRequestBody);\n\n  appwriteManager.log(\n    `AI summarize response: ${JSON.stringify(response, null, 4)}`\n  );\n\n  if (!response.result.content) {\n    appwriteManager.log('Error: AI response missing content');\n    return postData; // Return original if AI response is invalid\n  }\n\n  if (response.result.title) {\n    genericPost.title = response.result.title;\n  }\n  if (response.result.content) {\n    genericPost.text = response.result.content;\n  }\n  const updatedPost = {\n    ...postData,\n    postData: JSON.stringify(genericPost),\n  };\n\n  appwriteManager.log(\n    `Final updated text: ${JSON.parse(updatedPost.postData).text}`\n  );\n  return updatedPost;\n}\n\nexport async function handleAiAddHashtags(\n  data: ActionData,\n  appwriteManager: AppwriteManager\n) {\n  const { config, postData } = data;\n  const genericPost = JSON.parse(postData.postData);\n\n  appwriteManager.log(`Generating AI hashtags`);\n\n  let baseInstructions: string | undefined;\n  if (genericPost.platform === 'bluesky') {\n    baseInstructions =\n      'The post is for Bluesky, so the maximum length is 300 characters\\n';\n  }\n  const userInstructions = baseInstructions\n    ? `${baseInstructions} ${config.user_instructions || ''}`\n    : config.user_instructions || undefined;\n\n  const requestData = {\n    ...(genericPost.title && { title: genericPost.title }),\n    content: `${genericPost.text}`,\n    max_tags: config.max_tags,\n    categories: config.categories,\n    user_instructions: userInstructions,\n  } satisfies AIAddTagsActionConfig;\n\n  const actionConfig = {\n    action: 'ai_gen_tags',\n    ...requestData,\n  } satisfies ActionConfig;\n\n  const aiRequestBody = await createAIRequest(\n    appwriteManager,\n    postData.userId,\n    actionConfig\n  );\n\n  const response = await appwriteManager.executeAIFunction(aiRequestBody);\n\n  appwriteManager.log(\n    `AI add hashtags response: ${JSON.stringify(response, null, 4)}`\n  );\n\n  if (!response.result.tags) {\n    appwriteManager.log('Error: AI response missing tags');\n    return postData; // Return original if AI response is invalid\n  }\n\n  if (!response.result.tags?.length) {\n    appwriteManager.log('Error: AI response missing tags');\n    return postData; // Return original if AI response is invalid\n  }\n\n  if (response.result.tags) {\n    genericPost.text = `${genericPost.text} ${response.result.tags?.join(' ') || ''}`;\n  }\n  const updatedPost = {\n    ...postData,\n    postData: JSON.stringify(genericPost),\n  };\n\n  appwriteManager.log(\n    `Final updated text: ${JSON.parse(updatedPost.postData).text}`\n  );\n  return updatedPost;\n}\n\nexport async function handleAiGenerateTitle(\n  data: ActionData,\n  appwriteManager: AppwriteManager\n) {\n  const { config, postData } = data;\n  const genericPost = JSON.parse(postData.postData);\n\n  appwriteManager.log('Generating AI title');\n\n  let baseInstructions: string | undefined;\n  if (genericPost.platform === 'bluesky') {\n    baseInstructions =\n      'The post is for Bluesky, so the maximum length is 300 characters\\n';\n  }\n  const userInstructions = baseInstructions\n    ? `${baseInstructions} ${config.user_instructions || ''}`\n    : config.user_instructions || undefined;\n\n  const requestData = {\n    ...(genericPost.title && { title: genericPost.title }),\n    content: `${genericPost.text}`,\n    style: config.style as StyleEnum | 'professional',\n    max_length: config.max_length,\n    user_instructions: userInstructions,\n  } satisfies AIAddTitleActionConfig;\n\n  const actionConfig = {\n    action: 'ai_gen_title',\n    ...requestData,\n  } satisfies ActionConfig;\n\n  const aiRequestBody = await createAIRequest(\n    appwriteManager,\n    postData.userId,\n    actionConfig\n  );\n\n  const response = await appwriteManager.executeAIFunction(aiRequestBody);\n\n  appwriteManager.log(\n    `AI add title response: ${JSON.stringify(response, null, 4)}`\n  );\n\n  if (!response.result.title) {\n    appwriteManager.log('Error: AI response missing title');\n    return postData; // Return original if AI response is invalid\n  }\n\n  if (response.result.title) {\n    genericPost.title = response.result.title;\n  }\n  const updatedPost = {\n    ...postData,\n    postData: JSON.stringify(genericPost),\n  };\n\n  appwriteManager.log(\n    `Final updated text: ${JSON.parse(updatedPost.postData).text}`\n  );\n  return updatedPost;\n}\n","numLines":374,"startLine":1,"totalLines":374}}}
{"parentUuid":"b90a8239-a488-4032-af37-9f6dfd42705d","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011jKriZx9gdZgyjACw6T7DQ","type":"tool_result","content":"     1→\"\"\"\n     2→Socialaize AI API - Appwrite Function\n     3→Streamlined AI service with LlamaIndex workflows and function calling\n     4→\"\"\"\n     5→\n     6→import json\n     7→import asyncio\n     8→from .services.ai_service import AIService\n     9→from .services.conversation_cache import ConversationCache\n    10→from .services.appwrite_client import AppwriteClientService\n    11→from .services.billing_service import BillingService\n    12→from .schemas.requests import ChatRequest, ActionRequest\n    13→from .schemas.responses import ChatResponse, ActionResponse, ErrorResponse\n    14→import os\n    15→\n    16→\n    17→# Global instances\n    18→ai_service: AIService | None = None\n    19→conversation_cache: ConversationCache | None = None\n    20→appwrite_service: AppwriteClientService | None = None\n    21→billing_service: BillingService | None = None\n    22→\n    23→\n    24→async def setup_services(context) -> None:\n    25→    \"\"\"Initialize services with Appwrite context\"\"\"\n    26→    global ai_service, conversation_cache, appwrite_service, billing_service\n    27→    \n    28→    if ai_service is None:\n    29→        context.log(\"Initializing AI services...\")\n    30→        \n    31→        # Get environment variables\n    32→        openai_api_key = context.req.headers.get(\"OPENAI_API_KEY\") or os.getenv(\"OPENAI_API_KEY\")\n    33→        if not openai_api_key:\n    34→            raise ValueError(\"OPENAI_API_KEY not found in headers or variables\")\n    35→        \n    36→        # Initialize Appwrite client service\n    37→        appwrite_service = AppwriteClientService(context)\n    38→        \n    39→        # Initialize billing service\n    40→        billing_service = BillingService(appwrite_service, context)\n    41→        \n    42→        # Initialize conversation cache\n    43→        conversation_cache = ConversationCache()\n    44→        \n    45→        # Initialize AI service with billing integration\n    46→        ai_service = AIService(\n    47→            openai_api_key=openai_api_key,\n    48→            context=context,\n    49→            billing_service=billing_service,\n    50→            appwrite_service=appwrite_service\n    51→        )\n    52→        \n    53→        context.log(\"AI services initialized successfully with billing integration\")\n    54→\n    55→\n    56→async def main(context):\n    57→    \"\"\"Main function entry point for Appwrite function\"\"\"\n    58→    try:\n    59→        context.log(\"Starting AI API function execution\")\n    60→        \n    61→        # Setup services\n    62→        await setup_services(context)\n    63→        \n    64→        # Parse request method and path\n    65→        method = context.req.method\n    66→        path = context.req.path.strip('/')\n    67→        \n    68→        context.log(f\"Processing {method} request to /{path}\")\n    69→        \n    70→        if method != 'POST':\n    71→            return context.res.json({\n    72→                \"error\": \"Method not allowed\",\n    73→                \"message\": \"Only POST requests are supported\"\n    74→            }, 405)\n    75→        \n    76→        # Get request body\n    77→        body = context.req.body\n    78→        if isinstance(body, str):\n    79→            try:\n    80→                body = json.loads(body)\n    81→            except json.JSONDecodeError:\n    82→                return context.res.json({\n    83→                    \"error\": \"Invalid JSON\",\n    84→                    \"message\": \"Request body must be valid JSON\"\n    85→                }, 400)\n    86→        context.log(f\"Request Body: {json.dumps(body, indent=4)}\")\n    87→        \n    88→        # Route based on path\n    89→        if path == 'chat' or path == '':\n    90→            return await handle_chat(context, body)\n    91→        elif path == 'action':\n    92→            return await handle_action(context, body)\n    93→        else:\n    94→            return context.res.json({\n    95→                \"error\": \"Unknown endpoint\",\n    96→                \"message\": f\"Endpoint /{path} not found. Available: /chat, /action\"\n    97→            }, 404)\n    98→            \n    99→    except Exception as e:\n   100→        context.error(f\"Function execution failed: {str(e)}\")\n   101→        return context.res.json({\n   102→            \"error\": \"Internal server error\",\n   103→            \"message\": str(e)\n   104→        }, 500)\n   105→\n   106→\n   107→async def handle_chat(context, body: dict):\n   108→    \"\"\"Handle chat requests\"\"\"\n   109→    try:\n   110→        context.log(\"Processing chat request\")\n   111→        \n   112→        # Validate request\n   113→        try:\n   114→            chat_request = ChatRequest(**body)\n   115→        except Exception as e:\n   116→            return context.res.json({\n   117→                \"error\": \"Validation error\",\n   118→                \"message\": f\"Invalid chat request: {str(e)}\"\n   119→            }, 400)\n   120→        \n   121→        # Get user info from headers\n   122→        user_id = context.req.headers.get('z-appwrite-user-id')\n   123→        if not user_id:\n   124→            return context.res.json({\n   125→                \"error\": \"Authentication required\",\n   126→                \"message\": \"User ID not found in request headers\"\n   127→            }, 401)\n   128→        \n   129→        context.log(f\"Processing chat for user: {user_id}\")\n   130→        \n   131→        # Process chat\n   132→        response = await ai_service.process_chat(\n   133→            chat_request=chat_request,\n   134→            user_id=user_id,\n   135→            conversation_cache=conversation_cache\n   136→        )\n   137→        \n   138→        context.log(\"Chat processed successfully\")\n   139→        return context.res.json(response.model_dump())\n   140→        \n   141→    except Exception as e:\n   142→        context.error(f\"Chat processing error: {str(e)}\")\n   143→        \n   144→        # Handle billing-specific errors\n   145→        error_message = str(e)\n   146→        if \"Credit validation failed\" in error_message:\n   147→            return context.res.json({\n   148→                \"error\": \"Insufficient credits\",\n   149→                \"message\": error_message,\n   150→                \"error_type\": \"billing\"\n   151→            }, 402)  # Payment Required\n   152→        \n   153→        return context.res.json({\n   154→            \"error\": \"Chat processing failed\",\n   155→            \"message\": str(e)\n   156→        }, 500)\n   157→\n   158→\n   159→async def handle_action(context, body: dict):\n   160→    \"\"\"Handle AI action requests (rewrite, translate, etc.)\"\"\"\n   161→    try:\n   162→        context.log(\"Processing action request\")\n   163→        \n   164→        # Validate request\n   165→        try:\n   166→            # If action_config is nested, flatten it\n   167→            if \"action_config\" in body:\n   168→                request_data = body[\"action_config\"]\n   169→            else:\n   170→                request_data = body\n   171→            \n   172→            action_request = ActionRequest(**request_data)\n   173→        except Exception as e:\n   174→            context.log(f\"Action request validation failed: {str(e)}\")\n   175→            return context.res.json({\n   176→                \"error\": \"Validation error\",\n   177→                \"message\": f\"Invalid action request: {str(e)}\"\n   178→            }, 400)\n   179→        \n   180→        # Get user info from headers\n   181→        user_id = body.get(\"user_id\") or context.req.headers.get('x-appwrite-user-id')\n   182→        if not user_id:\n   183→            context.log(\"User ID not found in request headers\")\n   184→            return context.res.json({\n   185→                \"error\": \"Authentication required\",\n   186→                \"message\": \"User ID not found in request headers\"\n   187→            }, 401)\n   188→        \n   189→        context.log(f\"Processing action '{action_request.action}' for user: {user_id}\")\n   190→        \n   191→        # Process action\n   192→        response = await ai_service.process_action(\n   193→            action_request=action_request,\n   194→            user_id=user_id\n   195→        )\n   196→        \n   197→        context.log(f\"Action '{action_request.action}' processed successfully, final output: {json.dumps(response.model_dump(), indent=4)}\")\n   198→        return context.res.json(response.model_dump())\n   199→        \n   200→    except Exception as e:\n   201→        context.error(f\"Action processing error: {str(e)}\")\n   202→        \n   203→        # Handle billing-specific errors\n   204→        error_message = str(e)\n   205→        if \"Credit validation failed\" in error_message:\n   206→            return context.res.json({\n   207→                \"error\": \"Insufficient credits\",\n   208→                \"message\": error_message,\n   209→                \"error_type\": \"billing\"\n   210→            }, 402)  # Payment Required\n   211→        \n   212→        return context.res.json({\n   213→            \"error\": \"Action processing failed\",\n   214→            \"message\": str(e)\n   215→        }, 500)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"3363ddf1-0303-46f3-912c-907ea92c4ea0","timestamp":"2025-09-30T20:36:03.600Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/natedamstra/socialaize/functions/AI_API/src/main.py","content":"\"\"\"\nSocialaize AI API - Appwrite Function\nStreamlined AI service with LlamaIndex workflows and function calling\n\"\"\"\n\nimport json\nimport asyncio\nfrom .services.ai_service import AIService\nfrom .services.conversation_cache import ConversationCache\nfrom .services.appwrite_client import AppwriteClientService\nfrom .services.billing_service import BillingService\nfrom .schemas.requests import ChatRequest, ActionRequest\nfrom .schemas.responses import ChatResponse, ActionResponse, ErrorResponse\nimport os\n\n\n# Global instances\nai_service: AIService | None = None\nconversation_cache: ConversationCache | None = None\nappwrite_service: AppwriteClientService | None = None\nbilling_service: BillingService | None = None\n\n\nasync def setup_services(context) -> None:\n    \"\"\"Initialize services with Appwrite context\"\"\"\n    global ai_service, conversation_cache, appwrite_service, billing_service\n    \n    if ai_service is None:\n        context.log(\"Initializing AI services...\")\n        \n        # Get environment variables\n        openai_api_key = context.req.headers.get(\"OPENAI_API_KEY\") or os.getenv(\"OPENAI_API_KEY\")\n        if not openai_api_key:\n            raise ValueError(\"OPENAI_API_KEY not found in headers or variables\")\n        \n        # Initialize Appwrite client service\n        appwrite_service = AppwriteClientService(context)\n        \n        # Initialize billing service\n        billing_service = BillingService(appwrite_service, context)\n        \n        # Initialize conversation cache\n        conversation_cache = ConversationCache()\n        \n        # Initialize AI service with billing integration\n        ai_service = AIService(\n            openai_api_key=openai_api_key,\n            context=context,\n            billing_service=billing_service,\n            appwrite_service=appwrite_service\n        )\n        \n        context.log(\"AI services initialized successfully with billing integration\")\n\n\nasync def main(context):\n    \"\"\"Main function entry point for Appwrite function\"\"\"\n    try:\n        context.log(\"Starting AI API function execution\")\n        \n        # Setup services\n        await setup_services(context)\n        \n        # Parse request method and path\n        method = context.req.method\n        path = context.req.path.strip('/')\n        \n        context.log(f\"Processing {method} request to /{path}\")\n        \n        if method != 'POST':\n            return context.res.json({\n                \"error\": \"Method not allowed\",\n                \"message\": \"Only POST requests are supported\"\n            }, 405)\n        \n        # Get request body\n        body = context.req.body\n        if isinstance(body, str):\n            try:\n                body = json.loads(body)\n            except json.JSONDecodeError:\n                return context.res.json({\n                    \"error\": \"Invalid JSON\",\n                    \"message\": \"Request body must be valid JSON\"\n                }, 400)\n        context.log(f\"Request Body: {json.dumps(body, indent=4)}\")\n        \n        # Route based on path\n        if path == 'chat' or path == '':\n            return await handle_chat(context, body)\n        elif path == 'action':\n            return await handle_action(context, body)\n        else:\n            return context.res.json({\n                \"error\": \"Unknown endpoint\",\n                \"message\": f\"Endpoint /{path} not found. Available: /chat, /action\"\n            }, 404)\n            \n    except Exception as e:\n        context.error(f\"Function execution failed: {str(e)}\")\n        return context.res.json({\n            \"error\": \"Internal server error\",\n            \"message\": str(e)\n        }, 500)\n\n\nasync def handle_chat(context, body: dict):\n    \"\"\"Handle chat requests\"\"\"\n    try:\n        context.log(\"Processing chat request\")\n        \n        # Validate request\n        try:\n            chat_request = ChatRequest(**body)\n        except Exception as e:\n            return context.res.json({\n                \"error\": \"Validation error\",\n                \"message\": f\"Invalid chat request: {str(e)}\"\n            }, 400)\n        \n        # Get user info from headers\n        user_id = context.req.headers.get('z-appwrite-user-id')\n        if not user_id:\n            return context.res.json({\n                \"error\": \"Authentication required\",\n                \"message\": \"User ID not found in request headers\"\n            }, 401)\n        \n        context.log(f\"Processing chat for user: {user_id}\")\n        \n        # Process chat\n        response = await ai_service.process_chat(\n            chat_request=chat_request,\n            user_id=user_id,\n            conversation_cache=conversation_cache\n        )\n        \n        context.log(\"Chat processed successfully\")\n        return context.res.json(response.model_dump())\n        \n    except Exception as e:\n        context.error(f\"Chat processing error: {str(e)}\")\n        \n        # Handle billing-specific errors\n        error_message = str(e)\n        if \"Credit validation failed\" in error_message:\n            return context.res.json({\n                \"error\": \"Insufficient credits\",\n                \"message\": error_message,\n                \"error_type\": \"billing\"\n            }, 402)  # Payment Required\n        \n        return context.res.json({\n            \"error\": \"Chat processing failed\",\n            \"message\": str(e)\n        }, 500)\n\n\nasync def handle_action(context, body: dict):\n    \"\"\"Handle AI action requests (rewrite, translate, etc.)\"\"\"\n    try:\n        context.log(\"Processing action request\")\n        \n        # Validate request\n        try:\n            # If action_config is nested, flatten it\n            if \"action_config\" in body:\n                request_data = body[\"action_config\"]\n            else:\n                request_data = body\n            \n            action_request = ActionRequest(**request_data)\n        except Exception as e:\n            context.log(f\"Action request validation failed: {str(e)}\")\n            return context.res.json({\n                \"error\": \"Validation error\",\n                \"message\": f\"Invalid action request: {str(e)}\"\n            }, 400)\n        \n        # Get user info from headers\n        user_id = body.get(\"user_id\") or context.req.headers.get('x-appwrite-user-id')\n        if not user_id:\n            context.log(\"User ID not found in request headers\")\n            return context.res.json({\n                \"error\": \"Authentication required\",\n                \"message\": \"User ID not found in request headers\"\n            }, 401)\n        \n        context.log(f\"Processing action '{action_request.action}' for user: {user_id}\")\n        \n        # Process action\n        response = await ai_service.process_action(\n            action_request=action_request,\n            user_id=user_id\n        )\n        \n        context.log(f\"Action '{action_request.action}' processed successfully, final output: {json.dumps(response.model_dump(), indent=4)}\")\n        return context.res.json(response.model_dump())\n        \n    except Exception as e:\n        context.error(f\"Action processing error: {str(e)}\")\n        \n        # Handle billing-specific errors\n        error_message = str(e)\n        if \"Credit validation failed\" in error_message:\n            return context.res.json({\n                \"error\": \"Insufficient credits\",\n                \"message\": error_message,\n                \"error_type\": \"billing\"\n            }, 402)  # Payment Required\n        \n        return context.res.json({\n            \"error\": \"Action processing failed\",\n            \"message\": str(e)\n        }, 500)","numLines":215,"startLine":1,"totalLines":215}}}
{"parentUuid":"3363ddf1-0303-46f3-912c-907ea92c4ea0","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0148s39Rn3sWidzK97jth1ro","type":"tool_result","content":"     1→\"\"\"Request schemas for AI API\"\"\"\n     2→\n     3→from typing import Any, Literal\n     4→from pydantic import BaseModel, Field\n     5→\n     6→\n     7→class ChatMessage(BaseModel):\n     8→    \"\"\"Individual chat message\"\"\"\n     9→    role: Literal[\"user\", \"assistant\", \"system\"]\n    10→    content: str\n    11→    metadata: dict[str, Any] = Field(default_factory=dict)\n    12→\n    13→\n    14→class ChatRequest(BaseModel):\n    15→    \"\"\"Chat conversation request\"\"\"\n    16→    message: str = Field(..., description=\"User message content\")\n    17→    chat_id: str | None = Field(None, description=\"Conversation ID for continuity\")\n    18→    context: dict[str, Any] = Field(default_factory=dict, description=\"Additional context\")\n    19→    max_tokens: int = Field(default=2000, ge=1, le=4000)\n    20→    temperature: float = Field(default=0.7, ge=0.0, le=2.0)\n    21→    tools_enabled: bool = Field(default=True, description=\"Enable function calling tools\")\n    22→\n    23→\n    24→class ActionRequest(BaseModel):\n    25→    \"\"\"AI action request for content processing\"\"\"\n    26→    action: Literal[\n    27→        \"ai_translate\", \n    28→        \"ai_rewrite\", \n    29→        \"ai_summarize\", \n    30→        \"ai_gen_content\", \n    31→        \"ai_gen_title\", \n    32→        \"ai_gen_tags\"\n    33→    ] = Field(..., description=\"Type of AI action to perform\")\n    34→    \n    35→    content: str = Field(..., description=\"Content to process\")\n    36→    \n    37→    # Action-specific parameters\n    38→    target_language: str | None = Field(None, description=\"Target language for translation\")\n    39→    tone: str | None = Field(None, description=\"Desired tone (casual, professional, etc.)\")\n    40→    length: Literal[\"shorter\", \"longer\", \"same\"] | None = Field(None, description=\"Content length adjustment\")\n    41→    platform: str | None = Field(None, description=\"Target social platform\")\n    42→    style: str | None = Field(None, description=\"Writing style preference\")\n    43→    \n    44→    # Common parameters\n    45→    max_tokens: int = Field(default=2000, ge=1, le=4000)\n    46→    temperature: float = Field(default=0.7, ge=0.0, le=2.0)\n    47→    context: dict[str, Any] = Field(default_factory=dict, description=\"Additional context\")\n    48→\n    49→\n    50→class ActionConfig(BaseModel):\n    51→    \"\"\"Configuration for action processing\"\"\"\n    52→    preserve_formatting: bool = Field(default=True)\n    53→    include_hashtags: bool = Field(default=False)\n    54→    character_limit: int | None = Field(None, ge=1)\n    55→    custom_instructions: str | None = Field(None)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"798dcc20-aabf-475c-8a94-8e771bb4dc40","timestamp":"2025-09-30T20:36:03.600Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/natedamstra/socialaize/functions/AI_API/src/schemas/requests.py","content":"\"\"\"Request schemas for AI API\"\"\"\n\nfrom typing import Any, Literal\nfrom pydantic import BaseModel, Field\n\n\nclass ChatMessage(BaseModel):\n    \"\"\"Individual chat message\"\"\"\n    role: Literal[\"user\", \"assistant\", \"system\"]\n    content: str\n    metadata: dict[str, Any] = Field(default_factory=dict)\n\n\nclass ChatRequest(BaseModel):\n    \"\"\"Chat conversation request\"\"\"\n    message: str = Field(..., description=\"User message content\")\n    chat_id: str | None = Field(None, description=\"Conversation ID for continuity\")\n    context: dict[str, Any] = Field(default_factory=dict, description=\"Additional context\")\n    max_tokens: int = Field(default=2000, ge=1, le=4000)\n    temperature: float = Field(default=0.7, ge=0.0, le=2.0)\n    tools_enabled: bool = Field(default=True, description=\"Enable function calling tools\")\n\n\nclass ActionRequest(BaseModel):\n    \"\"\"AI action request for content processing\"\"\"\n    action: Literal[\n        \"ai_translate\", \n        \"ai_rewrite\", \n        \"ai_summarize\", \n        \"ai_gen_content\", \n        \"ai_gen_title\", \n        \"ai_gen_tags\"\n    ] = Field(..., description=\"Type of AI action to perform\")\n    \n    content: str = Field(..., description=\"Content to process\")\n    \n    # Action-specific parameters\n    target_language: str | None = Field(None, description=\"Target language for translation\")\n    tone: str | None = Field(None, description=\"Desired tone (casual, professional, etc.)\")\n    length: Literal[\"shorter\", \"longer\", \"same\"] | None = Field(None, description=\"Content length adjustment\")\n    platform: str | None = Field(None, description=\"Target social platform\")\n    style: str | None = Field(None, description=\"Writing style preference\")\n    \n    # Common parameters\n    max_tokens: int = Field(default=2000, ge=1, le=4000)\n    temperature: float = Field(default=0.7, ge=0.0, le=2.0)\n    context: dict[str, Any] = Field(default_factory=dict, description=\"Additional context\")\n\n\nclass ActionConfig(BaseModel):\n    \"\"\"Configuration for action processing\"\"\"\n    preserve_formatting: bool = Field(default=True)\n    include_hashtags: bool = Field(default=False)\n    character_limit: int | None = Field(None, ge=1)\n    custom_instructions: str | None = Field(None)","numLines":55,"startLine":1,"totalLines":55}}}
{"parentUuid":"798dcc20-aabf-475c-8a94-8e771bb4dc40","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q7VRdaw7bpM8sqFNs3hML5","type":"tool_result","content":"     1→\"\"\"Schemas for AI action responses\"\"\"\n     2→\n     3→from typing import Any, Dict, List, Optional, Union\n     4→from pydantic import BaseModel, Field\n     5→from datetime import datetime\n     6→\n     7→\n     8→class MediaSuggestion(BaseModel):\n     9→    \"\"\"Suggested media for a post\"\"\"\n    10→    type: str = Field(..., description=\"Media type: image, video, carousel\")\n    11→    description: str = Field(..., description=\"Description of suggested media\")\n    12→    alt_text: Optional[str] = Field(None, description=\"Suggested alt text\")\n    13→    aspect_ratio: Optional[str] = Field(None, description=\"Suggested aspect ratio (e.g. '1:1', '16:9')\")\n    14→\n    15→\n    16→class PostDraft(BaseModel):\n    17→    \"\"\"AI-generated post draft\"\"\"\n    18→    id: str = Field(..., description=\"Unique identifier for the draft\")\n    19→    text: str = Field(..., description=\"Post text content\")\n    20→    platform: str = Field(..., description=\"Target platform (instagram, facebook, etc.)\")\n    21→    hashtags: List[str] = Field(default_factory=list, description=\"Suggested hashtags\")\n    22→    mentions: List[str] = Field(default_factory=list, description=\"Suggested mentions\")\n    23→    media_suggestions: List[MediaSuggestion] = Field(default_factory=list, description=\"Suggested media\")\n    24→    posting_time: Optional[datetime] = Field(None, description=\"Suggested posting time\")\n    25→    content_type: str = Field(..., description=\"Post type: text, image, video, carousel\")\n    26→    confidence_score: float = Field(..., ge=0.0, le=1.0, description=\"AI confidence in this suggestion\")\n    27→    based_on: List[str] = Field(default_factory=list, description=\"What this draft is based on\")\n    28→\n    29→\n    30→class CreatePostAction(BaseModel):\n    31→    \"\"\"Action to create a single post\"\"\"\n    32→    type: str = Field(default=\"create_post\", description=\"Action type\")\n    33→    data: PostDraft = Field(..., description=\"Post draft data\")\n    34→\n    35→\n    36→class SchedulePostsAction(BaseModel):\n    37→    \"\"\"Action to schedule multiple posts\"\"\"\n    38→    type: str = Field(default=\"schedule_posts\", description=\"Action type\")\n    39→    data: Dict[str, Any] = Field(..., description=\"Scheduling data\")\n    40→    \n    41→    class ScheduledPost(BaseModel):\n    42→        text: str\n    43→        platform: str\n    44→        scheduled_for: datetime\n    45→        hashtags: List[str] = Field(default_factory=list)\n    46→        media_suggestions: List[MediaSuggestion] = Field(default_factory=list)\n    47→\n    48→\n    49→class CalendarEvent(BaseModel):\n    50→    \"\"\"Content calendar event\"\"\"\n    51→    id: str = Field(..., description=\"Event identifier\")\n    52→    day: int = Field(..., description=\"Day number in calendar\")\n    53→    date: datetime = Field(..., description=\"Scheduled date/time\")\n    54→    platform: str = Field(..., description=\"Target platform\")\n    55→    content_type: str = Field(..., description=\"Type of content\")\n    56→    topic_suggestion: str = Field(..., description=\"Suggested topic\")\n    57→    status: str = Field(..., description=\"Event status: suggested, scheduled, completed\")\n    58→    estimated_engagement: Optional[float] = Field(None, description=\"Predicted engagement\")\n    59→\n    60→\n    61→class CreateCalendarAction(BaseModel):\n    62→    \"\"\"Action to create content calendar\"\"\"\n    63→    type: str = Field(default=\"create_calendar\", description=\"Action type\")\n    64→    data: Dict[str, Any] = Field(..., description=\"Calendar data\")\n    65→    \n    66→    class CalendarData(BaseModel):\n    67→        start_date: datetime\n    68→        duration_days: int\n    69→        total_posts: int\n    70→        posts_per_day: int\n    71→        schedule: List[CalendarEvent]\n    72→        platforms: List[str]\n    73→        content_themes: List[str] = Field(default_factory=list)\n    74→\n    75→\n    76→class PerformanceInsight(BaseModel):\n    77→    \"\"\"Performance analysis insight\"\"\"\n    78→    metric: str = Field(..., description=\"Metric name\")\n    79→    value: Union[str, float, int] = Field(..., description=\"Metric value\")\n    80→    change: Optional[float] = Field(None, description=\"Change from previous period\")\n    81→    trend: Optional[str] = Field(None, description=\"Trend direction: up, down, stable\")\n    82→    recommendation: Optional[str] = Field(None, description=\"Recommended action\")\n    83→\n    84→\n    85→class AnalyzePerformanceAction(BaseModel):\n    86→    \"\"\"Action to show performance analysis\"\"\"\n    87→    type: str = Field(default=\"analyze_performance\", description=\"Action type\")\n    88→    data: Dict[str, Any] = Field(..., description=\"Analysis data\")\n    89→    \n    90→    class AnalysisData(BaseModel):\n    91→        platform: Optional[str] = None\n    92→        time_period: str\n    93→        insights: List[PerformanceInsight]\n    94→        top_posts: List[Dict[str, Any]] = Field(default_factory=list)\n    95→        recommendations: List[str] = Field(default_factory=list)\n    96→\n    97→\n    98→class ExportData(BaseModel):\n    99→    \"\"\"Export data specification\"\"\"\n   100→    format: str = Field(..., description=\"Export format: csv, pdf, json\")\n   101→    data_type: str = Field(..., description=\"Data type: analytics, posts, engagement\")\n   102→    time_range: str = Field(..., description=\"Time range for export\")\n   103→    platforms: List[str] = Field(default_factory=list, description=\"Platforms to include\")\n   104→    filename: Optional[str] = Field(None, description=\"Suggested filename\")\n   105→\n   106→\n   107→class ExportAnalyticsAction(BaseModel):\n   108→    \"\"\"Action to export analytics\"\"\"\n   109→    type: str = Field(default=\"export_analytics\", description=\"Action type\")\n   110→    data: ExportData = Field(..., description=\"Export specification\")\n   111→\n   112→\n   113→class AccountConnection(BaseModel):\n   114→    \"\"\"Account connection information\"\"\"\n   115→    platform: str = Field(..., description=\"Platform name\")\n   116→    account_name: str = Field(..., description=\"Account display name\")\n   117→    is_connected: bool = Field(..., description=\"Connection status\")\n   118→    expires_at: Optional[datetime] = Field(None, description=\"Token expiration\")\n   119→    needs_reauth: bool = Field(default=False, description=\"Needs re-authentication\")\n   120→    health_status: str = Field(..., description=\"Health status: healthy, warning, error\")\n   121→\n   122→\n   123→class ManageAccountsAction(BaseModel):\n   124→    \"\"\"Action to manage account connections\"\"\"\n   125→    type: str = Field(default=\"manage_accounts\", description=\"Action type\")\n   126→    data: Dict[str, Any] = Field(..., description=\"Account management data\")\n   127→    \n   128→    class AccountData(BaseModel):\n   129→        accounts: List[AccountConnection]\n   130→        issues: List[str] = Field(default_factory=list)\n   131→        recommendations: List[str] = Field(default_factory=list)\n   132→\n   133→\n   134→class AIActionResponse(BaseModel):\n   135→    \"\"\"Complete AI response with message and actions\"\"\"\n   136→    message: str = Field(..., description=\"Text response from AI\")\n   137→    actions: List[Union[\n   138→        CreatePostAction,\n   139→        SchedulePostsAction,\n   140→        CreateCalendarAction,\n   141→        AnalyzePerformanceAction,\n   142→        ExportAnalyticsAction,\n   143→        ManageAccountsAction\n   144→    ]] = Field(default_factory=list, description=\"Actionable items\")\n   145→    has_actions: bool = Field(..., description=\"Whether response includes actions\")\n   146→    response_type: str = Field(..., description=\"Response type: text or actionable\")\n   147→    chat_id: str = Field(..., description=\"Chat session identifier\")\n   148→    timestamp: datetime = Field(default_factory=datetime.utcnow, description=\"Response timestamp\")\n   149→    tokens_used: Optional[Dict[str, Any]] = Field(None, description=\"Token usage information\")\n   150→    tools_used: List[str] = Field(default_factory=list, description=\"Tools used in generating response\")\n   151→\n   152→\n   153→class ActionExecutionRequest(BaseModel):\n   154→    \"\"\"Request to execute an AI-suggested action\"\"\"\n   155→    action_id: str = Field(..., description=\"Action identifier\")\n   156→    action_type: str = Field(..., description=\"Type of action to execute\")\n   157→    user_modifications: Optional[Dict[str, Any]] = Field(None, description=\"User modifications to the action\")\n   158→    execute_immediately: bool = Field(default=False, description=\"Execute immediately or save as draft\")\n   159→\n   160→\n   161→class ActionExecutionResponse(BaseModel):\n   162→    \"\"\"Response from action execution\"\"\"\n   163→    action_id: str = Field(..., description=\"Executed action identifier\")\n   164→    status: str = Field(..., description=\"Execution status: success, error, pending\")\n   165→    result: Optional[Dict[str, Any]] = Field(None, description=\"Execution result\")\n   166→    error: Optional[str] = Field(None, description=\"Error message if failed\")\n   167→    next_steps: List[str] = Field(default_factory=list, description=\"Suggested next steps\")\n   168→    created_items: List[Dict[str, Any]] = Field(default_factory=list, description=\"Items created by this action\")\n   169→\n   170→\n   171→# UI Component Schemas for Frontend\n   172→class UIButton(BaseModel):\n   173→    \"\"\"UI Button component\"\"\"\n   174→    label: str\n   175→    action: str\n   176→    variant: str = Field(default=\"primary\", description=\"Button variant: primary, secondary, danger\")\n   177→    disabled: bool = Field(default=False)\n   178→    loading: bool = Field(default=False)\n   179→\n   180→\n   181→class UIPostPreview(BaseModel):\n   182→    \"\"\"UI Post preview component\"\"\"\n   183→    post_data: PostDraft\n   184→    platforms: List[str]\n   185→    actions: List[UIButton] = Field(default_factory=list)\n   186→    editable: bool = Field(default=True)\n   187→\n   188→\n   189→class UICalendarWidget(BaseModel):\n   190→    \"\"\"UI Calendar widget component\"\"\"\n   191→    calendar_data: Dict[str, Any]\n   192→    view_mode: str = Field(default=\"week\", description=\"View mode: day, week, month\")\n   193→    actions: List[UIButton] = Field(default_factory=list)\n   194→    editable: bool = Field(default=True)\n   195→\n   196→\n   197→class UIAnalyticsChart(BaseModel):\n   198→    \"\"\"UI Analytics chart component\"\"\"\n   199→    chart_type: str = Field(..., description=\"Chart type: line, bar, pie, etc.\")\n   200→    data: Dict[str, Any] = Field(..., description=\"Chart data\")\n   201→    title: str = Field(..., description=\"Chart title\")\n   202→    description: Optional[str] = Field(None, description=\"Chart description\")\n   203→    actions: List[UIButton] = Field(default_factory=list)\n   204→\n   205→\n   206→class UIActionCard(BaseModel):\n   207→    \"\"\"UI Action card component\"\"\"\n   208→    action: Union[\n   209→        CreatePostAction,\n   210→        SchedulePostsAction,\n   211→        CreateCalendarAction,\n   212→        AnalyzePerformanceAction,\n   213→        ExportAnalyticsAction,\n   214→        ManageAccountsAction\n   215→    ]\n   216→    ui_component: Union[UIPostPreview, UICalendarWidget, UIAnalyticsChart, Dict[str, Any]]\n   217→    actions: List[UIButton] = Field(default_factory=list)\n   218→    collapsible: bool = Field(default=True)\n   219→    expanded: bool = Field(default=False)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"061bea99-e2be-4b8d-a9b7-3e912450f3d6","timestamp":"2025-09-30T20:36:03.600Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/natedamstra/socialaize/functions/AI_API/src/schemas/action_responses.py","content":"\"\"\"Schemas for AI action responses\"\"\"\n\nfrom typing import Any, Dict, List, Optional, Union\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\n\nclass MediaSuggestion(BaseModel):\n    \"\"\"Suggested media for a post\"\"\"\n    type: str = Field(..., description=\"Media type: image, video, carousel\")\n    description: str = Field(..., description=\"Description of suggested media\")\n    alt_text: Optional[str] = Field(None, description=\"Suggested alt text\")\n    aspect_ratio: Optional[str] = Field(None, description=\"Suggested aspect ratio (e.g. '1:1', '16:9')\")\n\n\nclass PostDraft(BaseModel):\n    \"\"\"AI-generated post draft\"\"\"\n    id: str = Field(..., description=\"Unique identifier for the draft\")\n    text: str = Field(..., description=\"Post text content\")\n    platform: str = Field(..., description=\"Target platform (instagram, facebook, etc.)\")\n    hashtags: List[str] = Field(default_factory=list, description=\"Suggested hashtags\")\n    mentions: List[str] = Field(default_factory=list, description=\"Suggested mentions\")\n    media_suggestions: List[MediaSuggestion] = Field(default_factory=list, description=\"Suggested media\")\n    posting_time: Optional[datetime] = Field(None, description=\"Suggested posting time\")\n    content_type: str = Field(..., description=\"Post type: text, image, video, carousel\")\n    confidence_score: float = Field(..., ge=0.0, le=1.0, description=\"AI confidence in this suggestion\")\n    based_on: List[str] = Field(default_factory=list, description=\"What this draft is based on\")\n\n\nclass CreatePostAction(BaseModel):\n    \"\"\"Action to create a single post\"\"\"\n    type: str = Field(default=\"create_post\", description=\"Action type\")\n    data: PostDraft = Field(..., description=\"Post draft data\")\n\n\nclass SchedulePostsAction(BaseModel):\n    \"\"\"Action to schedule multiple posts\"\"\"\n    type: str = Field(default=\"schedule_posts\", description=\"Action type\")\n    data: Dict[str, Any] = Field(..., description=\"Scheduling data\")\n    \n    class ScheduledPost(BaseModel):\n        text: str\n        platform: str\n        scheduled_for: datetime\n        hashtags: List[str] = Field(default_factory=list)\n        media_suggestions: List[MediaSuggestion] = Field(default_factory=list)\n\n\nclass CalendarEvent(BaseModel):\n    \"\"\"Content calendar event\"\"\"\n    id: str = Field(..., description=\"Event identifier\")\n    day: int = Field(..., description=\"Day number in calendar\")\n    date: datetime = Field(..., description=\"Scheduled date/time\")\n    platform: str = Field(..., description=\"Target platform\")\n    content_type: str = Field(..., description=\"Type of content\")\n    topic_suggestion: str = Field(..., description=\"Suggested topic\")\n    status: str = Field(..., description=\"Event status: suggested, scheduled, completed\")\n    estimated_engagement: Optional[float] = Field(None, description=\"Predicted engagement\")\n\n\nclass CreateCalendarAction(BaseModel):\n    \"\"\"Action to create content calendar\"\"\"\n    type: str = Field(default=\"create_calendar\", description=\"Action type\")\n    data: Dict[str, Any] = Field(..., description=\"Calendar data\")\n    \n    class CalendarData(BaseModel):\n        start_date: datetime\n        duration_days: int\n        total_posts: int\n        posts_per_day: int\n        schedule: List[CalendarEvent]\n        platforms: List[str]\n        content_themes: List[str] = Field(default_factory=list)\n\n\nclass PerformanceInsight(BaseModel):\n    \"\"\"Performance analysis insight\"\"\"\n    metric: str = Field(..., description=\"Metric name\")\n    value: Union[str, float, int] = Field(..., description=\"Metric value\")\n    change: Optional[float] = Field(None, description=\"Change from previous period\")\n    trend: Optional[str] = Field(None, description=\"Trend direction: up, down, stable\")\n    recommendation: Optional[str] = Field(None, description=\"Recommended action\")\n\n\nclass AnalyzePerformanceAction(BaseModel):\n    \"\"\"Action to show performance analysis\"\"\"\n    type: str = Field(default=\"analyze_performance\", description=\"Action type\")\n    data: Dict[str, Any] = Field(..., description=\"Analysis data\")\n    \n    class AnalysisData(BaseModel):\n        platform: Optional[str] = None\n        time_period: str\n        insights: List[PerformanceInsight]\n        top_posts: List[Dict[str, Any]] = Field(default_factory=list)\n        recommendations: List[str] = Field(default_factory=list)\n\n\nclass ExportData(BaseModel):\n    \"\"\"Export data specification\"\"\"\n    format: str = Field(..., description=\"Export format: csv, pdf, json\")\n    data_type: str = Field(..., description=\"Data type: analytics, posts, engagement\")\n    time_range: str = Field(..., description=\"Time range for export\")\n    platforms: List[str] = Field(default_factory=list, description=\"Platforms to include\")\n    filename: Optional[str] = Field(None, description=\"Suggested filename\")\n\n\nclass ExportAnalyticsAction(BaseModel):\n    \"\"\"Action to export analytics\"\"\"\n    type: str = Field(default=\"export_analytics\", description=\"Action type\")\n    data: ExportData = Field(..., description=\"Export specification\")\n\n\nclass AccountConnection(BaseModel):\n    \"\"\"Account connection information\"\"\"\n    platform: str = Field(..., description=\"Platform name\")\n    account_name: str = Field(..., description=\"Account display name\")\n    is_connected: bool = Field(..., description=\"Connection status\")\n    expires_at: Optional[datetime] = Field(None, description=\"Token expiration\")\n    needs_reauth: bool = Field(default=False, description=\"Needs re-authentication\")\n    health_status: str = Field(..., description=\"Health status: healthy, warning, error\")\n\n\nclass ManageAccountsAction(BaseModel):\n    \"\"\"Action to manage account connections\"\"\"\n    type: str = Field(default=\"manage_accounts\", description=\"Action type\")\n    data: Dict[str, Any] = Field(..., description=\"Account management data\")\n    \n    class AccountData(BaseModel):\n        accounts: List[AccountConnection]\n        issues: List[str] = Field(default_factory=list)\n        recommendations: List[str] = Field(default_factory=list)\n\n\nclass AIActionResponse(BaseModel):\n    \"\"\"Complete AI response with message and actions\"\"\"\n    message: str = Field(..., description=\"Text response from AI\")\n    actions: List[Union[\n        CreatePostAction,\n        SchedulePostsAction,\n        CreateCalendarAction,\n        AnalyzePerformanceAction,\n        ExportAnalyticsAction,\n        ManageAccountsAction\n    ]] = Field(default_factory=list, description=\"Actionable items\")\n    has_actions: bool = Field(..., description=\"Whether response includes actions\")\n    response_type: str = Field(..., description=\"Response type: text or actionable\")\n    chat_id: str = Field(..., description=\"Chat session identifier\")\n    timestamp: datetime = Field(default_factory=datetime.utcnow, description=\"Response timestamp\")\n    tokens_used: Optional[Dict[str, Any]] = Field(None, description=\"Token usage information\")\n    tools_used: List[str] = Field(default_factory=list, description=\"Tools used in generating response\")\n\n\nclass ActionExecutionRequest(BaseModel):\n    \"\"\"Request to execute an AI-suggested action\"\"\"\n    action_id: str = Field(..., description=\"Action identifier\")\n    action_type: str = Field(..., description=\"Type of action to execute\")\n    user_modifications: Optional[Dict[str, Any]] = Field(None, description=\"User modifications to the action\")\n    execute_immediately: bool = Field(default=False, description=\"Execute immediately or save as draft\")\n\n\nclass ActionExecutionResponse(BaseModel):\n    \"\"\"Response from action execution\"\"\"\n    action_id: str = Field(..., description=\"Executed action identifier\")\n    status: str = Field(..., description=\"Execution status: success, error, pending\")\n    result: Optional[Dict[str, Any]] = Field(None, description=\"Execution result\")\n    error: Optional[str] = Field(None, description=\"Error message if failed\")\n    next_steps: List[str] = Field(default_factory=list, description=\"Suggested next steps\")\n    created_items: List[Dict[str, Any]] = Field(default_factory=list, description=\"Items created by this action\")\n\n\n# UI Component Schemas for Frontend\nclass UIButton(BaseModel):\n    \"\"\"UI Button component\"\"\"\n    label: str\n    action: str\n    variant: str = Field(default=\"primary\", description=\"Button variant: primary, secondary, danger\")\n    disabled: bool = Field(default=False)\n    loading: bool = Field(default=False)\n\n\nclass UIPostPreview(BaseModel):\n    \"\"\"UI Post preview component\"\"\"\n    post_data: PostDraft\n    platforms: List[str]\n    actions: List[UIButton] = Field(default_factory=list)\n    editable: bool = Field(default=True)\n\n\nclass UICalendarWidget(BaseModel):\n    \"\"\"UI Calendar widget component\"\"\"\n    calendar_data: Dict[str, Any]\n    view_mode: str = Field(default=\"week\", description=\"View mode: day, week, month\")\n    actions: List[UIButton] = Field(default_factory=list)\n    editable: bool = Field(default=True)\n\n\nclass UIAnalyticsChart(BaseModel):\n    \"\"\"UI Analytics chart component\"\"\"\n    chart_type: str = Field(..., description=\"Chart type: line, bar, pie, etc.\")\n    data: Dict[str, Any] = Field(..., description=\"Chart data\")\n    title: str = Field(..., description=\"Chart title\")\n    description: Optional[str] = Field(None, description=\"Chart description\")\n    actions: List[UIButton] = Field(default_factory=list)\n\n\nclass UIActionCard(BaseModel):\n    \"\"\"UI Action card component\"\"\"\n    action: Union[\n        CreatePostAction,\n        SchedulePostsAction,\n        CreateCalendarAction,\n        AnalyzePerformanceAction,\n        ExportAnalyticsAction,\n        ManageAccountsAction\n    ]\n    ui_component: Union[UIPostPreview, UICalendarWidget, UIAnalyticsChart, Dict[str, Any]]\n    actions: List[UIButton] = Field(default_factory=list)\n    collapsible: bool = Field(default=True)\n    expanded: bool = Field(default=False)","numLines":219,"startLine":1,"totalLines":219}}}
{"parentUuid":"061bea99-e2be-4b8d-a9b7-3e912450f3d6","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_013d1fcE6MBSnZGkKXDrspPj","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"thinking","thinking":"Great! Now I need to read the AI workflows to understand how actions are actually processed. Let me read the AI service and workflow files.","signature":"ErYCCkYICBgCKkBDiCqTH15qWyI8MTGTroBPdUCkn3Ealr+I3m72J+B/HwmVd5aZvYIK6AWdAPky616gwiOJpu7nH/JCeL7XZ9dMEgyODAOG7jDFICpa8HsaDDZCU85c2tYNVBHmKyIwpEHla74SQN5nav1qIJsXGHHELEAY04fgX8rQR8kOTeQzMyzDBkaqgh1WSpFRFdZZKp0BF7iAuPJpdggYwSv7pfSrriPURqe28xZUdQKqL30fqvPv2uUBOh1ez0IIglvfbI4E46UzY58Tw9OasN5Hfe+ByjBxA6Dy/bx6Wr1+T8oYcIPWm/k1Ru02SRx62cvYe46+8FsNRYTnLshFaAKkLK1dCkC4qcYqsfu/GlaI9BNOuBB3FXAqgA8rsLCWY17lB4RPiDNuCxXAERBMJMti+BgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":11827,"cache_read_input_tokens":42120,"cache_creation":{"ephemeral_5m_input_tokens":11827,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CTfE5wE4Za3vw3wNZyrfM","type":"assistant","uuid":"8387658c-60b7-42d8-81c7-bec834ddae52","timestamp":"2025-09-30T20:36:07.935Z"}
{"parentUuid":"8387658c-60b7-42d8-81c7-bec834ddae52","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_013d1fcE6MBSnZGkKXDrspPj","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_01Y9ukNtaEGjMZfhxRheLr9Q","name":"TodoWrite","input":{"todos":[{"content":"Read frontend workflow utilities to understand action nodes and configs","activeForm":"Reading frontend workflow utilities","status":"completed"},{"content":"Read WorkflowManager AI action handlers","activeForm":"Reading WorkflowManager AI action handlers","status":"completed"},{"content":"Read AI_API implementation and schemas","activeForm":"Reading AI_API implementation and schemas","status":"in_progress"},{"content":"Analyze schemas and data flow between all three layers","activeForm":"Analyzing schemas and data flow","status":"pending"},{"content":"Create comprehensive rewritten documentation with visual diagrams","activeForm":"Creating comprehensive documentation","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":11827,"cache_read_input_tokens":42120,"cache_creation":{"ephemeral_5m_input_tokens":11827,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CTfE5wE4Za3vw3wNZyrfM","type":"assistant","uuid":"45d1b6ab-c0be-4080-9015-7da67a38e5e7","timestamp":"2025-09-30T20:36:09.881Z"}
{"parentUuid":"45d1b6ab-c0be-4080-9015-7da67a38e5e7","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_013d1fcE6MBSnZGkKXDrspPj","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_015V1iorqS7gcQN1Uzf5Bi7k","name":"Read","input":{"file_path":"/Users/natedamstra/socialaize/functions/AI_API/src/services/ai_service.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":11827,"cache_read_input_tokens":42120,"cache_creation":{"ephemeral_5m_input_tokens":11827,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CTfE5wE4Za3vw3wNZyrfM","type":"assistant","uuid":"6a26b956-ec85-4f55-9e26-4835c4224161","timestamp":"2025-09-30T20:36:10.901Z"}
{"parentUuid":"6a26b956-ec85-4f55-9e26-4835c4224161","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_013d1fcE6MBSnZGkKXDrspPj","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_01Q1tHVceDs5iJonR6xnGNfN","name":"Read","input":{"file_path":"/Users/natedamstra/socialaize/functions/AI_API/src/workflows/ai_workflow.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":11827,"cache_read_input_tokens":42120,"cache_creation":{"ephemeral_5m_input_tokens":11827,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CTfE5wE4Za3vw3wNZyrfM","type":"assistant","uuid":"a8339948-5cb6-4bc3-9949-8b4fa541b63f","timestamp":"2025-09-30T20:36:11.568Z"}
{"parentUuid":"a8339948-5cb6-4bc3-9949-8b4fa541b63f","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_013d1fcE6MBSnZGkKXDrspPj","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_013gYpf8DWC5emKYDkeXZapJ","name":"Read","input":{"file_path":"/Users/natedamstra/socialaize/functions/AI_API/src/schemas/responses.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":11827,"cache_read_input_tokens":42120,"cache_creation":{"ephemeral_5m_input_tokens":11827,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CTfE5wE4Za3vw3wNZyrfM","type":"assistant","uuid":"6a71f9ee-1547-403b-bf46-59805c1c8908","timestamp":"2025-09-30T20:36:12.660Z"}
{"parentUuid":"6a71f9ee-1547-403b-bf46-59805c1c8908","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y9ukNtaEGjMZfhxRheLr9Q","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"dd297dcb-982d-4b9a-b065-73c1313862af","timestamp":"2025-09-30T20:36:13.016Z","toolUseResult":{"oldTodos":[{"content":"Read frontend workflow utilities to understand action nodes and configs","status":"in_progress","activeForm":"Reading frontend workflow utilities"},{"content":"Read WorkflowManager AI action handlers","status":"pending","activeForm":"Reading WorkflowManager AI action handlers"},{"content":"Read AI_API implementation and schemas","status":"pending","activeForm":"Reading AI_API implementation"},{"content":"Analyze schemas and data flow between all three layers","status":"pending","activeForm":"Analyzing schemas and data flow"},{"content":"Create comprehensive rewritten documentation with visual diagrams","status":"pending","activeForm":"Creating comprehensive documentation"}],"newTodos":[{"content":"Read frontend workflow utilities to understand action nodes and configs","status":"completed","activeForm":"Reading frontend workflow utilities"},{"content":"Read WorkflowManager AI action handlers","status":"completed","activeForm":"Reading WorkflowManager AI action handlers"},{"content":"Read AI_API implementation and schemas","status":"in_progress","activeForm":"Reading AI_API implementation and schemas"},{"content":"Analyze schemas and data flow between all three layers","status":"pending","activeForm":"Analyzing schemas and data flow"},{"content":"Create comprehensive rewritten documentation with visual diagrams","status":"pending","activeForm":"Creating comprehensive documentation"}]}}
{"parentUuid":"dd297dcb-982d-4b9a-b065-73c1313862af","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015V1iorqS7gcQN1Uzf5Bi7k","type":"tool_result","content":"     1→\"\"\"Core AI service for processing chat and action requests\"\"\"\n     2→\n     3→import time\n     4→import uuid\n     5→from datetime import datetime\n     6→from typing import Optional\n     7→\n     8→from llama_index.llms.openai import OpenAI\n     9→from llama_index.core.base.llms.types import ChatMessage as LIMessage\n    10→\n    11→from ..workflows.ai_workflow import AIWorkflow\n    12→from ..workflows.chat_workflow import ChatWorkflow\n    13→from ..workflows.enhanced_chat_workflow import EnhancedChatWorkflow\n    14→from ..services.user_data_service import UserDataService\n    15→from ..services.conversation_cache import ConversationCache\n    16→from ..services.billing_service import BillingService\n    17→from ..services.appwrite_client import AppwriteClientService\n    18→from ..schemas.requests import ChatRequest, ActionRequest\n    19→from ..schemas.responses import ChatResponse, ActionResponse, TokenUsage, ActionResult\n    20→from ..config.billing import (\n    21→    TOKENS_PER_CHARACTER,\n    22→    SYSTEM_PROMPT_OVERHEAD,\n    23→    TOKEN_ESTIMATION_BUFFER,\n    24→    ACTION_TOKEN_MULTIPLIERS,\n    25→    MAX_RESPONSE_PREVIEW_LENGTH\n    26→)\n    27→\n    28→\n    29→class AIService:\n    30→    \"\"\"Main AI service for handling chat and action requests\"\"\"\n    31→    \n    32→    def __init__(self, openai_api_key: str, context, billing_service: Optional[BillingService] = None, appwrite_service: Optional[AppwriteClientService] = None):\n    33→        self.context = context\n    34→        self.billing_service = billing_service\n    35→        self.appwrite_service = appwrite_service\n    36→        \n    37→        # Initialize LLMs\n    38→        self.llm = OpenAI(\n    39→            api_key=openai_api_key,\n    40→            model=\"gpt-5-nano\",\n    41→            temperature=0.7,\n    42→            max_tokens=2000\n    43→        )\n    44→        \n    45→        self.smart_llm = OpenAI(\n    46→            api_key=openai_api_key,\n    47→            model=\"gpt-5-nano\",\n    48→            temperature=0.7,\n    49→            max_tokens=2000\n    50→        )\n    51→        \n    52→        context.log(\"AI Service initialized with OpenAI models\")\n    53→    \n    54→    async def process_chat(\n    55→        self, \n    56→        chat_request: ChatRequest, \n    57→        user_id: str, \n    58→        conversation_cache: ConversationCache\n    59→    ) -> ChatResponse:\n    60→        \"\"\"Process chat conversation with function calling support\"\"\"\n    61→        start_time = time.time()\n    62→        chat_id = chat_request.chat_id or f\"chat_{user_id}_{int(time.time())}\"\n    63→        message_id = f\"msg_{uuid.uuid4().hex[:8]}\"\n    64→        \n    65→        self.context.log(f\"Processing chat for user {user_id}, chat_id: {chat_id}\")\n    66→        \n    67→        # Validate credits before processing if billing service is available\n    68→        if self.billing_service:\n    69→            estimated_tokens = chat_request.max_tokens or 2000\n    70→            validation = await self.billing_service.validate_user_credits(user_id, estimated_tokens)\n    71→            \n    72→            if not validation.valid:\n    73→                self.context.log(f\"Credit validation failed for user {user_id}: {validation.message}\")\n    74→                raise Exception(f\"Credit validation failed: {validation.message}\")\n    75→        \n    76→        try:\n    77→            # Create user data service for accessing team-scoped data\n    78→            user_data_service = None\n    79→            if self.appwrite_service:\n    80→                user_data_service = UserDataService(\n    81→                    appwrite_client=self.appwrite_service,\n    82→                    user_id=user_id,\n    83→                    context=self.context\n    84→                )\n    85→            \n    86→            # Initialize enhanced chat workflow with actionable responses  \n    87→            chat_workflow = ChatWorkflow(\n    88→                llm=self.llm if not chat_request.tools_enabled else self.smart_llm,\n    89→                conversation_cache=conversation_cache,\n    90→                user_data_service=user_data_service,\n    91→                timeout=60.0,\n    92→                verbose=True\n    93→            )\n    94→            \n    95→            # Run chat workflow\n    96→            result = await chat_workflow.run(\n    97→                message=chat_request.message,\n    98→                chat_id=chat_id,\n    99→                user_id=user_id,\n   100→                max_tokens=chat_request.max_tokens,\n   101→                temperature=chat_request.temperature,\n   102→                context=chat_request.context,\n   103→                tools_enabled=chat_request.tools_enabled\n   104→            )\n   105→            \n   106→            # Calculate processing time\n   107→            response_time_ms = int((time.time() - start_time) * 1000)\n   108→            \n   109→            # Extract response data from enhanced workflow\n   110→            response_message = result.get(\"message\", \"\")\n   111→            actions = result.get(\"actions\", [])\n   112→            has_actions = result.get(\"has_actions\", False)\n   113→            response_type = result.get(\"response_type\", \"text\")\n   114→            tokens_used = result.get(\"tokens\", {})\n   115→            tools_used = result.get(\"tools_used\", [])\n   116→            function_calls = result.get(\"function_calls\", [])\n   117→            model_used = result.get(\"model_used\", self.llm.model)\n   118→            \n   119→            self.context.log(f\"Chat completed in {response_time_ms}ms, tokens: {tokens_used}\")\n   120→            \n   121→            # Record credit usage if billing service is available\n   122→            if self.billing_service and tokens_used:\n   123→                token_usage = TokenUsage(**tokens_used) if tokens_used else TokenUsage()\n   124→                \n   125→                # Create metadata for audit trail\n   126→                metadata = {\n   127→                    \"chat_id\": chat_id,\n   128→                    \"message_id\": message_id,\n   129→                    \"tools_enabled\": chat_request.tools_enabled,\n   130→                    \"tools_used\": tools_used,\n   131→                    \"function_calls_count\": len(function_calls),\n   132→                    \"response_time_ms\": response_time_ms\n   133→                }\n   134→                \n   135→                # Record usage (async, don't block response)\n   136→                await self.billing_service.record_credit_usage(\n   137→                    user_id=user_id,\n   138→                    model_used=model_used,\n   139→                    request_type=\"chat\",\n   140→                    token_usage=token_usage,\n   141→                    response_preview=response_message[:MAX_RESPONSE_PREVIEW_LENGTH],\n   142→                    metadata=metadata\n   143→                )\n   144→            \n   145→            return ChatResponse(\n   146→                message=response_message,\n   147→                chat_id=chat_id,\n   148→                message_id=message_id,\n   149→                actions=actions,\n   150→                has_actions=has_actions,\n   151→                response_type=response_type,\n   152→                model_used=model_used,\n   153→                tokens=TokenUsage(**tokens_used) if tokens_used else TokenUsage(),\n   154→                response_time_ms=response_time_ms,\n   155→                tools_used=tools_used,\n   156→                function_calls=function_calls\n   157→            )\n   158→            \n   159→        except Exception as e:\n   160→            self.context.error(f\"Chat processing failed: {str(e)}\")\n   161→            raise Exception(f\"Chat processing failed: {str(e)}\")\n   162→    \n   163→    async def process_action(\n   164→        self, \n   165→        action_request: ActionRequest, \n   166→        user_id: str\n   167→    ) -> ActionResponse:\n   168→        \"\"\"Process AI action requests (rewrite, translate, etc.)\"\"\"\n   169→        start_time = time.time()\n   170→        \n   171→        self.context.log(f\"Processing action '{action_request.action}' for user {user_id}\")\n   172→        \n   173→        # Validate credits before processing if billing service is available\n   174→        if self.billing_service:\n   175→            # Estimate tokens based on action type and content length\n   176→            estimated_tokens = self._estimate_action_tokens(action_request)\n   177→            validation = await self.billing_service.validate_user_credits(user_id, estimated_tokens)\n   178→            \n   179→            if not validation.valid:\n   180→                self.context.log(f\"Credit validation failed for user {user_id}: {validation.message}\")\n   181→                raise Exception(f\"Credit validation failed: {validation.message}\")\n   182→        \n   183→        try:\n   184→            # Select appropriate LLM based on action complexity\n   185→            llm = self._select_llm_for_action(action_request.action)\n   186→            \n   187→            # Initialize AI workflow\n   188→            ai_workflow = AIWorkflow(\n   189→                llm=llm,\n   190→                action_type=action_request.action,\n   191→                timeout=90.0,\n   192→                verbose=True\n   193→            )\n   194→            \n   195→            # Run workflow\n   196→            self.context.log(f\"Running action workflow for {action_request.action}\")\n   197→            result = await ai_workflow.run(\n   198→                request=action_request,\n   199→                user_id=user_id\n   200→            )\n   201→            \n   202→            # Calculate processing time\n   203→            response_time_ms = int((time.time() - start_time) * 1000)\n   204→            \n   205→            # Extract response data\n   206→            processed_content = result.get(\"content\", \"\")\n   207→            processed_title = result.get(\"title\")  # May be None for most actions\n   208→\n   209→            # For title generation action, extract title from content if present\n   210→            if action_request.action == \"ai_gen_title\" and not processed_title:\n   211→                # If the workflow returned title in content, use it as title\n   212→                processed_title = processed_content\n   213→                # Keep original content if provided\n   214→                if hasattr(action_request, 'original_content'):\n   215→                    processed_content = action_request.original_content\n   216→                elif action_request.content:\n   217→                    processed_content = action_request.content\n   218→\n   219→            confidence_score = result.get(\"confidence_score\", 0.8)\n   220→            optimization_attempts = result.get(\"optimization_attempts\", 1)\n   221→            tools_used = result.get(\"tools_used\", [])\n   222→            model_used = result.get(\"model_used\", llm.model)\n   223→            tokens_used = result.get(\"tokens\", {})\n   224→            \n   225→            # Determine optimizations applied\n   226→            optimizations_applied = []\n   227→            if action_request.action == \"ai_translate\":\n   228→                optimizations_applied.append(\"language_translation\")\n   229→            elif action_request.action == \"ai_rewrite\":\n   230→                optimizations_applied.extend([\"tone_adjustment\", \"clarity_improvement\"])\n   231→            elif action_request.action == \"ai_summarize\":\n   232→                optimizations_applied.extend([\"content_summarization\", \"key_point_extraction\"])\n   233→            elif action_request.action in [\"ai_gen_content\", \"ai_gen_title\", \"ai_gen_tags\"]:\n   234→                optimizations_applied.append(\"content_generation\")\n   235→            \n   236→            # Add platform optimization if specified\n   237→            if action_request.platform:\n   238→                optimizations_applied.append(f\"platform_optimization_{action_request.platform}\")\n   239→            \n   240→            # Generate warnings if needed\n   241→            warnings = []\n   242→            if confidence_score < 0.7:\n   243→                warnings.append(\"Low confidence in result quality\")\n   244→            if optimization_attempts > 2:\n   245→                warnings.append(\"Multiple optimization attempts required\")\n   246→            if len(processed_content) > 5000:\n   247→                warnings.append(\"Result may be too long for some platforms\")\n   248→            \n   249→            self.context.log(f\"Action completed in {response_time_ms}ms, confidence: {confidence_score}\")\n   250→            \n   251→            # Record credit usage if billing service is available\n   252→            if self.billing_service and tokens_used:\n   253→                token_usage = TokenUsage(**tokens_used) if tokens_used else TokenUsage()\n   254→                \n   255→                # Create metadata for audit trail\n   256→                metadata = {\n   257→                    \"action\": action_request.action,\n   258→                    \"platform\": action_request.platform,\n   259→                    \"content_length\": len(action_request.content or \"\"),\n   260→                    \"confidence_score\": confidence_score,\n   261→                    \"optimization_attempts\": optimization_attempts,\n   262→                    \"optimizations_applied\": optimizations_applied,\n   263→                    \"response_time_ms\": response_time_ms\n   264→                }\n   265→                \n   266→                # Record usage (async, don't block response)\n   267→                await self.billing_service.record_credit_usage(\n   268→                    user_id=user_id,\n   269→                    model_used=model_used,\n   270→                    request_type=\"action\",\n   271→                    token_usage=token_usage,\n   272→                    response_preview=processed_content[:MAX_RESPONSE_PREVIEW_LENGTH],\n   273→                    metadata=metadata\n   274→                )\n   275→            \n   276→            return ActionResponse(\n   277→                result=ActionResult(\n   278→                    content=processed_content,\n   279→                    title=processed_title\n   280→                ),\n   281→                action=action_request.action,\n   282→                model_used=model_used,\n   283→                tokens=TokenUsage(**tokens_used) if tokens_used else TokenUsage(),\n   284→                response_time_ms=response_time_ms,\n   285→                confidence_score=confidence_score,\n   286→                optimizations_applied=optimizations_applied,\n   287→                warnings=warnings\n   288→            )\n   289→            \n   290→        except Exception as e:\n   291→            self.context.error(f\"Action processing failed: {str(e)}\")\n   292→            raise Exception(f\"Action processing failed: {str(e)}\")\n   293→    \n   294→    def _select_llm_for_action(self, action: str) -> OpenAI:\n   295→        \"\"\"Select appropriate LLM based on action complexity\"\"\"\n   296→        # Use smart model for complex tasks\n   297→        complex_actions = [\"ai_gen_content\", \"ai_rewrite\"]\n   298→        \n   299→        if action in complex_actions:\n   300→            self.context.log(f\"Using smart model for complex action: {action}\")\n   301→            return self.smart_llm\n   302→        else:\n   303→            self.context.log(f\"Using standard model for action: {action}\")\n   304→            return self.llm\n   305→    \n   306→    def _estimate_action_tokens(self, action_request: ActionRequest) -> int:\n   307→        \"\"\"Estimate token usage for action requests\"\"\"\n   308→        content_length = len(action_request.content or \"\")\n   309→        \n   310→        # Base estimation using configuration constants\n   311→        input_tokens = max(100, int(content_length * TOKENS_PER_CHARACTER))\n   312→        \n   313→        # Get multiplier for action type\n   314→        multiplier = ACTION_TOKEN_MULTIPLIERS.get(action_request.action, ACTION_TOKEN_MULTIPLIERS[\"default\"])\n   315→        \n   316→        # Calculate estimated total tokens\n   317→        base_total = input_tokens * multiplier\n   318→        \n   319→        # Add system prompt overhead\n   320→        total_estimated = base_total + SYSTEM_PROMPT_OVERHEAD\n   321→        \n   322→        # Add safety buffer\n   323→        return int(total_estimated * TOKEN_ESTIMATION_BUFFER)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"70b41a3f-7918-41de-b603-7b9b9e29577e","timestamp":"2025-09-30T20:36:13.124Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/natedamstra/socialaize/functions/AI_API/src/services/ai_service.py","content":"\"\"\"Core AI service for processing chat and action requests\"\"\"\n\nimport time\nimport uuid\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom llama_index.llms.openai import OpenAI\nfrom llama_index.core.base.llms.types import ChatMessage as LIMessage\n\nfrom ..workflows.ai_workflow import AIWorkflow\nfrom ..workflows.chat_workflow import ChatWorkflow\nfrom ..workflows.enhanced_chat_workflow import EnhancedChatWorkflow\nfrom ..services.user_data_service import UserDataService\nfrom ..services.conversation_cache import ConversationCache\nfrom ..services.billing_service import BillingService\nfrom ..services.appwrite_client import AppwriteClientService\nfrom ..schemas.requests import ChatRequest, ActionRequest\nfrom ..schemas.responses import ChatResponse, ActionResponse, TokenUsage, ActionResult\nfrom ..config.billing import (\n    TOKENS_PER_CHARACTER,\n    SYSTEM_PROMPT_OVERHEAD,\n    TOKEN_ESTIMATION_BUFFER,\n    ACTION_TOKEN_MULTIPLIERS,\n    MAX_RESPONSE_PREVIEW_LENGTH\n)\n\n\nclass AIService:\n    \"\"\"Main AI service for handling chat and action requests\"\"\"\n    \n    def __init__(self, openai_api_key: str, context, billing_service: Optional[BillingService] = None, appwrite_service: Optional[AppwriteClientService] = None):\n        self.context = context\n        self.billing_service = billing_service\n        self.appwrite_service = appwrite_service\n        \n        # Initialize LLMs\n        self.llm = OpenAI(\n            api_key=openai_api_key,\n            model=\"gpt-5-nano\",\n            temperature=0.7,\n            max_tokens=2000\n        )\n        \n        self.smart_llm = OpenAI(\n            api_key=openai_api_key,\n            model=\"gpt-5-nano\",\n            temperature=0.7,\n            max_tokens=2000\n        )\n        \n        context.log(\"AI Service initialized with OpenAI models\")\n    \n    async def process_chat(\n        self, \n        chat_request: ChatRequest, \n        user_id: str, \n        conversation_cache: ConversationCache\n    ) -> ChatResponse:\n        \"\"\"Process chat conversation with function calling support\"\"\"\n        start_time = time.time()\n        chat_id = chat_request.chat_id or f\"chat_{user_id}_{int(time.time())}\"\n        message_id = f\"msg_{uuid.uuid4().hex[:8]}\"\n        \n        self.context.log(f\"Processing chat for user {user_id}, chat_id: {chat_id}\")\n        \n        # Validate credits before processing if billing service is available\n        if self.billing_service:\n            estimated_tokens = chat_request.max_tokens or 2000\n            validation = await self.billing_service.validate_user_credits(user_id, estimated_tokens)\n            \n            if not validation.valid:\n                self.context.log(f\"Credit validation failed for user {user_id}: {validation.message}\")\n                raise Exception(f\"Credit validation failed: {validation.message}\")\n        \n        try:\n            # Create user data service for accessing team-scoped data\n            user_data_service = None\n            if self.appwrite_service:\n                user_data_service = UserDataService(\n                    appwrite_client=self.appwrite_service,\n                    user_id=user_id,\n                    context=self.context\n                )\n            \n            # Initialize enhanced chat workflow with actionable responses  \n            chat_workflow = ChatWorkflow(\n                llm=self.llm if not chat_request.tools_enabled else self.smart_llm,\n                conversation_cache=conversation_cache,\n                user_data_service=user_data_service,\n                timeout=60.0,\n                verbose=True\n            )\n            \n            # Run chat workflow\n            result = await chat_workflow.run(\n                message=chat_request.message,\n                chat_id=chat_id,\n                user_id=user_id,\n                max_tokens=chat_request.max_tokens,\n                temperature=chat_request.temperature,\n                context=chat_request.context,\n                tools_enabled=chat_request.tools_enabled\n            )\n            \n            # Calculate processing time\n            response_time_ms = int((time.time() - start_time) * 1000)\n            \n            # Extract response data from enhanced workflow\n            response_message = result.get(\"message\", \"\")\n            actions = result.get(\"actions\", [])\n            has_actions = result.get(\"has_actions\", False)\n            response_type = result.get(\"response_type\", \"text\")\n            tokens_used = result.get(\"tokens\", {})\n            tools_used = result.get(\"tools_used\", [])\n            function_calls = result.get(\"function_calls\", [])\n            model_used = result.get(\"model_used\", self.llm.model)\n            \n            self.context.log(f\"Chat completed in {response_time_ms}ms, tokens: {tokens_used}\")\n            \n            # Record credit usage if billing service is available\n            if self.billing_service and tokens_used:\n                token_usage = TokenUsage(**tokens_used) if tokens_used else TokenUsage()\n                \n                # Create metadata for audit trail\n                metadata = {\n                    \"chat_id\": chat_id,\n                    \"message_id\": message_id,\n                    \"tools_enabled\": chat_request.tools_enabled,\n                    \"tools_used\": tools_used,\n                    \"function_calls_count\": len(function_calls),\n                    \"response_time_ms\": response_time_ms\n                }\n                \n                # Record usage (async, don't block response)\n                await self.billing_service.record_credit_usage(\n                    user_id=user_id,\n                    model_used=model_used,\n                    request_type=\"chat\",\n                    token_usage=token_usage,\n                    response_preview=response_message[:MAX_RESPONSE_PREVIEW_LENGTH],\n                    metadata=metadata\n                )\n            \n            return ChatResponse(\n                message=response_message,\n                chat_id=chat_id,\n                message_id=message_id,\n                actions=actions,\n                has_actions=has_actions,\n                response_type=response_type,\n                model_used=model_used,\n                tokens=TokenUsage(**tokens_used) if tokens_used else TokenUsage(),\n                response_time_ms=response_time_ms,\n                tools_used=tools_used,\n                function_calls=function_calls\n            )\n            \n        except Exception as e:\n            self.context.error(f\"Chat processing failed: {str(e)}\")\n            raise Exception(f\"Chat processing failed: {str(e)}\")\n    \n    async def process_action(\n        self, \n        action_request: ActionRequest, \n        user_id: str\n    ) -> ActionResponse:\n        \"\"\"Process AI action requests (rewrite, translate, etc.)\"\"\"\n        start_time = time.time()\n        \n        self.context.log(f\"Processing action '{action_request.action}' for user {user_id}\")\n        \n        # Validate credits before processing if billing service is available\n        if self.billing_service:\n            # Estimate tokens based on action type and content length\n            estimated_tokens = self._estimate_action_tokens(action_request)\n            validation = await self.billing_service.validate_user_credits(user_id, estimated_tokens)\n            \n            if not validation.valid:\n                self.context.log(f\"Credit validation failed for user {user_id}: {validation.message}\")\n                raise Exception(f\"Credit validation failed: {validation.message}\")\n        \n        try:\n            # Select appropriate LLM based on action complexity\n            llm = self._select_llm_for_action(action_request.action)\n            \n            # Initialize AI workflow\n            ai_workflow = AIWorkflow(\n                llm=llm,\n                action_type=action_request.action,\n                timeout=90.0,\n                verbose=True\n            )\n            \n            # Run workflow\n            self.context.log(f\"Running action workflow for {action_request.action}\")\n            result = await ai_workflow.run(\n                request=action_request,\n                user_id=user_id\n            )\n            \n            # Calculate processing time\n            response_time_ms = int((time.time() - start_time) * 1000)\n            \n            # Extract response data\n            processed_content = result.get(\"content\", \"\")\n            processed_title = result.get(\"title\")  # May be None for most actions\n\n            # For title generation action, extract title from content if present\n            if action_request.action == \"ai_gen_title\" and not processed_title:\n                # If the workflow returned title in content, use it as title\n                processed_title = processed_content\n                # Keep original content if provided\n                if hasattr(action_request, 'original_content'):\n                    processed_content = action_request.original_content\n                elif action_request.content:\n                    processed_content = action_request.content\n\n            confidence_score = result.get(\"confidence_score\", 0.8)\n            optimization_attempts = result.get(\"optimization_attempts\", 1)\n            tools_used = result.get(\"tools_used\", [])\n            model_used = result.get(\"model_used\", llm.model)\n            tokens_used = result.get(\"tokens\", {})\n            \n            # Determine optimizations applied\n            optimizations_applied = []\n            if action_request.action == \"ai_translate\":\n                optimizations_applied.append(\"language_translation\")\n            elif action_request.action == \"ai_rewrite\":\n                optimizations_applied.extend([\"tone_adjustment\", \"clarity_improvement\"])\n            elif action_request.action == \"ai_summarize\":\n                optimizations_applied.extend([\"content_summarization\", \"key_point_extraction\"])\n            elif action_request.action in [\"ai_gen_content\", \"ai_gen_title\", \"ai_gen_tags\"]:\n                optimizations_applied.append(\"content_generation\")\n            \n            # Add platform optimization if specified\n            if action_request.platform:\n                optimizations_applied.append(f\"platform_optimization_{action_request.platform}\")\n            \n            # Generate warnings if needed\n            warnings = []\n            if confidence_score < 0.7:\n                warnings.append(\"Low confidence in result quality\")\n            if optimization_attempts > 2:\n                warnings.append(\"Multiple optimization attempts required\")\n            if len(processed_content) > 5000:\n                warnings.append(\"Result may be too long for some platforms\")\n            \n            self.context.log(f\"Action completed in {response_time_ms}ms, confidence: {confidence_score}\")\n            \n            # Record credit usage if billing service is available\n            if self.billing_service and tokens_used:\n                token_usage = TokenUsage(**tokens_used) if tokens_used else TokenUsage()\n                \n                # Create metadata for audit trail\n                metadata = {\n                    \"action\": action_request.action,\n                    \"platform\": action_request.platform,\n                    \"content_length\": len(action_request.content or \"\"),\n                    \"confidence_score\": confidence_score,\n                    \"optimization_attempts\": optimization_attempts,\n                    \"optimizations_applied\": optimizations_applied,\n                    \"response_time_ms\": response_time_ms\n                }\n                \n                # Record usage (async, don't block response)\n                await self.billing_service.record_credit_usage(\n                    user_id=user_id,\n                    model_used=model_used,\n                    request_type=\"action\",\n                    token_usage=token_usage,\n                    response_preview=processed_content[:MAX_RESPONSE_PREVIEW_LENGTH],\n                    metadata=metadata\n                )\n            \n            return ActionResponse(\n                result=ActionResult(\n                    content=processed_content,\n                    title=processed_title\n                ),\n                action=action_request.action,\n                model_used=model_used,\n                tokens=TokenUsage(**tokens_used) if tokens_used else TokenUsage(),\n                response_time_ms=response_time_ms,\n                confidence_score=confidence_score,\n                optimizations_applied=optimizations_applied,\n                warnings=warnings\n            )\n            \n        except Exception as e:\n            self.context.error(f\"Action processing failed: {str(e)}\")\n            raise Exception(f\"Action processing failed: {str(e)}\")\n    \n    def _select_llm_for_action(self, action: str) -> OpenAI:\n        \"\"\"Select appropriate LLM based on action complexity\"\"\"\n        # Use smart model for complex tasks\n        complex_actions = [\"ai_gen_content\", \"ai_rewrite\"]\n        \n        if action in complex_actions:\n            self.context.log(f\"Using smart model for complex action: {action}\")\n            return self.smart_llm\n        else:\n            self.context.log(f\"Using standard model for action: {action}\")\n            return self.llm\n    \n    def _estimate_action_tokens(self, action_request: ActionRequest) -> int:\n        \"\"\"Estimate token usage for action requests\"\"\"\n        content_length = len(action_request.content or \"\")\n        \n        # Base estimation using configuration constants\n        input_tokens = max(100, int(content_length * TOKENS_PER_CHARACTER))\n        \n        # Get multiplier for action type\n        multiplier = ACTION_TOKEN_MULTIPLIERS.get(action_request.action, ACTION_TOKEN_MULTIPLIERS[\"default\"])\n        \n        # Calculate estimated total tokens\n        base_total = input_tokens * multiplier\n        \n        # Add system prompt overhead\n        total_estimated = base_total + SYSTEM_PROMPT_OVERHEAD\n        \n        # Add safety buffer\n        return int(total_estimated * TOKEN_ESTIMATION_BUFFER)","numLines":323,"startLine":1,"totalLines":323}}}
{"parentUuid":"70b41a3f-7918-41de-b603-7b9b9e29577e","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q1tHVceDs5iJonR6xnGNfN","type":"tool_result","content":"     1→\"\"\"Enhanced AI workflow with SmartScraper patterns\"\"\"\n     2→\n     3→import asyncio\n     4→from typing import Any\n     5→from datetime import datetime\n     6→\n     7→from llama_index.core.workflow import (\n     8→    Context,\n     9→    Event,\n    10→    StartEvent,\n    11→    StopEvent,\n    12→    Workflow,\n    13→    step,\n    14→)\n    15→from llama_index.core.tools import BaseTool, FunctionTool\n    16→from llama_index.core.llms import LLM\n    17→from llama_index.core.llms.function_calling import FunctionCallingLLM\n    18→from llama_index.core.base.llms.types import ChatMessage as LIMessage\n    19→from llama_index.llms.openai import OpenAI\n    20→\n    21→from ..schemas.requests import ActionRequest, ChatRequest\n    22→from ..schemas.responses import ActionResponse, ChatResponse, TokenUsage\n    23→\n    24→\n    25→# Enhanced Events with Rich Context\n    26→class ContentAnalysisEvent(Event):\n    27→    \"\"\"Event for content analysis phase\"\"\"\n    28→    content: str\n    29→    action: str\n    30→    parameters: dict[str, Any]\n    31→    analysis_context: dict[str, Any]\n    32→    phase: str\n    33→    user_id: str\n    34→\n    35→\n    36→class ToolExecutionEvent(Event):\n    37→    \"\"\"Event for tool execution phase\"\"\"\n    38→    tool_calls: list[dict[str, Any]]\n    39→    content_context: dict[str, Any]\n    40→    optimization_targets: list[str]\n    41→    user_id: str\n    42→    phase: str\n    43→\n    44→\n    45→class OptimizationEvent(Event):\n    46→    \"\"\"Event for content optimization phase\"\"\"\n    47→    processed_content: str\n    48→    optimization_context: dict[str, Any]\n    49→    confidence_score: float\n    50→    user_id: str\n    51→    phase: str\n    52→\n    53→\n    54→class AIWorkflow(Workflow):\n    55→    \"\"\"Enhanced AI workflow with SmartScraper patterns\"\"\"\n    56→    \n    57→    def __init__(\n    58→        self,\n    59→        llm: FunctionCallingLLM,\n    60→        action_type: str,\n    61→        timeout: float = 120.0,\n    62→        verbose: bool = False\n    63→    ):\n    64→        super().__init__(timeout=timeout, verbose=verbose)\n    65→        self.llm = llm\n    66→        self.action_type = action_type\n    67→        \n    68→        # Workflow state\n    69→        self._optimization_context: dict[str, Any] = {}\n    70→        self._content_analysis: dict[str, Any] = {}\n    71→        self._optimization_attempts: int = 0\n    72→        self._confidence_scores: dict[str, float] = {}\n    73→        self._tools_used: list[str] = []\n    74→        \n    75→        # Register tools\n    76→        self._register_tools()\n    77→    \n    78→    def _register_tools(self) -> None:\n    79→        \"\"\"Register tools for the workflow\"\"\"\n    80→        self.tools = [\n    81→            FunctionTool.from_defaults(\n    82→                fn=self.analyze_content_sentiment,\n    83→                name=\"analyze_sentiment\",\n    84→                description=\"Analyze the sentiment and tone of content\"\n    85→            ),\n    86→            FunctionTool.from_defaults(\n    87→                fn=self.check_content_constraints,\n    88→                name=\"check_constraints\",\n    89→                description=\"Check content against platform constraints and limits\"\n    90→            ),\n    91→            FunctionTool.from_defaults(\n    92→                fn=self.optimize_for_platform,\n    93→                name=\"optimize_platform\",\n    94→                description=\"Optimize content for specific social media platform\"\n    95→            ),\n    96→            FunctionTool.from_defaults(\n    97→                fn=self.validate_output_quality,\n    98→                name=\"validate_quality\",\n    99→                description=\"Validate the quality and appropriateness of generated content\"\n   100→            ),\n   101→            FunctionTool.from_defaults(\n   102→                fn=self.complete_optimization,\n   103→                name=\"complete_optimization\",\n   104→                description=\"Mark the optimization as complete with final result. Pass only the optimized content without any explanations or additional text.\"\n   105→            )\n   106→        ]\n   107→    \n   108→    @step\n   109→    async def start_workflow(self, ctx: Context, ev: StartEvent) -> ContentAnalysisEvent:\n   110→        \"\"\"Initialize workflow with request parameters\"\"\"\n   111→        request = ev.get(\"request\")\n   112→        user_id = ev.get(\"user_id\")\n   113→        \n   114→        # Store initial context\n   115→        await ctx.set(\"request\", request)\n   116→        await ctx.set(\"user_id\", user_id)\n   117→        await ctx.set(\"start_time\", datetime.utcnow())\n   118→        \n   119→        # Reset workflow state\n   120→        self._optimization_attempts = 0\n   121→        self._confidence_scores = {}\n   122→        self._tools_used = []\n   123→        \n   124→        # Initialize analysis context\n   125→        analysis_context = {\n   126→            \"action_type\": self.action_type,\n   127→            \"content_length\": len(request.content),\n   128→            \"parameters\": self._extract_parameters(request),\n   129→            \"platform_constraints\": self._get_platform_constraints(request),\n   130→        }\n   131→        \n   132→        return ContentAnalysisEvent(\n   133→            content=request.content,\n   134→            action=self.action_type,\n   135→            parameters=self._extract_parameters(request),\n   136→            analysis_context=analysis_context,\n   137→            phase=\"initial_analysis\",\n   138→            user_id=user_id\n   139→        )\n   140→    \n   141→    @step\n   142→    async def analyze_content(self, ctx: Context, ev: ContentAnalysisEvent) -> ToolExecutionEvent:\n   143→        \"\"\"Analyze content and determine optimization strategy\"\"\"\n   144→        self._optimization_attempts += 1\n   145→        \n   146→        # Build analysis prompt\n   147→        analysis_prompt = self._build_analysis_prompt(ev)\n   148→        \n   149→        # Get LLM analysis\n   150→        messages = [LIMessage(role=\"user\", content=analysis_prompt)]\n   151→        response = await self.llm.achat_with_tools(tools=self.tools, user_msg=messages[0])\n   152→        \n   153→        # Extract tool calls using proper LlamaIndex method\n   154→        tool_calls = []\n   155→        if hasattr(self.llm, 'get_tool_calls_from_response'):\n   156→            # Use LlamaIndex's native tool call extraction (correct approach)\n   157→            llamaindex_tool_calls = self.llm.get_tool_calls_from_response(\n   158→                response, error_on_no_tool_call=False\n   159→            )\n   160→            if llamaindex_tool_calls:\n   161→                tool_calls = [\n   162→                    {\n   163→                        \"name\": tool_call.tool_name,\n   164→                        \"arguments\": tool_call.tool_kwargs,\n   165→                        \"id\": getattr(tool_call, 'tool_id', f\"call_{i}\")\n   166→                    }\n   167→                    for i, tool_call in enumerate(llamaindex_tool_calls)\n   168→                ]\n   169→        else:\n   170→            # Fallback for LLMs that don't support get_tool_calls_from_response\n   171→            if hasattr(response.message, 'tool_calls') and response.message.tool_calls:\n   172→                tool_calls = [\n   173→                    {\n   174→                        \"name\": getattr(tool_call, 'tool_name', getattr(tool_call, 'name', 'unknown')),\n   175→                        \"arguments\": getattr(tool_call, 'tool_kwargs', getattr(tool_call, 'arguments', {})),\n   176→                        \"id\": getattr(tool_call, 'tool_id', getattr(tool_call, 'id', f\"call_{i}\"))\n   177→                    }\n   178→                    for i, tool_call in enumerate(response.message.tool_calls)\n   179→                ]\n   180→        \n   181→        # Update context\n   182→        content_context = {\n   183→            \"original_content\": ev.content,\n   184→            \"analysis_result\": str(response.message.content),\n   185→            \"action_parameters\": ev.parameters,\n   186→            \"optimization_attempts\": self._optimization_attempts\n   187→        }\n   188→        \n   189→        return ToolExecutionEvent(\n   190→            tool_calls=tool_calls,\n   191→            content_context=content_context,\n   192→            optimization_targets=self._extract_optimization_targets(ev),\n   193→            user_id=ev.user_id,\n   194→            phase=\"tool_execution\"\n   195→        )\n   196→    \n   197→    @step\n   198→    async def execute_tools(self, ctx: Context, ev: ToolExecutionEvent) -> OptimizationEvent | ContentAnalysisEvent | StopEvent:\n   199→        \"\"\"Execute tool calls and process results\"\"\"\n   200→        \n   201→        if not ev.tool_calls:\n   202→            # No tools called, proceed with direct optimization\n   203→            return await self._direct_optimization(ctx, ev)\n   204→        \n   205→        # Execute each tool call\n   206→        tool_results = []\n   207→        for tool_call in ev.tool_calls:\n   208→            try:\n   209→                # Find and execute tool\n   210→                tool = self._find_tool(tool_call[\"name\"])\n   211→                if tool:\n   212→                    result = await self._execute_tool(tool, tool_call[\"arguments\"])\n   213→                    tool_results.append({\n   214→                        \"tool\": tool_call[\"name\"],\n   215→                        \"result\": result,\n   216→                        \"success\": True\n   217→                    })\n   218→                    self._tools_used.append(tool_call[\"name\"])\n   219→                else:\n   220→                    tool_results.append({\n   221→                        \"tool\": tool_call[\"name\"],\n   222→                        \"result\": f\"Tool {tool_call['name']} not found\",\n   223→                        \"success\": False\n   224→                    })\n   225→            except Exception as e:\n   226→                tool_results.append({\n   227→                    \"tool\": tool_call[\"name\"],\n   228→                    \"result\": f\"Tool execution error: {str(e)}\",\n   229→                    \"success\": False\n   230→                })\n   231→        \n   232→        # Check for completion signal\n   233→        completion_results = [r for r in tool_results if r[\"tool\"] == \"complete_optimization\" and r[\"success\"]]\n   234→        if completion_results:\n   235→            result_data = completion_results[0][\"result\"]\n   236→            if isinstance(result_data, dict) and result_data.get(\"success\", False):\n   237→                # Ensure we only return the clean content in the final result\n   238→                return StopEvent(result={\n   239→                    \"content\": result_data.get(\"final_content\", \"\"),\n   240→                    \"confidence_score\": result_data.get(\"confidence\", 0.8),\n   241→                    \"optimization_attempts\": self._optimization_attempts,\n   242→                    \"tools_used\": self._tools_used,\n   243→                    \"success\": True\n   244→                })\n   245→        \n   246→        # Check for loop prevention (max attempts)\n   247→        if self._optimization_attempts >= 3:\n   248→            return await self._force_completion(ctx, ev)\n   249→        \n   250→        # Continue optimization with tool results\n   251→        optimization_context = {\n   252→            \"tool_results\": tool_results,\n   253→            \"content_context\": ev.content_context,\n   254→            \"optimization_targets\": ev.optimization_targets\n   255→        }\n   256→        \n   257→        return OptimizationEvent(\n   258→            processed_content=ev.content_context.get(\"original_content\", \"\"),\n   259→            optimization_context=optimization_context,\n   260→            confidence_score=self._calculate_confidence(tool_results),\n   261→            user_id=ev.user_id,\n   262→            phase=\"optimization\"\n   263→        )\n   264→    \n   265→    @step\n   266→    async def optimize_content(self, ctx: Context, ev: OptimizationEvent) -> ContentAnalysisEvent | StopEvent:\n   267→        \"\"\"Optimize content based on analysis and tool results\"\"\"\n   268→        \n   269→        # Build optimization prompt\n   270→        optimization_prompt = self._build_optimization_prompt(ev)\n   271→        \n   272→        # Get LLM optimization\n   273→        messages = [LIMessage(role=\"user\", content=optimization_prompt)]\n   274→        response = await self.llm.achat(messages)\n   275→        \n   276→        optimized_content = str(response.message.content)\n   277→        \n   278→        # Validate optimization quality\n   279→        quality_score = self._assess_quality(optimized_content, ev)\n   280→        \n   281→        if quality_score >= 0.8 or self._optimization_attempts >= 3:\n   282→            # Good enough quality or max attempts reached\n   283→            return StopEvent(result={\n   284→                \"content\": optimized_content,\n   285→                \"confidence_score\": quality_score,\n   286→                \"optimization_attempts\": self._optimization_attempts,\n   287→                \"tools_used\": self._tools_used,\n   288→                \"success\": True\n   289→            })\n   290→        else:\n   291→            # Need more optimization\n   292→            return ContentAnalysisEvent(\n   293→                content=optimized_content,\n   294→                action=self.action_type,\n   295→                parameters=ev.optimization_context.get(\"content_context\", {}).get(\"action_parameters\", {}),\n   296→                analysis_context={\"previous_optimization\": ev.optimization_context},\n   297→                phase=\"re_optimization\",\n   298→                user_id=ev.user_id\n   299→            )\n   300→    \n   301→    # Tool implementations\n   302→    def analyze_content_sentiment(self, content: str) -> dict[str, Any]:\n   303→        \"\"\"Analyze content sentiment and tone\"\"\"\n   304→        # Simple sentiment analysis - could be enhanced\n   305→        positive_words = [\"good\", \"great\", \"amazing\", \"excellent\", \"love\", \"best\"]\n   306→        negative_words = [\"bad\", \"terrible\", \"hate\", \"worst\", \"awful\", \"horrible\"]\n   307→        \n   308→        content_lower = content.lower()\n   309→        positive_count = sum(1 for word in positive_words if word in content_lower)\n   310→        negative_count = sum(1 for word in negative_words if word in content_lower)\n   311→        \n   312→        if positive_count > negative_count:\n   313→            sentiment = \"positive\"\n   314→        elif negative_count > positive_count:\n   315→            sentiment = \"negative\"\n   316→        else:\n   317→            sentiment = \"neutral\"\n   318→        \n   319→        return {\n   320→            \"sentiment\": sentiment,\n   321→            \"confidence\": min(abs(positive_count - negative_count) / len(content.split()) * 10, 1.0),\n   322→            \"tone\": \"professional\" if sentiment == \"neutral\" else sentiment\n   323→        }\n   324→    \n   325→    def check_content_constraints(self, content: str, platform: str = None) -> dict[str, Any]:\n   326→        \"\"\"Check content against platform constraints\"\"\"\n   327→        constraints = {\n   328→            \"character_count\": len(content),\n   329→            \"word_count\": len(content.split()),\n   330→            \"has_hashtags\": \"#\" in content,\n   331→            \"has_mentions\": \"@\" in content,\n   332→            \"has_urls\": \"http\" in content or \"www.\" in content\n   333→        }\n   334→        \n   335→        # Platform-specific limits\n   336→        platform_limits = {\n   337→            \"twitter\": 280,\n   338→            \"instagram\": 2200,\n   339→            \"facebook\": 63206,\n   340→            \"linkedin\": 3000\n   341→        }\n   342→        \n   343→        if platform and platform.lower() in platform_limits:\n   344→            limit = platform_limits[platform.lower()]\n   345→            constraints[\"within_limit\"] = len(content) <= limit\n   346→            constraints[\"platform_limit\"] = limit\n   347→        \n   348→        return constraints\n   349→    \n   350→    def optimize_for_platform(self, content: str, platform: str = None) -> dict[str, Any]:\n   351→        \"\"\"Optimize content for specific platform\"\"\"\n   352→        optimizations = []\n   353→        \n   354→        if platform:\n   355→            platform = platform.lower()\n   356→            \n   357→            if platform == \"twitter\" and len(content) > 280:\n   358→                optimizations.append(\"content_too_long\")\n   359→            elif platform == \"instagram\" and \"#\" not in content:\n   360→                optimizations.append(\"add_hashtags\")\n   361→            elif platform == \"linkedin\" and not content[0].isupper():\n   362→                optimizations.append(\"capitalize_first_letter\")\n   363→        \n   364→        return {\n   365→            \"platform\": platform,\n   366→            \"optimizations_needed\": optimizations,\n   367→            \"current_length\": len(content),\n   368→            \"optimization_suggestions\": self._get_platform_suggestions(platform)\n   369→        }\n   370→    \n   371→    def validate_output_quality(self, content: str) -> dict[str, Any]:\n   372→        \"\"\"Validate output quality\"\"\"\n   373→        quality_checks = {\n   374→            \"has_content\": len(content.strip()) > 0,\n   375→            \"reasonable_length\": 10 <= len(content) <= 5000,\n   376→            \"proper_grammar\": not content.startswith((\" \", \"\\n\", \"\\t\")),\n   377→            \"no_repetition\": len(set(content.split())) / len(content.split()) > 0.5 if content.split() else False\n   378→        }\n   379→        \n   380→        quality_score = sum(quality_checks.values()) / len(quality_checks)\n   381→        \n   382→        return {\n   383→            \"quality_score\": quality_score,\n   384→            \"checks\": quality_checks,\n   385→            \"approved\": quality_score >= 0.75\n   386→        }\n   387→    \n   388→    def complete_optimization(self, content: str, confidence: float = 0.8) -> dict[str, Any]:\n   389→        \"\"\"Mark optimization as complete\"\"\"\n   390→        # Ensure content is clean and contains only the optimized text\n   391→        clean_content = content.strip()\n   392→        \n   393→        return {\n   394→            \"success\": True,\n   395→            \"final_content\": clean_content,\n   396→            \"confidence\": confidence,\n   397→            \"completion_reason\": \"optimization_complete\"\n   398→        }\n   399→    \n   400→    # Helper methods\n   401→    def _extract_parameters(self, request: ActionRequest | ChatRequest) -> dict[str, Any]:\n   402→        \"\"\"Extract parameters from request\"\"\"\n   403→        if isinstance(request, ActionRequest):\n   404→            return {\n   405→                \"target_language\": getattr(request, 'target_language', None),\n   406→                \"tone\": getattr(request, 'tone', None),\n   407→                \"length\": getattr(request, 'length', None),\n   408→                \"platform\": getattr(request, 'platform', None),\n   409→                \"style\": getattr(request, 'style', None),\n   410→            }\n   411→        return {}\n   412→    \n   413→    def _get_platform_constraints(self, request: ActionRequest | ChatRequest) -> dict[str, Any]:\n   414→        \"\"\"Get platform-specific constraints\"\"\"\n   415→        platform = getattr(request, 'platform', None)\n   416→        if not platform:\n   417→            return {}\n   418→        \n   419→        constraints = {\n   420→            \"twitter\": {\"max_length\": 280, \"hashtag_limit\": 2},\n   421→            \"instagram\": {\"max_length\": 2200, \"hashtag_limit\": 30},\n   422→            \"facebook\": {\"max_length\": 63206, \"hashtag_limit\": 5},\n   423→            \"linkedin\": {\"max_length\": 3000, \"hashtag_limit\": 5}\n   424→        }\n   425→        \n   426→        return constraints.get(platform.lower(), {})\n   427→    \n   428→    def _build_analysis_prompt(self, ev: ContentAnalysisEvent) -> str:\n   429→        \"\"\"Build analysis prompt for LLM\"\"\"\n   430→        return f\"\"\"\n   431→Analyze the following content for {ev.action} optimization:\n   432→\n   433→Content: \"{ev.content}\"\n   434→\n   435→Action: {ev.action}\n   436→Parameters: {ev.parameters}\n   437→Platform constraints: {ev.analysis_context.get('platform_constraints', {})}\n   438→\n   439→Please analyze this content and determine the best optimization strategy. \n   440→Use the available tools to check sentiment, constraints, and platform requirements.\n   441→\n   442→CRITICAL: If you can complete the optimization directly, use the complete_optimization tool with ONLY the final optimized content. Do NOT include any explanations or additional text in the final result.\n   443→\n   444→The end result must be ONLY the optimized content with no commentary, explanations, or additional text.\n   445→\"\"\"\n   446→    \n   447→    def _build_optimization_prompt(self, ev: OptimizationEvent) -> str:\n   448→        \"\"\"Build optimization prompt for LLM\"\"\"\n   449→        return f\"\"\"\n   450→Optimize the following content based on the analysis results:\n   451→\n   452→Original Content: \"{ev.processed_content}\"\n   453→\n   454→Tool Results: {ev.optimization_context.get('tool_results', [])}\n   455→Optimization Targets: {ev.optimization_context.get('optimization_targets', [])}\n   456→Current Confidence: {ev.confidence_score}\n   457→\n   458→CRITICAL INSTRUCTIONS:\n   459→- Your response WILL be the social media posts content, therefore:\n   460→- Your response must ONLY contain the final optimized content\n   461→- Do NOT include any explanations, suggestions, or additional text\n   462→- Do NOT include phrases like \"Here's the optimized version:\" or \"Consider this revision:\"\n   463→- Do NOT include any commentary or analysis\n   464→- Return ONLY the optimized content itself\n   465→- If you cannot optimize further, return the original content exactly as provided\n   466→\n   467→Your entire response should be the optimized content and nothing else.\n   468→\"\"\"\n   469→    \n   470→    def _extract_optimization_targets(self, ev: ContentAnalysisEvent) -> list[str]:\n   471→        \"\"\"Extract optimization targets from event\"\"\"\n   472→        targets = []\n   473→        \n   474→        if ev.action == \"ai_translate\":\n   475→            targets.append(\"language_accuracy\")\n   476→        elif ev.action == \"ai_rewrite\":\n   477→            targets.extend([\"tone_adjustment\", \"clarity\", \"engagement\"])\n   478→        elif ev.action == \"ai_summarize\":\n   479→            targets.extend([\"brevity\", \"key_points\", \"coherence\"])\n   480→        \n   481→        return targets\n   482→    \n   483→    def _find_tool(self, tool_name: str) -> BaseTool | None:\n   484→        \"\"\"Find tool by name\"\"\"\n   485→        for tool in self.tools:\n   486→            if tool.metadata.name == tool_name:\n   487→                return tool\n   488→        return None\n   489→    \n   490→    async def _execute_tool(self, tool: BaseTool, arguments: dict[str, Any]) -> Any:\n   491→        \"\"\"Execute a tool with arguments\"\"\"\n   492→        try:\n   493→            if hasattr(tool, 'acall'):\n   494→                return await tool.acall(**arguments)\n   495→            else:\n   496→                return tool.call(**arguments)\n   497→        except Exception as e:\n   498→            return {\"error\": str(e), \"success\": False}\n   499→    \n   500→    def _calculate_confidence(self, tool_results: list[dict[str, Any]]) -> float:\n   501→        \"\"\"Calculate confidence score from tool results\"\"\"\n   502→        if not tool_results:\n   503→            return 0.5\n   504→        \n   505→        successful_results = [r for r in tool_results if r[\"success\"]]\n   506→        return len(successful_results) / len(tool_results)\n   507→    \n   508→    def _assess_quality(self, content: str, ev: OptimizationEvent) -> float:\n   509→        \"\"\"Assess quality of optimized content\"\"\"\n   510→        # Simple quality assessment\n   511→        if not content or len(content.strip()) < 5:\n   512→            return 0.0\n   513→        \n   514→        # Check if content has improved\n   515→        original_length = len(ev.processed_content)\n   516→        new_length = len(content)\n   517→        \n   518→        # Basic quality metrics\n   519→        quality_score = 0.5  # Base score\n   520→        \n   521→        if 0.5 <= new_length / original_length <= 2.0:  # Reasonable length change\n   522→            quality_score += 0.2\n   523→        \n   524→        if content != ev.processed_content:  # Content was actually modified\n   525→            quality_score += 0.2\n   526→        \n   527→        return min(quality_score + ev.confidence_score * 0.1, 1.0)\n   528→    \n   529→    def _get_platform_suggestions(self, platform: str) -> list[str]:\n   530→        \"\"\"Get platform-specific optimization suggestions\"\"\"\n   531→        suggestions = {\n   532→            \"twitter\": [\"Keep it under 280 characters\", \"Use hashtags sparingly\", \"Make it engaging\"],\n   533→            \"instagram\": [\"Add relevant hashtags\", \"Use visual language\", \"Include call-to-action\"],\n   534→            \"facebook\": [\"Write conversational tone\", \"Ask questions\", \"Keep paragraphs short\"],\n   535→            \"linkedin\": [\"Professional tone\", \"Include industry keywords\", \"Add value\"]\n   536→        }\n   537→        \n   538→        return suggestions.get(platform, [\"Clear and engaging\", \"Appropriate length\", \"Good grammar\"])\n   539→    \n   540→    async def _direct_optimization(self, ctx: Context, ev: ToolExecutionEvent) -> OptimizationEvent:\n   541→        \"\"\"Handle direct optimization without tool calls\"\"\"\n   542→        return OptimizationEvent(\n   543→            processed_content=ev.content_context.get(\"original_content\", \"\"),\n   544→            optimization_context={\"direct_optimization\": True},\n   545→            confidence_score=0.7,\n   546→            user_id=ev.user_id,\n   547→            phase=\"direct_optimization\"\n   548→        )\n   549→    \n   550→    async def _force_completion(self, ctx: Context, ev: ToolExecutionEvent) -> StopEvent:\n   551→        \"\"\"Force completion when max attempts reached\"\"\"\n   552→        content = ev.content_context.get(\"original_content\", \"\")\n   553→        return StopEvent(result={\n   554→            \"content\": content,\n   555→            \"confidence_score\": 0.6,\n   556→            \"optimization_attempts\": self._optimization_attempts,\n   557→            \"tools_used\": self._tools_used,\n   558→            \"success\": True,\n   559→            \"completion_reason\": \"max_attempts_reached\"\n   560→        })\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"ee81523f-8260-45d6-9e8e-595ba0d9e0cf","timestamp":"2025-09-30T20:36:13.125Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/natedamstra/socialaize/functions/AI_API/src/workflows/ai_workflow.py","content":"\"\"\"Enhanced AI workflow with SmartScraper patterns\"\"\"\n\nimport asyncio\nfrom typing import Any\nfrom datetime import datetime\n\nfrom llama_index.core.workflow import (\n    Context,\n    Event,\n    StartEvent,\n    StopEvent,\n    Workflow,\n    step,\n)\nfrom llama_index.core.tools import BaseTool, FunctionTool\nfrom llama_index.core.llms import LLM\nfrom llama_index.core.llms.function_calling import FunctionCallingLLM\nfrom llama_index.core.base.llms.types import ChatMessage as LIMessage\nfrom llama_index.llms.openai import OpenAI\n\nfrom ..schemas.requests import ActionRequest, ChatRequest\nfrom ..schemas.responses import ActionResponse, ChatResponse, TokenUsage\n\n\n# Enhanced Events with Rich Context\nclass ContentAnalysisEvent(Event):\n    \"\"\"Event for content analysis phase\"\"\"\n    content: str\n    action: str\n    parameters: dict[str, Any]\n    analysis_context: dict[str, Any]\n    phase: str\n    user_id: str\n\n\nclass ToolExecutionEvent(Event):\n    \"\"\"Event for tool execution phase\"\"\"\n    tool_calls: list[dict[str, Any]]\n    content_context: dict[str, Any]\n    optimization_targets: list[str]\n    user_id: str\n    phase: str\n\n\nclass OptimizationEvent(Event):\n    \"\"\"Event for content optimization phase\"\"\"\n    processed_content: str\n    optimization_context: dict[str, Any]\n    confidence_score: float\n    user_id: str\n    phase: str\n\n\nclass AIWorkflow(Workflow):\n    \"\"\"Enhanced AI workflow with SmartScraper patterns\"\"\"\n    \n    def __init__(\n        self,\n        llm: FunctionCallingLLM,\n        action_type: str,\n        timeout: float = 120.0,\n        verbose: bool = False\n    ):\n        super().__init__(timeout=timeout, verbose=verbose)\n        self.llm = llm\n        self.action_type = action_type\n        \n        # Workflow state\n        self._optimization_context: dict[str, Any] = {}\n        self._content_analysis: dict[str, Any] = {}\n        self._optimization_attempts: int = 0\n        self._confidence_scores: dict[str, float] = {}\n        self._tools_used: list[str] = []\n        \n        # Register tools\n        self._register_tools()\n    \n    def _register_tools(self) -> None:\n        \"\"\"Register tools for the workflow\"\"\"\n        self.tools = [\n            FunctionTool.from_defaults(\n                fn=self.analyze_content_sentiment,\n                name=\"analyze_sentiment\",\n                description=\"Analyze the sentiment and tone of content\"\n            ),\n            FunctionTool.from_defaults(\n                fn=self.check_content_constraints,\n                name=\"check_constraints\",\n                description=\"Check content against platform constraints and limits\"\n            ),\n            FunctionTool.from_defaults(\n                fn=self.optimize_for_platform,\n                name=\"optimize_platform\",\n                description=\"Optimize content for specific social media platform\"\n            ),\n            FunctionTool.from_defaults(\n                fn=self.validate_output_quality,\n                name=\"validate_quality\",\n                description=\"Validate the quality and appropriateness of generated content\"\n            ),\n            FunctionTool.from_defaults(\n                fn=self.complete_optimization,\n                name=\"complete_optimization\",\n                description=\"Mark the optimization as complete with final result. Pass only the optimized content without any explanations or additional text.\"\n            )\n        ]\n    \n    @step\n    async def start_workflow(self, ctx: Context, ev: StartEvent) -> ContentAnalysisEvent:\n        \"\"\"Initialize workflow with request parameters\"\"\"\n        request = ev.get(\"request\")\n        user_id = ev.get(\"user_id\")\n        \n        # Store initial context\n        await ctx.set(\"request\", request)\n        await ctx.set(\"user_id\", user_id)\n        await ctx.set(\"start_time\", datetime.utcnow())\n        \n        # Reset workflow state\n        self._optimization_attempts = 0\n        self._confidence_scores = {}\n        self._tools_used = []\n        \n        # Initialize analysis context\n        analysis_context = {\n            \"action_type\": self.action_type,\n            \"content_length\": len(request.content),\n            \"parameters\": self._extract_parameters(request),\n            \"platform_constraints\": self._get_platform_constraints(request),\n        }\n        \n        return ContentAnalysisEvent(\n            content=request.content,\n            action=self.action_type,\n            parameters=self._extract_parameters(request),\n            analysis_context=analysis_context,\n            phase=\"initial_analysis\",\n            user_id=user_id\n        )\n    \n    @step\n    async def analyze_content(self, ctx: Context, ev: ContentAnalysisEvent) -> ToolExecutionEvent:\n        \"\"\"Analyze content and determine optimization strategy\"\"\"\n        self._optimization_attempts += 1\n        \n        # Build analysis prompt\n        analysis_prompt = self._build_analysis_prompt(ev)\n        \n        # Get LLM analysis\n        messages = [LIMessage(role=\"user\", content=analysis_prompt)]\n        response = await self.llm.achat_with_tools(tools=self.tools, user_msg=messages[0])\n        \n        # Extract tool calls using proper LlamaIndex method\n        tool_calls = []\n        if hasattr(self.llm, 'get_tool_calls_from_response'):\n            # Use LlamaIndex's native tool call extraction (correct approach)\n            llamaindex_tool_calls = self.llm.get_tool_calls_from_response(\n                response, error_on_no_tool_call=False\n            )\n            if llamaindex_tool_calls:\n                tool_calls = [\n                    {\n                        \"name\": tool_call.tool_name,\n                        \"arguments\": tool_call.tool_kwargs,\n                        \"id\": getattr(tool_call, 'tool_id', f\"call_{i}\")\n                    }\n                    for i, tool_call in enumerate(llamaindex_tool_calls)\n                ]\n        else:\n            # Fallback for LLMs that don't support get_tool_calls_from_response\n            if hasattr(response.message, 'tool_calls') and response.message.tool_calls:\n                tool_calls = [\n                    {\n                        \"name\": getattr(tool_call, 'tool_name', getattr(tool_call, 'name', 'unknown')),\n                        \"arguments\": getattr(tool_call, 'tool_kwargs', getattr(tool_call, 'arguments', {})),\n                        \"id\": getattr(tool_call, 'tool_id', getattr(tool_call, 'id', f\"call_{i}\"))\n                    }\n                    for i, tool_call in enumerate(response.message.tool_calls)\n                ]\n        \n        # Update context\n        content_context = {\n            \"original_content\": ev.content,\n            \"analysis_result\": str(response.message.content),\n            \"action_parameters\": ev.parameters,\n            \"optimization_attempts\": self._optimization_attempts\n        }\n        \n        return ToolExecutionEvent(\n            tool_calls=tool_calls,\n            content_context=content_context,\n            optimization_targets=self._extract_optimization_targets(ev),\n            user_id=ev.user_id,\n            phase=\"tool_execution\"\n        )\n    \n    @step\n    async def execute_tools(self, ctx: Context, ev: ToolExecutionEvent) -> OptimizationEvent | ContentAnalysisEvent | StopEvent:\n        \"\"\"Execute tool calls and process results\"\"\"\n        \n        if not ev.tool_calls:\n            # No tools called, proceed with direct optimization\n            return await self._direct_optimization(ctx, ev)\n        \n        # Execute each tool call\n        tool_results = []\n        for tool_call in ev.tool_calls:\n            try:\n                # Find and execute tool\n                tool = self._find_tool(tool_call[\"name\"])\n                if tool:\n                    result = await self._execute_tool(tool, tool_call[\"arguments\"])\n                    tool_results.append({\n                        \"tool\": tool_call[\"name\"],\n                        \"result\": result,\n                        \"success\": True\n                    })\n                    self._tools_used.append(tool_call[\"name\"])\n                else:\n                    tool_results.append({\n                        \"tool\": tool_call[\"name\"],\n                        \"result\": f\"Tool {tool_call['name']} not found\",\n                        \"success\": False\n                    })\n            except Exception as e:\n                tool_results.append({\n                    \"tool\": tool_call[\"name\"],\n                    \"result\": f\"Tool execution error: {str(e)}\",\n                    \"success\": False\n                })\n        \n        # Check for completion signal\n        completion_results = [r for r in tool_results if r[\"tool\"] == \"complete_optimization\" and r[\"success\"]]\n        if completion_results:\n            result_data = completion_results[0][\"result\"]\n            if isinstance(result_data, dict) and result_data.get(\"success\", False):\n                # Ensure we only return the clean content in the final result\n                return StopEvent(result={\n                    \"content\": result_data.get(\"final_content\", \"\"),\n                    \"confidence_score\": result_data.get(\"confidence\", 0.8),\n                    \"optimization_attempts\": self._optimization_attempts,\n                    \"tools_used\": self._tools_used,\n                    \"success\": True\n                })\n        \n        # Check for loop prevention (max attempts)\n        if self._optimization_attempts >= 3:\n            return await self._force_completion(ctx, ev)\n        \n        # Continue optimization with tool results\n        optimization_context = {\n            \"tool_results\": tool_results,\n            \"content_context\": ev.content_context,\n            \"optimization_targets\": ev.optimization_targets\n        }\n        \n        return OptimizationEvent(\n            processed_content=ev.content_context.get(\"original_content\", \"\"),\n            optimization_context=optimization_context,\n            confidence_score=self._calculate_confidence(tool_results),\n            user_id=ev.user_id,\n            phase=\"optimization\"\n        )\n    \n    @step\n    async def optimize_content(self, ctx: Context, ev: OptimizationEvent) -> ContentAnalysisEvent | StopEvent:\n        \"\"\"Optimize content based on analysis and tool results\"\"\"\n        \n        # Build optimization prompt\n        optimization_prompt = self._build_optimization_prompt(ev)\n        \n        # Get LLM optimization\n        messages = [LIMessage(role=\"user\", content=optimization_prompt)]\n        response = await self.llm.achat(messages)\n        \n        optimized_content = str(response.message.content)\n        \n        # Validate optimization quality\n        quality_score = self._assess_quality(optimized_content, ev)\n        \n        if quality_score >= 0.8 or self._optimization_attempts >= 3:\n            # Good enough quality or max attempts reached\n            return StopEvent(result={\n                \"content\": optimized_content,\n                \"confidence_score\": quality_score,\n                \"optimization_attempts\": self._optimization_attempts,\n                \"tools_used\": self._tools_used,\n                \"success\": True\n            })\n        else:\n            # Need more optimization\n            return ContentAnalysisEvent(\n                content=optimized_content,\n                action=self.action_type,\n                parameters=ev.optimization_context.get(\"content_context\", {}).get(\"action_parameters\", {}),\n                analysis_context={\"previous_optimization\": ev.optimization_context},\n                phase=\"re_optimization\",\n                user_id=ev.user_id\n            )\n    \n    # Tool implementations\n    def analyze_content_sentiment(self, content: str) -> dict[str, Any]:\n        \"\"\"Analyze content sentiment and tone\"\"\"\n        # Simple sentiment analysis - could be enhanced\n        positive_words = [\"good\", \"great\", \"amazing\", \"excellent\", \"love\", \"best\"]\n        negative_words = [\"bad\", \"terrible\", \"hate\", \"worst\", \"awful\", \"horrible\"]\n        \n        content_lower = content.lower()\n        positive_count = sum(1 for word in positive_words if word in content_lower)\n        negative_count = sum(1 for word in negative_words if word in content_lower)\n        \n        if positive_count > negative_count:\n            sentiment = \"positive\"\n        elif negative_count > positive_count:\n            sentiment = \"negative\"\n        else:\n            sentiment = \"neutral\"\n        \n        return {\n            \"sentiment\": sentiment,\n            \"confidence\": min(abs(positive_count - negative_count) / len(content.split()) * 10, 1.0),\n            \"tone\": \"professional\" if sentiment == \"neutral\" else sentiment\n        }\n    \n    def check_content_constraints(self, content: str, platform: str = None) -> dict[str, Any]:\n        \"\"\"Check content against platform constraints\"\"\"\n        constraints = {\n            \"character_count\": len(content),\n            \"word_count\": len(content.split()),\n            \"has_hashtags\": \"#\" in content,\n            \"has_mentions\": \"@\" in content,\n            \"has_urls\": \"http\" in content or \"www.\" in content\n        }\n        \n        # Platform-specific limits\n        platform_limits = {\n            \"twitter\": 280,\n            \"instagram\": 2200,\n            \"facebook\": 63206,\n            \"linkedin\": 3000\n        }\n        \n        if platform and platform.lower() in platform_limits:\n            limit = platform_limits[platform.lower()]\n            constraints[\"within_limit\"] = len(content) <= limit\n            constraints[\"platform_limit\"] = limit\n        \n        return constraints\n    \n    def optimize_for_platform(self, content: str, platform: str = None) -> dict[str, Any]:\n        \"\"\"Optimize content for specific platform\"\"\"\n        optimizations = []\n        \n        if platform:\n            platform = platform.lower()\n            \n            if platform == \"twitter\" and len(content) > 280:\n                optimizations.append(\"content_too_long\")\n            elif platform == \"instagram\" and \"#\" not in content:\n                optimizations.append(\"add_hashtags\")\n            elif platform == \"linkedin\" and not content[0].isupper():\n                optimizations.append(\"capitalize_first_letter\")\n        \n        return {\n            \"platform\": platform,\n            \"optimizations_needed\": optimizations,\n            \"current_length\": len(content),\n            \"optimization_suggestions\": self._get_platform_suggestions(platform)\n        }\n    \n    def validate_output_quality(self, content: str) -> dict[str, Any]:\n        \"\"\"Validate output quality\"\"\"\n        quality_checks = {\n            \"has_content\": len(content.strip()) > 0,\n            \"reasonable_length\": 10 <= len(content) <= 5000,\n            \"proper_grammar\": not content.startswith((\" \", \"\\n\", \"\\t\")),\n            \"no_repetition\": len(set(content.split())) / len(content.split()) > 0.5 if content.split() else False\n        }\n        \n        quality_score = sum(quality_checks.values()) / len(quality_checks)\n        \n        return {\n            \"quality_score\": quality_score,\n            \"checks\": quality_checks,\n            \"approved\": quality_score >= 0.75\n        }\n    \n    def complete_optimization(self, content: str, confidence: float = 0.8) -> dict[str, Any]:\n        \"\"\"Mark optimization as complete\"\"\"\n        # Ensure content is clean and contains only the optimized text\n        clean_content = content.strip()\n        \n        return {\n            \"success\": True,\n            \"final_content\": clean_content,\n            \"confidence\": confidence,\n            \"completion_reason\": \"optimization_complete\"\n        }\n    \n    # Helper methods\n    def _extract_parameters(self, request: ActionRequest | ChatRequest) -> dict[str, Any]:\n        \"\"\"Extract parameters from request\"\"\"\n        if isinstance(request, ActionRequest):\n            return {\n                \"target_language\": getattr(request, 'target_language', None),\n                \"tone\": getattr(request, 'tone', None),\n                \"length\": getattr(request, 'length', None),\n                \"platform\": getattr(request, 'platform', None),\n                \"style\": getattr(request, 'style', None),\n            }\n        return {}\n    \n    def _get_platform_constraints(self, request: ActionRequest | ChatRequest) -> dict[str, Any]:\n        \"\"\"Get platform-specific constraints\"\"\"\n        platform = getattr(request, 'platform', None)\n        if not platform:\n            return {}\n        \n        constraints = {\n            \"twitter\": {\"max_length\": 280, \"hashtag_limit\": 2},\n            \"instagram\": {\"max_length\": 2200, \"hashtag_limit\": 30},\n            \"facebook\": {\"max_length\": 63206, \"hashtag_limit\": 5},\n            \"linkedin\": {\"max_length\": 3000, \"hashtag_limit\": 5}\n        }\n        \n        return constraints.get(platform.lower(), {})\n    \n    def _build_analysis_prompt(self, ev: ContentAnalysisEvent) -> str:\n        \"\"\"Build analysis prompt for LLM\"\"\"\n        return f\"\"\"\nAnalyze the following content for {ev.action} optimization:\n\nContent: \"{ev.content}\"\n\nAction: {ev.action}\nParameters: {ev.parameters}\nPlatform constraints: {ev.analysis_context.get('platform_constraints', {})}\n\nPlease analyze this content and determine the best optimization strategy. \nUse the available tools to check sentiment, constraints, and platform requirements.\n\nCRITICAL: If you can complete the optimization directly, use the complete_optimization tool with ONLY the final optimized content. Do NOT include any explanations or additional text in the final result.\n\nThe end result must be ONLY the optimized content with no commentary, explanations, or additional text.\n\"\"\"\n    \n    def _build_optimization_prompt(self, ev: OptimizationEvent) -> str:\n        \"\"\"Build optimization prompt for LLM\"\"\"\n        return f\"\"\"\nOptimize the following content based on the analysis results:\n\nOriginal Content: \"{ev.processed_content}\"\n\nTool Results: {ev.optimization_context.get('tool_results', [])}\nOptimization Targets: {ev.optimization_context.get('optimization_targets', [])}\nCurrent Confidence: {ev.confidence_score}\n\nCRITICAL INSTRUCTIONS:\n- Your response WILL be the social media posts content, therefore:\n- Your response must ONLY contain the final optimized content\n- Do NOT include any explanations, suggestions, or additional text\n- Do NOT include phrases like \"Here's the optimized version:\" or \"Consider this revision:\"\n- Do NOT include any commentary or analysis\n- Return ONLY the optimized content itself\n- If you cannot optimize further, return the original content exactly as provided\n\nYour entire response should be the optimized content and nothing else.\n\"\"\"\n    \n    def _extract_optimization_targets(self, ev: ContentAnalysisEvent) -> list[str]:\n        \"\"\"Extract optimization targets from event\"\"\"\n        targets = []\n        \n        if ev.action == \"ai_translate\":\n            targets.append(\"language_accuracy\")\n        elif ev.action == \"ai_rewrite\":\n            targets.extend([\"tone_adjustment\", \"clarity\", \"engagement\"])\n        elif ev.action == \"ai_summarize\":\n            targets.extend([\"brevity\", \"key_points\", \"coherence\"])\n        \n        return targets\n    \n    def _find_tool(self, tool_name: str) -> BaseTool | None:\n        \"\"\"Find tool by name\"\"\"\n        for tool in self.tools:\n            if tool.metadata.name == tool_name:\n                return tool\n        return None\n    \n    async def _execute_tool(self, tool: BaseTool, arguments: dict[str, Any]) -> Any:\n        \"\"\"Execute a tool with arguments\"\"\"\n        try:\n            if hasattr(tool, 'acall'):\n                return await tool.acall(**arguments)\n            else:\n                return tool.call(**arguments)\n        except Exception as e:\n            return {\"error\": str(e), \"success\": False}\n    \n    def _calculate_confidence(self, tool_results: list[dict[str, Any]]) -> float:\n        \"\"\"Calculate confidence score from tool results\"\"\"\n        if not tool_results:\n            return 0.5\n        \n        successful_results = [r for r in tool_results if r[\"success\"]]\n        return len(successful_results) / len(tool_results)\n    \n    def _assess_quality(self, content: str, ev: OptimizationEvent) -> float:\n        \"\"\"Assess quality of optimized content\"\"\"\n        # Simple quality assessment\n        if not content or len(content.strip()) < 5:\n            return 0.0\n        \n        # Check if content has improved\n        original_length = len(ev.processed_content)\n        new_length = len(content)\n        \n        # Basic quality metrics\n        quality_score = 0.5  # Base score\n        \n        if 0.5 <= new_length / original_length <= 2.0:  # Reasonable length change\n            quality_score += 0.2\n        \n        if content != ev.processed_content:  # Content was actually modified\n            quality_score += 0.2\n        \n        return min(quality_score + ev.confidence_score * 0.1, 1.0)\n    \n    def _get_platform_suggestions(self, platform: str) -> list[str]:\n        \"\"\"Get platform-specific optimization suggestions\"\"\"\n        suggestions = {\n            \"twitter\": [\"Keep it under 280 characters\", \"Use hashtags sparingly\", \"Make it engaging\"],\n            \"instagram\": [\"Add relevant hashtags\", \"Use visual language\", \"Include call-to-action\"],\n            \"facebook\": [\"Write conversational tone\", \"Ask questions\", \"Keep paragraphs short\"],\n            \"linkedin\": [\"Professional tone\", \"Include industry keywords\", \"Add value\"]\n        }\n        \n        return suggestions.get(platform, [\"Clear and engaging\", \"Appropriate length\", \"Good grammar\"])\n    \n    async def _direct_optimization(self, ctx: Context, ev: ToolExecutionEvent) -> OptimizationEvent:\n        \"\"\"Handle direct optimization without tool calls\"\"\"\n        return OptimizationEvent(\n            processed_content=ev.content_context.get(\"original_content\", \"\"),\n            optimization_context={\"direct_optimization\": True},\n            confidence_score=0.7,\n            user_id=ev.user_id,\n            phase=\"direct_optimization\"\n        )\n    \n    async def _force_completion(self, ctx: Context, ev: ToolExecutionEvent) -> StopEvent:\n        \"\"\"Force completion when max attempts reached\"\"\"\n        content = ev.content_context.get(\"original_content\", \"\")\n        return StopEvent(result={\n            \"content\": content,\n            \"confidence_score\": 0.6,\n            \"optimization_attempts\": self._optimization_attempts,\n            \"tools_used\": self._tools_used,\n            \"success\": True,\n            \"completion_reason\": \"max_attempts_reached\"\n        })","numLines":560,"startLine":1,"totalLines":560}}}
{"parentUuid":"ee81523f-8260-45d6-9e8e-595ba0d9e0cf","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013gYpf8DWC5emKYDkeXZapJ","type":"tool_result","content":"     1→\"\"\"Response schemas for AI API\"\"\"\n     2→\n     3→from typing import Any\n     4→from pydantic import BaseModel, Field\n     5→from datetime import datetime\n     6→\n     7→\n     8→class TokenUsage(BaseModel):\n     9→    \"\"\"Token usage information\"\"\"\n    10→    prompt_tokens: int = 0\n    11→    completion_tokens: int = 0\n    12→    total_tokens: int = 0\n    13→    estimated_cost: float = 0.0\n    14→\n    15→\n    16→class ActionResult(BaseModel):\n    17→    \"\"\"Structured result for AI actions\"\"\"\n    18→    content: str = Field(..., description=\"Processed content\")\n    19→    title: str | None = Field(None, description=\"Processed title (if applicable)\")\n    20→\n    21→\n    22→class ChatResponse(BaseModel):\n    23→    \"\"\"Chat conversation response\"\"\"\n    24→    message: str = Field(..., description=\"AI response message\")\n    25→    chat_id: str = Field(..., description=\"Conversation ID\")\n    26→    message_id: str = Field(..., description=\"Unique message ID\")\n    27→    \n    28→    # Actionable response support\n    29→    actions: list[dict[str, Any]] = Field(default_factory=list, description=\"AI-suggested actions\")\n    30→    has_actions: bool = Field(default=False, description=\"Whether response includes actions\")\n    31→    response_type: str = Field(default=\"text\", description=\"Response type: text or actionable\")\n    32→    \n    33→    # Metadata\n    34→    model_used: str = Field(..., description=\"LLM model used\")\n    35→    tokens: TokenUsage = Field(default_factory=TokenUsage)\n    36→    response_time_ms: int = Field(..., description=\"Processing time in milliseconds\")\n    37→    timestamp: str = Field(default_factory=lambda: datetime.utcnow().isoformat())\n    38→    \n    39→    # Tool calling info\n    40→    tools_used: list[str] = Field(default_factory=list)\n    41→    function_calls: list[dict[str, Any]] = Field(default_factory=list)\n    42→\n    43→\n    44→class ActionResponse(BaseModel):\n    45→    \"\"\"AI action processing response\"\"\"\n    46→    result: ActionResult = Field(..., description=\"Processed content result with structure\")\n    47→    action: str = Field(..., description=\"Action type performed\")\n    48→\n    49→    # Metadata\n    50→    model_used: str = Field(..., description=\"LLM model used\")\n    51→    tokens: TokenUsage = Field(default_factory=TokenUsage)\n    52→    response_time_ms: int = Field(..., description=\"Processing time in milliseconds\")\n    53→    timestamp: str = Field(default_factory=lambda: datetime.utcnow().isoformat())\n    54→\n    55→    # Action-specific metadata\n    56→    confidence_score: float | None = Field(None, ge=0.0, le=1.0)\n    57→    optimizations_applied: list[str] = Field(default_factory=list)\n    58→    warnings: list[str] = Field(default_factory=list)\n    59→\n    60→\n    61→class ErrorResponse(BaseModel):\n    62→    \"\"\"Error response\"\"\"\n    63→    error: str = Field(..., description=\"Error message\")\n    64→    code: int = Field(..., description=\"HTTP status code\")\n    65→    details: dict[str, Any] | None = Field(None, description=\"Additional error details\")\n    66→    timestamp: str = Field(default_factory=lambda: datetime.utcnow().isoformat())\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"2b17a721-af98-45cc-ae23-8a4f5750f6f4","timestamp":"2025-09-30T20:36:13.125Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/natedamstra/socialaize/functions/AI_API/src/schemas/responses.py","content":"\"\"\"Response schemas for AI API\"\"\"\n\nfrom typing import Any\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\n\nclass TokenUsage(BaseModel):\n    \"\"\"Token usage information\"\"\"\n    prompt_tokens: int = 0\n    completion_tokens: int = 0\n    total_tokens: int = 0\n    estimated_cost: float = 0.0\n\n\nclass ActionResult(BaseModel):\n    \"\"\"Structured result for AI actions\"\"\"\n    content: str = Field(..., description=\"Processed content\")\n    title: str | None = Field(None, description=\"Processed title (if applicable)\")\n\n\nclass ChatResponse(BaseModel):\n    \"\"\"Chat conversation response\"\"\"\n    message: str = Field(..., description=\"AI response message\")\n    chat_id: str = Field(..., description=\"Conversation ID\")\n    message_id: str = Field(..., description=\"Unique message ID\")\n    \n    # Actionable response support\n    actions: list[dict[str, Any]] = Field(default_factory=list, description=\"AI-suggested actions\")\n    has_actions: bool = Field(default=False, description=\"Whether response includes actions\")\n    response_type: str = Field(default=\"text\", description=\"Response type: text or actionable\")\n    \n    # Metadata\n    model_used: str = Field(..., description=\"LLM model used\")\n    tokens: TokenUsage = Field(default_factory=TokenUsage)\n    response_time_ms: int = Field(..., description=\"Processing time in milliseconds\")\n    timestamp: str = Field(default_factory=lambda: datetime.utcnow().isoformat())\n    \n    # Tool calling info\n    tools_used: list[str] = Field(default_factory=list)\n    function_calls: list[dict[str, Any]] = Field(default_factory=list)\n\n\nclass ActionResponse(BaseModel):\n    \"\"\"AI action processing response\"\"\"\n    result: ActionResult = Field(..., description=\"Processed content result with structure\")\n    action: str = Field(..., description=\"Action type performed\")\n\n    # Metadata\n    model_used: str = Field(..., description=\"LLM model used\")\n    tokens: TokenUsage = Field(default_factory=TokenUsage)\n    response_time_ms: int = Field(..., description=\"Processing time in milliseconds\")\n    timestamp: str = Field(default_factory=lambda: datetime.utcnow().isoformat())\n\n    # Action-specific metadata\n    confidence_score: float | None = Field(None, ge=0.0, le=1.0)\n    optimizations_applied: list[str] = Field(default_factory=list)\n    warnings: list[str] = Field(default_factory=list)\n\n\nclass ErrorResponse(BaseModel):\n    \"\"\"Error response\"\"\"\n    error: str = Field(..., description=\"Error message\")\n    code: int = Field(..., description=\"HTTP status code\")\n    details: dict[str, Any] | None = Field(None, description=\"Additional error details\")\n    timestamp: str = Field(default_factory=lambda: datetime.utcnow().isoformat())","numLines":66,"startLine":1,"totalLines":66}}}
{"parentUuid":"2b17a721-af98-45cc-ae23-8a4f5750f6f4","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01HZkkscdCcaXvfWQ9B8RK9z","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"thinking","thinking":"Excellent! Now I have all the information I need. Let me read one more file - the WorkflowManager's routing to understand how actions are dispatched.","signature":"EsACCkYICBgCKkCfdxhYLXax9wcrukUsoisi93Q+/Q2tRLlsUtZ+KgJr30KWTt/ThaylSwFZU0qL5Nzf13ur9OBGVIq5EhfMLYcVEgwiWZHeIKVLSpf+hO8aDEmjHVh2EzcArvG2iCIwxfv+psBTWQH8N5q/osG3tmXq0omsFQRONWOCsSZOhIN8inwcqW9RG3wBCptLSw/wKqcB5q1h8oLXCRCm1LCdqwmxGFjXtpaxxO6gRbO0gK5/nGkrzZWOhSkotVnaFnbJHHOPl+ryVw9eZfqZQse4ZYjLynQF9Bf5nGrWWnf0eanlgjsC9wMUUar6DCFRQwbXtEy22y9XG+gro7OnB0CdFUirkLXhN6s5eJiktoNM6s703dwXagLBfgjnyK+9ATHZ5QPEYDVBdVn2wWasTaA60JSKFF914CGUSbYYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":13498,"cache_read_input_tokens":53947,"cache_creation":{"ephemeral_5m_input_tokens":13498,"ephemeral_1h_input_tokens":0},"output_tokens":11,"service_tier":"standard"}},"requestId":"req_011CTfE6dsZgcFnx49jKwAeK","type":"assistant","uuid":"1503e4bf-ec92-44cb-a1cf-51986571a91a","timestamp":"2025-09-30T20:36:17.073Z"}
{"parentUuid":"1503e4bf-ec92-44cb-a1cf-51986571a91a","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01HZkkscdCcaXvfWQ9B8RK9z","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_01S1KD5xEzgJiNoVTZRbqfNw","name":"TodoWrite","input":{"todos":[{"content":"Read frontend workflow utilities to understand action nodes and configs","activeForm":"Reading frontend workflow utilities","status":"completed"},{"content":"Read WorkflowManager AI action handlers","activeForm":"Reading WorkflowManager AI action handlers","status":"completed"},{"content":"Read AI_API implementation and schemas","activeForm":"Reading AI_API implementation and schemas","status":"completed"},{"content":"Analyze schemas and data flow between all three layers","activeForm":"Analyzing schemas and data flow","status":"in_progress"},{"content":"Create comprehensive rewritten documentation with visual diagrams","activeForm":"Creating comprehensive documentation","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":13498,"cache_read_input_tokens":53947,"cache_creation":{"ephemeral_5m_input_tokens":13498,"ephemeral_1h_input_tokens":0},"output_tokens":11,"service_tier":"standard"}},"requestId":"req_011CTfE6dsZgcFnx49jKwAeK","type":"assistant","uuid":"6120b223-8f81-4e39-8eb6-67fd2b9589a5","timestamp":"2025-09-30T20:36:20.767Z"}
{"parentUuid":"6120b223-8f81-4e39-8eb6-67fd2b9589a5","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01HZkkscdCcaXvfWQ9B8RK9z","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_013rpCnAV4d7LcDjuCt6nVUh","name":"Glob","input":{"pattern":"functions/WorkflowManager/src/handlers/workflowActions.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":13498,"cache_read_input_tokens":53947,"cache_creation":{"ephemeral_5m_input_tokens":13498,"ephemeral_1h_input_tokens":0},"output_tokens":310,"service_tier":"standard"}},"requestId":"req_011CTfE6dsZgcFnx49jKwAeK","type":"assistant","uuid":"652a3ab5-22f1-45e2-b797-84210fc00abd","timestamp":"2025-09-30T20:36:21.554Z"}
{"parentUuid":"652a3ab5-22f1-45e2-b797-84210fc00abd","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01S1KD5xEzgJiNoVTZRbqfNw","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"5459b03b-ace0-4071-a787-b58af194d737","timestamp":"2025-09-30T20:36:21.665Z","toolUseResult":{"oldTodos":[{"content":"Read frontend workflow utilities to understand action nodes and configs","status":"completed","activeForm":"Reading frontend workflow utilities"},{"content":"Read WorkflowManager AI action handlers","status":"completed","activeForm":"Reading WorkflowManager AI action handlers"},{"content":"Read AI_API implementation and schemas","status":"in_progress","activeForm":"Reading AI_API implementation and schemas"},{"content":"Analyze schemas and data flow between all three layers","status":"pending","activeForm":"Analyzing schemas and data flow"},{"content":"Create comprehensive rewritten documentation with visual diagrams","status":"pending","activeForm":"Creating comprehensive documentation"}],"newTodos":[{"content":"Read frontend workflow utilities to understand action nodes and configs","status":"completed","activeForm":"Reading frontend workflow utilities"},{"content":"Read WorkflowManager AI action handlers","status":"completed","activeForm":"Reading WorkflowManager AI action handlers"},{"content":"Read AI_API implementation and schemas","status":"completed","activeForm":"Reading AI_API implementation and schemas"},{"content":"Analyze schemas and data flow between all three layers","status":"in_progress","activeForm":"Analyzing schemas and data flow"},{"content":"Create comprehensive rewritten documentation with visual diagrams","status":"pending","activeForm":"Creating comprehensive documentation"}]}}
{"parentUuid":"5459b03b-ace0-4071-a787-b58af194d737","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013rpCnAV4d7LcDjuCt6nVUh","type":"tool_result","content":"/Users/natedamstra/socialaize/functions/WorkflowManager/src/handlers/workflowActions.ts"}]},"uuid":"502332e8-c43a-45a4-9bbe-d7e69f07f112","timestamp":"2025-09-30T20:36:21.724Z","toolUseResult":{"filenames":["/Users/natedamstra/socialaize/functions/WorkflowManager/src/handlers/workflowActions.ts"],"durationMs":17,"numFiles":1,"truncated":false}}
{"parentUuid":"502332e8-c43a-45a4-9bbe-d7e69f07f112","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01CxDsAZv8bL7yAs7W4BRyE1","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"thinking","thinking":"Good, let me read that file to understand the routing.","signature":"EuEBCkYICBgCKkDqX5jWxslXtcP5QEHQtjNogOYiU26r/nl1dKvkWpJ3yU2tq1Af4HIinrTMhHUCeWQlWWFUQI++lj6bZO0japrXEgwlfIQAjU4ElRzWQhgaDF3PP06UrnaRv3s6NyIwzjB0bJNxeF3J8/vikoLl2ed2IB41SqSMaFCIdp1exdAZGRgr+YS8ggea6eXFgLOmKkmQG5BgKlYYqI9pWVhrbncop5pqk2GpNJ9FenqzEKh1iY4EEIFdZ7wFT3SkEI7AVHymseRQFe5yA3KpGE27KRY2yEa1UfQuxxhoGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":432,"cache_read_input_tokens":67445,"cache_creation":{"ephemeral_5m_input_tokens":432,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CTfE7FxUUZpoN153YWRNp","type":"assistant","uuid":"ee49e91e-75a2-46aa-99fa-811856182e1a","timestamp":"2025-09-30T20:36:24.681Z"}
{"parentUuid":"ee49e91e-75a2-46aa-99fa-811856182e1a","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01CxDsAZv8bL7yAs7W4BRyE1","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_01KEK9rWu78dVDpiWhD1HukQ","name":"Read","input":{"file_path":"/Users/natedamstra/socialaize/functions/WorkflowManager/src/handlers/workflowActions.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":432,"cache_read_input_tokens":67445,"cache_creation":{"ephemeral_5m_input_tokens":432,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CTfE7FxUUZpoN153YWRNp","type":"assistant","uuid":"097537fe-9371-49b7-87cd-9b616998cfee","timestamp":"2025-09-30T20:36:25.238Z"}
{"parentUuid":"097537fe-9371-49b7-87cd-9b616998cfee","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KEK9rWu78dVDpiWhD1HukQ","type":"tool_result","content":"     1→import {\n     2→  AppwriteManager,\n     3→  WORKFLOW_EXECUTION_COLL_ID,\n     4→  WORKFLOW_NODE_COLL_ID,\n     5→} from './appwriteManager.js';\n     6→import { Query } from 'node-appwrite';\n     7→import { PostContainer } from '../types/database/postContainer.js';\n     8→import {\n     9→  WorkflowExecution,\n    10→  WorkflowExecutionSchema,\n    11→} from '../types/database/workflowExecution.js';\n    12→import * as aiActions from './actions/aiActions.js';\n    13→import * as contentActions from './actions/contentActions.js';\n    14→import * as utilityActions from './actions/utilityActions.js';\n    15→import {\n    16→  ActionConfig,\n    17→  ConditionSchema,\n    18→  type Condition,\n    19→} from '../schema/actionSchemas.js';\n    20→\n    21→interface NodeState {\n    22→  status: 'pending' | 'running' | 'completed' | 'failed';\n    23→  output?: any;\n    24→  completedBranches?: string[];\n    25→  error?: {\n    26→    message: string;\n    27→    stack?: string;\n    28→    details?: any;\n    29→  };\n    30→}\n    31→\n    32→interface NodeConnections {\n    33→  next?: string;\n    34→  cases?: Array<{ condition: string; nodeId: string }>;\n    35→  default?: string;\n    36→  branches?: string[];\n    37→  requiredBranches?: string[];\n    38→}\n    39→\n    40→export class WorkflowActions {\n    41→  constructor(\n    42→    private appwriteManager: AppwriteManager,\n    43→    private log: (message: string) => void,\n    44→    private error: (message: string) => void,\n    45→    private databaseId: string\n    46→  ) {\n    47→    this.appwriteManager.databaseId = databaseId;\n    48→  }\n    49→\n    50→  private async checkCondition(\n    51→    condition: Condition,\n    52→    postData: any\n    53→  ): Promise<boolean> {\n    54→    this.log(`Checking condition: ${JSON.stringify(condition, null, 4)}`);\n    55→    const postContainer =\n    56→      typeof postData === 'string' ? JSON.parse(postData) : postData;\n    57→    const genericPost =\n    58→      typeof postContainer.postData === 'string'\n    59→        ? JSON.parse(postContainer.postData)\n    60→        : postContainer.postData;\n    61→    this.log(`Generic post: ${JSON.stringify(genericPost, null, 4)}`);\n    62→    switch (condition.type) {\n    63→      case 'post_type_is':\n    64→        return genericPost.postType === condition.value;\n    65→      case 'platform_is':\n    66→        return genericPost.platform === condition.value;\n    67→      case 'content_contains':\n    68→        return genericPost.text?.includes(condition.value) ?? false;\n    69→      case 'content_matches':\n    70→        try {\n    71→          const regex = new RegExp(condition.value);\n    72→          return (\n    73→            regex.test(genericPost.text || '') ||\n    74→            genericPost.text === condition.value\n    75→          );\n    76→        } catch {\n    77→          return false;\n    78→        }\n    79→      case 'hashtags_contain':\n    80→        this.log(\n    81→          `Checking hashtags_contain: ${condition.value} | extraData: ${JSON.stringify(\n    82→            genericPost.extraData?.hashtags,\n    83→            null,\n    84→            2\n    85→          )} | text: \"${genericPost.text}\"`\n    86→        );\n    87→        \n    88→        // Try to use extraData.hashtags first (if populated by post converters)\n    89→        let hashtags = genericPost.extraData?.hashtags;\n    90→        \n    91→        // If no hashtags in extraData, parse them from text using ztextutils as fallback\n    92→        if (!Array.isArray(hashtags) || hashtags.length === 0) {\n    93→          this.log('No hashtags in extraData, parsing from text with ztextutils');\n    94→          const { defaultParser } = await import('ztextutils');\n    95→          const textData = defaultParser.parse(genericPost.text || '');\n    96→          hashtags = textData.hashtags;\n    97→        }\n    98→        \n    99→        this.log(`Using hashtags: ${JSON.stringify(hashtags)}`);\n   100→        \n   101→        const hasMatch =\n   102→          Array.isArray(hashtags) &&\n   103→          hashtags.some((hashtag: string) => {\n   104→            const result = hashtag\n   105→              .toLowerCase()\n   106→              .includes(condition.value.toLowerCase());\n   107→            this.log(`  Checking \"${hashtag}\" contains \"${condition.value}\": ${result}`);\n   108→            return result;\n   109→          });\n   110→\n   111→        this.log(`Final result: ${hasMatch}`);\n   112→        return hasMatch;\n   113→      case 'video_duration':\n   114→        this.log(`Checking video_duration condition: ${condition.operator} ${condition.value}`);\n   115→\n   116→        // If this is a carousel post, video_duration is not applicable\n   117→        if (genericPost.postType === 'carousel' || genericPost.postType === 'caption-image' || genericPost.postType === 'file' || genericPost.postType === 'text') {\n   118→          this.log('Post is a carousel; video_duration condition not applicable. Condition fails.');\n   119→          return false;\n   120→        }\n   121→\n   122→        // Try to get duration from extraData.duration first\n   123→        let videoDuration = null;\n   124→\n   125→        if (genericPost.extraData) {\n   126→          try {\n   127→            const extraData = typeof genericPost.extraData === 'string'\n   128→              ? JSON.parse(genericPost.extraData)\n   129→              : genericPost.extraData;\n   130→            videoDuration = extraData.duration;\n   131→          } catch (e) {\n   132→            this.log(`Failed to parse extraData: ${e}`);\n   133→          }\n   134→        }\n   135→\n   136→        // If not found in extraData, try platformMetrics\n   137→        if (videoDuration === null && genericPost.platformMetrics) {\n   138→          try {\n   139→            const platformMetrics = typeof genericPost.platformMetrics === 'string'\n   140→              ? JSON.parse(genericPost.platformMetrics)\n   141→              : genericPost.platformMetrics;\n   142→            videoDuration = platformMetrics.duration;\n   143→          } catch (e) {\n   144→            this.log(`Failed to parse platformMetrics: ${e}`);\n   145→          }\n   146→        }\n   147→\n   148→        // If no duration found in existing data, check if post contains video before extracting\n   149→        if (videoDuration === null || videoDuration === undefined) {\n   150→          const hasVideo = Array.isArray(genericPost.media)\n   151→            ? genericPost.media.some((m: any) => m?.type === 'video')\n   152→            : false;\n   153→          if (!hasVideo) {\n   154→            this.log('Post is not a video; skipping duration extraction. Condition fails.');\n   155→            return false;\n   156→          }\n   157→\n   158→          this.log('No video duration found in existing data, attempting to extract from video files');\n   159→          const { VideoUtils } = await import('../utils/videoUtils.js');\n   160→          videoDuration = await VideoUtils.extractVideoDurationFromPost(\n   161→            genericPost,\n   162→            this.appwriteManager,\n   163→            this.log\n   164→          );\n   165→\n   166→          if (videoDuration === null || videoDuration === undefined) {\n   167→            this.log('No video duration found - video likely still being processed by FileMetadataHandler');\n   168→            this.log('Retrying with delays to allow file processing to complete...');\n   169→\n   170→            // Retry with increasing delays to wait for FileMetadataHandler\n   171→            const maxAttempts = 5;\n   172→            const baseDelayMs = 3000; // Start with 3 seconds\n   173→\n   174→            for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n   175→              const delayMs = baseDelayMs * attempt; // Increasing delay: 3s, 6s, 9s, 12s, 15s\n   176→              this.log(`Retry attempt ${attempt}/${maxAttempts} - waiting ${delayMs/1000}s for video processing...`);\n   177→\n   178→              await new Promise(resolve => setTimeout(resolve, delayMs));\n   179→\n   180→              try {\n   181→                videoDuration = await VideoUtils.extractVideoDurationFromPost(\n   182→                  genericPost,\n   183→                  this.appwriteManager,\n   184→                  this.log\n   185→                );\n   186→\n   187→                if (videoDuration !== null && videoDuration !== undefined) {\n   188→                  this.log(`Video duration found on attempt ${attempt}: ${videoDuration} seconds`);\n   189→                  break;\n   190→                }\n   191→              } catch (retryError) {\n   192→                this.log(`Retry attempt ${attempt} failed: ${retryError}`);\n   193→              }\n   194→            }\n   195→\n   196→            // Final check after all retries\n   197→            if (videoDuration === null || videoDuration === undefined) {\n   198→              this.log('No video duration found after all retry attempts - condition fails');\n   199→              return false;\n   200→            }\n   201→          }\n   202→\n   203→          this.log(`Extracted video duration: ${videoDuration} seconds`);\n   204→        } else {\n   205→          this.log(`Found video duration: ${videoDuration} seconds`);\n   206→        }\n   207→\n   208→        const durationValue = Number(videoDuration);\n   209→        const conditionValue = Number(condition.value);\n   210→\n   211→        if (isNaN(durationValue) || isNaN(conditionValue)) {\n   212→          this.log('Invalid duration values, condition fails');\n   213→          return false;\n   214→        }\n   215→\n   216→        const result = condition.operator === 'greater_than'\n   217→          ? durationValue > conditionValue\n   218→          : durationValue < conditionValue;\n   219→\n   220→        this.log(`Video duration check: ${durationValue} ${condition.operator === 'greater_than' ? '>' : '<'} ${conditionValue} = ${result}`);\n   221→        return result;\n   222→      default:\n   223→        return true;\n   224→    }\n   225→  }\n   226→\n   227→  async handleWorkflowAction(\n   228→    action: string,\n   229→    data: {\n   230→      postData: any;\n   231→      config: ActionConfig;\n   232→    }\n   233→  ) {\n   234→    try {\n   235→      this.log(`Handling action: ${action} | ${JSON.stringify(data, null, 4)}`);\n   236→      // Check node's conditions (supports logical AND/OR tokens between conditions)\n   237→      if (data.config?.conditions && data.config.conditions.length > 0) {\n   238→        let combinedDefined = false;\n   239→        let combined = true;\n   240→        let currentOp: 'AND' | 'OR' = 'AND';\n   241→\n   242→        const tokens = data.config.conditions;\n   243→        for (let i = 0; i < tokens.length; i++) {\n   244→          const parsed = ConditionSchema.safeParse(tokens[i]);\n   245→          if (!parsed.success) {\n   246→            this.log(`Condition token ${i} failed schema parse; skipping.`);\n   247→            continue;\n   248→          }\n   249→\n   250→          const token = parsed.data as any;\n   251→          if (token.type === 'AND' || token.type === 'OR') {\n   252→            // Set operator only if a following condition exists\n   253→            if (i < tokens.length - 1) {\n   254→              currentOp = token.type;\n   255→            } else {\n   256→              this.log(`Trailing logical operator (${token.type}) without following condition; ignoring.`);\n   257→            }\n   258→            continue;\n   259→          }\n   260→\n   261→          // Evaluate a real condition\n   262→          const met = await this.checkCondition(token, data.postData);\n   263→          this.log(`Condition ${i} (${token.type}) result: ${met}`);\n   264→\n   265→          if (!combinedDefined) {\n   266→            combined = met;\n   267→            combinedDefined = true;\n   268→          } else {\n   269→            combined = currentOp === 'AND' ? combined && met : combined || met;\n   270→          }\n   271→\n   272→          // After consuming a condition, default operator stays as last set until changed by next token\n   273→        }\n   274→\n   275→        if (!combinedDefined) {\n   276→          // No valid condition found; allow node to proceed by default\n   277→          this.log('No valid conditions found; proceeding by default.');\n   278→        } else if (!combined) {\n   279→          this.log('Node conditions not met, skipping action');\n   280→          return data.postData; // Return unchanged data if conditions aren't met\n   281→        }\n   282→      }\n   283→\n   284→      switch (action) {\n   285→        // Content Publishing\n   286→        case 'publish_content':\n   287→          return await contentActions.handlePublishContent(\n   288→            {\n   289→              postData: data.postData,\n   290→              config: data.config,\n   291→            },\n   292→            this.appwriteManager\n   293→          );\n   294→\n   295→        // AI Actions\n   296→        case 'ai_rewrite':\n   297→        case 'ai_gen_content':\n   298→        case 'ai_generate_content':\n   299→          return await aiActions.handleAiRewrite(\n   300→            {\n   301→              postData: data.postData,\n   302→              config: data.config,\n   303→            },\n   304→            this.appwriteManager\n   305→          );\n   306→        case 'ai_translate':\n   307→          return await aiActions.handleAiTranslate(\n   308→            {\n   309→              postData: data.postData,\n   310→              config: data.config,\n   311→            },\n   312→            this.appwriteManager\n   313→          );\n   314→        case 'ai_summarize':\n   315→          return await aiActions.handleAiSummarize(\n   316→            {\n   317→              postData: data.postData,\n   318→              config: data.config,\n   319→            },\n   320→            this.appwriteManager\n   321→          );\n   322→        case 'ai_add_hashtags':\n   323→        case 'ai_add_tags':\n   324→        case 'ai_gen_tags':\n   325→          return await aiActions.handleAiAddHashtags(\n   326→            {\n   327→              postData: data.postData,\n   328→              config: data.config,\n   329→            },\n   330→            this.appwriteManager\n   331→          );\n   332→        case 'ai_gen_title':\n   333→        case 'ai_add_title':\n   334→          return await aiActions.handleAiGenerateTitle(\n   335→            {\n   336→              postData: data.postData,\n   337→              config: data.config,\n   338→            },\n   339→            this.appwriteManager\n   340→          );\n   341→\n   342→        // Basic Content Modifications\n   343→        case 'set_title':\n   344→          return await contentActions.handleSetTitle(\n   345→            {\n   346→              postData: data.postData,\n   347→              config: data.config,\n   348→            },\n   349→            this.appwriteManager\n   350→          );\n   351→        case 'set_content':\n   352→          return await contentActions.handleSetContent(\n   353→            {\n   354→              postData: data.postData,\n   355→              config: data.config,\n   356→            },\n   357→            this.appwriteManager\n   358→          );\n   359→        case 'add_hashtags':\n   360→          return await contentActions.handleAddHashtags(\n   361→            {\n   362→              postData: data.postData,\n   363→              config: data.config,\n   364→            },\n   365→            this.appwriteManager\n   366→          );\n   367→        case 'schedule_post':\n   368→          return await contentActions.handleSchedulePost(\n   369→            {\n   370→              postData: data.postData,\n   371→              config: data.config,\n   372→            },\n   373→            this.appwriteManager\n   374→          );\n   375→\n   376→        // Utility Actions\n   377→        case 'wait':\n   378→          return await utilityActions.handleWait(\n   379→            {\n   380→              postData: data.postData,\n   381→              config: data.config,\n   382→            },\n   383→            this.appwriteManager\n   384→          );\n   385→        case 'fetch_content':\n   386→          return await utilityActions.handleFetchContent(\n   387→            {\n   388→              postData: data.postData,\n   389→              config: data.config,\n   390→            },\n   391→            this.appwriteManager\n   392→          );\n   393→\n   394→        default:\n   395→          this.error(`Unknown action: ${action}`);\n   396→          throw new Error(`Unknown action: ${action}`);\n   397→      }\n   398→    } catch (error) {\n   399→      const errorDetails = {\n   400→        message: error instanceof Error ? error.message : 'Unknown error',\n   401→        stack: error instanceof Error ? error.stack : undefined,\n   402→        details: error,\n   403→      };\n   404→      this.error(\n   405→        `Error in handleWorkflowAction: ${JSON.stringify(errorDetails, null, 2)}`\n   406→      );\n   407→      throw error;\n   408→    }\n   409→  }\n   410→\n   411→  async handleNewPost(\n   412→    workflowExecution: WorkflowExecution,\n   413→    workflowId: string\n   414→  ) {\n   415→    this.log(`Processing workflow execution: ${workflowExecution.$id}`);\n   416→    let processedData: any = {};\n   417→    const nodeStates: Record<string, NodeState> = {};\n   418→\n   419→    try {\n   420→      // Initialize or get existing node states\n   421→      const existingNodeStates = workflowExecution.nodeStates\n   422→        ? JSON.parse(workflowExecution.nodeStates)\n   423→        : {};\n   424→      Object.assign(nodeStates, existingNodeStates);\n   425→\n   426→      await this.updateExecutionStatus(workflowExecution.$id!, 'running');\n   427→\n   428→      const postData: PostContainer = workflowExecution.workflowData\n   429→        ? JSON.parse(workflowExecution.workflowData).post\n   430→        : {};\n   431→      processedData = postData;\n   432→\n   433→      // Get all nodes for this workflow\n   434→      const nodes = await this.appwriteManager.listDocuments(\n   435→        WORKFLOW_NODE_COLL_ID,\n   436→        [Query.equal('workflowId', workflowId), Query.limit(1000)],\n   437→        'workflows'\n   438→      );\n   439→\n   440→      if (!nodes.documents.length) {\n   441→        throw new Error('No nodes found in workflow');\n   442→      }\n   443→\n   444→      let currentNode = this.findStartingNode(nodes.documents);\n   445→      if (!currentNode) {\n   446→        throw new Error('No starting node found in workflow');\n   447→      }\n   448→\n   449→      while (currentNode) {\n   450→        const nodeId = currentNode.$id;\n   451→        const config = JSON.parse(currentNode.config || '{}');\n   452→\n   453→        // Defensive transformation: convert null conditions to undefined\n   454→        if (config.conditions === null) {\n   455→          config.conditions = undefined;\n   456→        }\n   457→\n   458→        const connections: NodeConnections = JSON.parse(\n   459→          currentNode.connections || '{}'\n   460→        );\n   461→\n   462→        try {\n   463→          nodeStates[nodeId] = { status: 'running' };\n   464→          await this.updateNodeStates(workflowExecution.$id!, nodeStates);\n   465→          this.log(`Processing node ${nodeId} -- ${currentNode.nodeType}`);\n   466→\n   467→          switch (currentNode.nodeType) {\n   468→            case 'ACTION': {\n   469→              if (!currentNode.action) {\n   470→                throw new Error('Action node requires an action type');\n   471→              }\n   472→\n   473→              this.log(\n   474→                `Processing action node ${nodeId} -- ${currentNode.action}`\n   475→              );\n   476→              processedData = await this.handleWorkflowAction(\n   477→                currentNode.action,\n   478→                {\n   479→                  postData: processedData,\n   480→                  config,\n   481→                }\n   482→              );\n   483→              this.log(\n   484→                `Action node ${nodeId} completed, processedData: ${JSON.stringify(processedData, null, 4)}`\n   485→              );\n   486→\n   487→              nodeStates[nodeId] = {\n   488→                status: 'completed',\n   489→                output: processedData,\n   490→              };\n   491→\n   492→              currentNode = connections.next\n   493→                ? nodes.documents.find((n) => n.$id === connections.next)\n   494→                : null;\n   495→              this.log(\n   496→                `Current node (after finding next node): ${JSON.stringify(\n   497→                  currentNode,\n   498→                  null,\n   499→                  4\n   500→                )}`\n   501→              );\n   502→              break;\n   503→            }\n   504→\n   505→            case 'SWITCH': {\n   506→              let nextNodeId = null;\n   507→\n   508→              // Check each case condition\n   509→              if (connections.cases) {\n   510→                for (const caseItem of connections.cases) {\n   511→                  const conditionMet = await this.checkCondition(\n   512→                    JSON.parse(caseItem.condition),\n   513→                    processedData\n   514→                  );\n   515→                  if (conditionMet) {\n   516→                    nextNodeId = caseItem.nodeId;\n   517→                    break;\n   518→                  }\n   519→                }\n   520→              }\n   521→\n   522→              // If no case matched, use default path\n   523→              if (!nextNodeId && connections.default) {\n   524→                nextNodeId = connections.default;\n   525→              }\n   526→\n   527→              nodeStates[nodeId] = {\n   528→                status: 'completed',\n   529→                output: { nextNode: nextNodeId },\n   530→              };\n   531→\n   532→              currentNode = nextNodeId\n   533→                ? nodes.documents.find(\n   534→                    (n) =>\n   535→                      n.$id === nextNodeId ||\n   536→                      nodeId === JSON.parse(n.connections).previous\n   537→                  )\n   538→                : null;\n   539→              this.log(\n   540→                `Current node (after finding next node): ${JSON.stringify(\n   541→                  currentNode,\n   542→                  null,\n   543→                  4\n   544→                )}`\n   545→              );\n   546→              break;\n   547→            }\n   548→\n   549→            case 'PARALLEL': {\n   550→              if (!connections.branches?.length) {\n   551→                throw new Error('Parallel node requires branches');\n   552→              }\n   553→\n   554→              // Process all branches in parallel\n   555→              const branchNodes = connections.branches.map((branchId) =>\n   556→                nodes.documents.find((n) => n.$id === branchId)\n   557→              );\n   558→\n   559→              const branchResults = await Promise.all(\n   560→                branchNodes.map((startNode) =>\n   561→                  this.processNodeBranch(\n   562→                    startNode,\n   563→                    nodes.documents,\n   564→                    processedData,\n   565→                    nodeStates\n   566→                  )\n   567→                )\n   568→              );\n   569→\n   570→              // Merge results from all branches\n   571→              processedData = branchResults.reduce(\n   572→                (acc, result) => ({\n   573→                  ...acc,\n   574→                  ...result,\n   575→                }),\n   576→                processedData\n   577→              );\n   578→\n   579→              // Move to next node if all required branches completed\n   580→              currentNode = connections.next\n   581→                ? nodes.documents.find((n) => n.$id === connections.next)\n   582→                : null;\n   583→              this.log(\n   584→                `Current node (after finding next node): ${JSON.stringify(\n   585→                  currentNode,\n   586→                  null,\n   587→                  4\n   588→                )}`\n   589→              );\n   590→              break;\n   591→            }\n   592→\n   593→            default:\n   594→              throw new Error(`Unknown node type: ${currentNode.nodeType}`);\n   595→          }\n   596→\n   597→          await this.updateNodeStates(workflowExecution.$id!, nodeStates);\n   598→        } catch (error) {\n   599→          const errorDetails = {\n   600→            message: error instanceof Error ? error.message : 'Unknown error',\n   601→            stack: error instanceof Error ? error.stack : undefined,\n   602→            details: error,\n   603→          };\n   604→\n   605→          this.error(\n   606→            `Error processing node ${nodeId}: ${JSON.stringify(errorDetails, null, 2)}`\n   607→          );\n   608→\n   609→          nodeStates[nodeId] = {\n   610→            status: 'failed',\n   611→            error: errorDetails,\n   612→          };\n   613→\n   614→          await this.updateNodeStates(workflowExecution.$id!, nodeStates);\n   615→          await this.updateExecutionStatus(workflowExecution.$id!, 'failed');\n   616→          throw error;\n   617→        }\n   618→      }\n   619→\n   620→      await this.updateExecutionStatus(workflowExecution.$id!, 'completed');\n   621→      return processedData;\n   622→    } catch (error) {\n   623→      const errorDetails = {\n   624→        message: error instanceof Error ? error.message : 'Unknown error',\n   625→        stack: error instanceof Error ? error.stack : undefined,\n   626→        details: error,\n   627→      };\n   628→\n   629→      this.error(\n   630→        `Error in workflow execution: ${JSON.stringify(errorDetails, null, 2)}`\n   631→      );\n   632→      await this.updateExecutionStatus(workflowExecution.$id!, 'failed');\n   633→      throw error;\n   634→    }\n   635→  }\n   636→\n   637→  private async processNodeBranch(\n   638→    startNode: any,\n   639→    allNodes: any[],\n   640→    initialData: any,\n   641→    nodeStates: Record<string, NodeState>\n   642→  ) {\n   643→    let currentNode = startNode;\n   644→    let processedData = initialData;\n   645→\n   646→    while (currentNode) {\n   647→      const nodeId = currentNode.$id;\n   648→      const config = JSON.parse(currentNode.config || '{}');\n   649→      const connections: NodeConnections = JSON.parse(\n   650→        currentNode.connections || '{}'\n   651→      );\n   652→\n   653→      try {\n   654→        if (currentNode.nodeType === 'ACTION' && currentNode.action) {\n   655→          processedData = await this.handleWorkflowAction(currentNode.action, {\n   656→            postData: processedData,\n   657→            config,\n   658→          });\n   659→\n   660→          nodeStates[nodeId] = {\n   661→            status: 'completed',\n   662→            output: processedData,\n   663→          };\n   664→        }\n   665→\n   666→        currentNode = connections.next\n   667→          ? allNodes.find(\n   668→              (n) =>\n   669→                n.$id === connections.next ||\n   670→                nodeId === JSON.parse(n.connections).previous\n   671→            )\n   672→          : null;\n   673→        this.log(`Current node: ${JSON.stringify(currentNode, null, 4)}`);\n   674→        if (Array.isArray(currentNode)) {\n   675→          currentNode = currentNode.find((n) => n.$id === connections.next);\n   676→        }\n   677→      } catch (error) {\n   678→        const errorDetails = {\n   679→          message: error instanceof Error ? error.message : 'Unknown error',\n   680→          stack: error instanceof Error ? error.stack : undefined,\n   681→          details: error,\n   682→        };\n   683→\n   684→        this.error(\n   685→          `Error processing branch node ${nodeId}: ${JSON.stringify(errorDetails, null, 2)}`\n   686→        );\n   687→\n   688→        nodeStates[nodeId] = {\n   689→          status: 'failed',\n   690→          error: errorDetails,\n   691→        };\n   692→\n   693→        throw error;\n   694→      }\n   695→    }\n   696→\n   697→    return processedData;\n   698→  }\n   699→\n   700→  private async updateExecutionStatus(\n   701→    executionId: string,\n   702→    status: 'running' | 'completed' | 'failed'\n   703→  ) {\n   704→    const executionDoc = await this.appwriteManager.getDocument(\n   705→      WORKFLOW_EXECUTION_COLL_ID,\n   706→      executionId,\n   707→      'workflows'\n   708→    );\n   709→\n   710→    const cleanExecution = WorkflowExecutionSchema.parse(executionDoc);\n   711→    delete cleanExecution.$id;\n   712→    delete cleanExecution.$createdAt;\n   713→    delete cleanExecution.$updatedAt;\n   714→\n   715→    await this.appwriteManager.updateDocument(\n   716→      WORKFLOW_EXECUTION_COLL_ID,\n   717→      executionId,\n   718→      {\n   719→        ...cleanExecution,\n   720→        status,\n   721→      },\n   722→      undefined,\n   723→      'workflows'\n   724→    );\n   725→  }\n   726→\n   727→  private async updateNodeStates(\n   728→    executionId: string,\n   729→    nodeStates: Record<string, NodeState>\n   730→  ) {\n   731→    const executionDoc = await this.appwriteManager.getDocument(\n   732→      WORKFLOW_EXECUTION_COLL_ID,\n   733→      executionId,\n   734→      'workflows'\n   735→    );\n   736→\n   737→    const execution = WorkflowExecutionSchema.parse(executionDoc);\n   738→\n   739→    const cleanExecution = { ...execution };\n   740→    delete cleanExecution.$id;\n   741→    delete cleanExecution.$createdAt;\n   742→    delete cleanExecution.$updatedAt;\n   743→\n   744→    await this.appwriteManager.updateDocument(\n   745→      WORKFLOW_EXECUTION_COLL_ID,\n   746→      executionId,\n   747→      {\n   748→        ...cleanExecution,\n   749→        nodeStates: JSON.stringify(nodeStates),\n   750→      },\n   751→      undefined,\n   752→      'workflows'\n   753→    );\n   754→  }\n   755→\n   756→  // Find node with no previous in connections (node.connections.previous) which is a ref to the\n   757→  // $id of the previous node (if any), otherwise doesn't exist if the trigger is the previous\n   758→  private findStartingNode(nodes: any[]): any {\n   759→    return nodes.find((node) => {\n   760→      const connections = JSON.parse(node.connections || '{}');\n   761→      return !connections.previous || connections.previous === 'trigger';\n   762→    });\n   763→  }\n   764→}\n   765→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"e7b0f98a-f304-4738-af99-c4157aa5e2b9","timestamp":"2025-09-30T20:36:25.297Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/natedamstra/socialaize/functions/WorkflowManager/src/handlers/workflowActions.ts","content":"import {\n  AppwriteManager,\n  WORKFLOW_EXECUTION_COLL_ID,\n  WORKFLOW_NODE_COLL_ID,\n} from './appwriteManager.js';\nimport { Query } from 'node-appwrite';\nimport { PostContainer } from '../types/database/postContainer.js';\nimport {\n  WorkflowExecution,\n  WorkflowExecutionSchema,\n} from '../types/database/workflowExecution.js';\nimport * as aiActions from './actions/aiActions.js';\nimport * as contentActions from './actions/contentActions.js';\nimport * as utilityActions from './actions/utilityActions.js';\nimport {\n  ActionConfig,\n  ConditionSchema,\n  type Condition,\n} from '../schema/actionSchemas.js';\n\ninterface NodeState {\n  status: 'pending' | 'running' | 'completed' | 'failed';\n  output?: any;\n  completedBranches?: string[];\n  error?: {\n    message: string;\n    stack?: string;\n    details?: any;\n  };\n}\n\ninterface NodeConnections {\n  next?: string;\n  cases?: Array<{ condition: string; nodeId: string }>;\n  default?: string;\n  branches?: string[];\n  requiredBranches?: string[];\n}\n\nexport class WorkflowActions {\n  constructor(\n    private appwriteManager: AppwriteManager,\n    private log: (message: string) => void,\n    private error: (message: string) => void,\n    private databaseId: string\n  ) {\n    this.appwriteManager.databaseId = databaseId;\n  }\n\n  private async checkCondition(\n    condition: Condition,\n    postData: any\n  ): Promise<boolean> {\n    this.log(`Checking condition: ${JSON.stringify(condition, null, 4)}`);\n    const postContainer =\n      typeof postData === 'string' ? JSON.parse(postData) : postData;\n    const genericPost =\n      typeof postContainer.postData === 'string'\n        ? JSON.parse(postContainer.postData)\n        : postContainer.postData;\n    this.log(`Generic post: ${JSON.stringify(genericPost, null, 4)}`);\n    switch (condition.type) {\n      case 'post_type_is':\n        return genericPost.postType === condition.value;\n      case 'platform_is':\n        return genericPost.platform === condition.value;\n      case 'content_contains':\n        return genericPost.text?.includes(condition.value) ?? false;\n      case 'content_matches':\n        try {\n          const regex = new RegExp(condition.value);\n          return (\n            regex.test(genericPost.text || '') ||\n            genericPost.text === condition.value\n          );\n        } catch {\n          return false;\n        }\n      case 'hashtags_contain':\n        this.log(\n          `Checking hashtags_contain: ${condition.value} | extraData: ${JSON.stringify(\n            genericPost.extraData?.hashtags,\n            null,\n            2\n          )} | text: \"${genericPost.text}\"`\n        );\n        \n        // Try to use extraData.hashtags first (if populated by post converters)\n        let hashtags = genericPost.extraData?.hashtags;\n        \n        // If no hashtags in extraData, parse them from text using ztextutils as fallback\n        if (!Array.isArray(hashtags) || hashtags.length === 0) {\n          this.log('No hashtags in extraData, parsing from text with ztextutils');\n          const { defaultParser } = await import('ztextutils');\n          const textData = defaultParser.parse(genericPost.text || '');\n          hashtags = textData.hashtags;\n        }\n        \n        this.log(`Using hashtags: ${JSON.stringify(hashtags)}`);\n        \n        const hasMatch =\n          Array.isArray(hashtags) &&\n          hashtags.some((hashtag: string) => {\n            const result = hashtag\n              .toLowerCase()\n              .includes(condition.value.toLowerCase());\n            this.log(`  Checking \"${hashtag}\" contains \"${condition.value}\": ${result}`);\n            return result;\n          });\n\n        this.log(`Final result: ${hasMatch}`);\n        return hasMatch;\n      case 'video_duration':\n        this.log(`Checking video_duration condition: ${condition.operator} ${condition.value}`);\n\n        // If this is a carousel post, video_duration is not applicable\n        if (genericPost.postType === 'carousel' || genericPost.postType === 'caption-image' || genericPost.postType === 'file' || genericPost.postType === 'text') {\n          this.log('Post is a carousel; video_duration condition not applicable. Condition fails.');\n          return false;\n        }\n\n        // Try to get duration from extraData.duration first\n        let videoDuration = null;\n\n        if (genericPost.extraData) {\n          try {\n            const extraData = typeof genericPost.extraData === 'string'\n              ? JSON.parse(genericPost.extraData)\n              : genericPost.extraData;\n            videoDuration = extraData.duration;\n          } catch (e) {\n            this.log(`Failed to parse extraData: ${e}`);\n          }\n        }\n\n        // If not found in extraData, try platformMetrics\n        if (videoDuration === null && genericPost.platformMetrics) {\n          try {\n            const platformMetrics = typeof genericPost.platformMetrics === 'string'\n              ? JSON.parse(genericPost.platformMetrics)\n              : genericPost.platformMetrics;\n            videoDuration = platformMetrics.duration;\n          } catch (e) {\n            this.log(`Failed to parse platformMetrics: ${e}`);\n          }\n        }\n\n        // If no duration found in existing data, check if post contains video before extracting\n        if (videoDuration === null || videoDuration === undefined) {\n          const hasVideo = Array.isArray(genericPost.media)\n            ? genericPost.media.some((m: any) => m?.type === 'video')\n            : false;\n          if (!hasVideo) {\n            this.log('Post is not a video; skipping duration extraction. Condition fails.');\n            return false;\n          }\n\n          this.log('No video duration found in existing data, attempting to extract from video files');\n          const { VideoUtils } = await import('../utils/videoUtils.js');\n          videoDuration = await VideoUtils.extractVideoDurationFromPost(\n            genericPost,\n            this.appwriteManager,\n            this.log\n          );\n\n          if (videoDuration === null || videoDuration === undefined) {\n            this.log('No video duration found - video likely still being processed by FileMetadataHandler');\n            this.log('Retrying with delays to allow file processing to complete...');\n\n            // Retry with increasing delays to wait for FileMetadataHandler\n            const maxAttempts = 5;\n            const baseDelayMs = 3000; // Start with 3 seconds\n\n            for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n              const delayMs = baseDelayMs * attempt; // Increasing delay: 3s, 6s, 9s, 12s, 15s\n              this.log(`Retry attempt ${attempt}/${maxAttempts} - waiting ${delayMs/1000}s for video processing...`);\n\n              await new Promise(resolve => setTimeout(resolve, delayMs));\n\n              try {\n                videoDuration = await VideoUtils.extractVideoDurationFromPost(\n                  genericPost,\n                  this.appwriteManager,\n                  this.log\n                );\n\n                if (videoDuration !== null && videoDuration !== undefined) {\n                  this.log(`Video duration found on attempt ${attempt}: ${videoDuration} seconds`);\n                  break;\n                }\n              } catch (retryError) {\n                this.log(`Retry attempt ${attempt} failed: ${retryError}`);\n              }\n            }\n\n            // Final check after all retries\n            if (videoDuration === null || videoDuration === undefined) {\n              this.log('No video duration found after all retry attempts - condition fails');\n              return false;\n            }\n          }\n\n          this.log(`Extracted video duration: ${videoDuration} seconds`);\n        } else {\n          this.log(`Found video duration: ${videoDuration} seconds`);\n        }\n\n        const durationValue = Number(videoDuration);\n        const conditionValue = Number(condition.value);\n\n        if (isNaN(durationValue) || isNaN(conditionValue)) {\n          this.log('Invalid duration values, condition fails');\n          return false;\n        }\n\n        const result = condition.operator === 'greater_than'\n          ? durationValue > conditionValue\n          : durationValue < conditionValue;\n\n        this.log(`Video duration check: ${durationValue} ${condition.operator === 'greater_than' ? '>' : '<'} ${conditionValue} = ${result}`);\n        return result;\n      default:\n        return true;\n    }\n  }\n\n  async handleWorkflowAction(\n    action: string,\n    data: {\n      postData: any;\n      config: ActionConfig;\n    }\n  ) {\n    try {\n      this.log(`Handling action: ${action} | ${JSON.stringify(data, null, 4)}`);\n      // Check node's conditions (supports logical AND/OR tokens between conditions)\n      if (data.config?.conditions && data.config.conditions.length > 0) {\n        let combinedDefined = false;\n        let combined = true;\n        let currentOp: 'AND' | 'OR' = 'AND';\n\n        const tokens = data.config.conditions;\n        for (let i = 0; i < tokens.length; i++) {\n          const parsed = ConditionSchema.safeParse(tokens[i]);\n          if (!parsed.success) {\n            this.log(`Condition token ${i} failed schema parse; skipping.`);\n            continue;\n          }\n\n          const token = parsed.data as any;\n          if (token.type === 'AND' || token.type === 'OR') {\n            // Set operator only if a following condition exists\n            if (i < tokens.length - 1) {\n              currentOp = token.type;\n            } else {\n              this.log(`Trailing logical operator (${token.type}) without following condition; ignoring.`);\n            }\n            continue;\n          }\n\n          // Evaluate a real condition\n          const met = await this.checkCondition(token, data.postData);\n          this.log(`Condition ${i} (${token.type}) result: ${met}`);\n\n          if (!combinedDefined) {\n            combined = met;\n            combinedDefined = true;\n          } else {\n            combined = currentOp === 'AND' ? combined && met : combined || met;\n          }\n\n          // After consuming a condition, default operator stays as last set until changed by next token\n        }\n\n        if (!combinedDefined) {\n          // No valid condition found; allow node to proceed by default\n          this.log('No valid conditions found; proceeding by default.');\n        } else if (!combined) {\n          this.log('Node conditions not met, skipping action');\n          return data.postData; // Return unchanged data if conditions aren't met\n        }\n      }\n\n      switch (action) {\n        // Content Publishing\n        case 'publish_content':\n          return await contentActions.handlePublishContent(\n            {\n              postData: data.postData,\n              config: data.config,\n            },\n            this.appwriteManager\n          );\n\n        // AI Actions\n        case 'ai_rewrite':\n        case 'ai_gen_content':\n        case 'ai_generate_content':\n          return await aiActions.handleAiRewrite(\n            {\n              postData: data.postData,\n              config: data.config,\n            },\n            this.appwriteManager\n          );\n        case 'ai_translate':\n          return await aiActions.handleAiTranslate(\n            {\n              postData: data.postData,\n              config: data.config,\n            },\n            this.appwriteManager\n          );\n        case 'ai_summarize':\n          return await aiActions.handleAiSummarize(\n            {\n              postData: data.postData,\n              config: data.config,\n            },\n            this.appwriteManager\n          );\n        case 'ai_add_hashtags':\n        case 'ai_add_tags':\n        case 'ai_gen_tags':\n          return await aiActions.handleAiAddHashtags(\n            {\n              postData: data.postData,\n              config: data.config,\n            },\n            this.appwriteManager\n          );\n        case 'ai_gen_title':\n        case 'ai_add_title':\n          return await aiActions.handleAiGenerateTitle(\n            {\n              postData: data.postData,\n              config: data.config,\n            },\n            this.appwriteManager\n          );\n\n        // Basic Content Modifications\n        case 'set_title':\n          return await contentActions.handleSetTitle(\n            {\n              postData: data.postData,\n              config: data.config,\n            },\n            this.appwriteManager\n          );\n        case 'set_content':\n          return await contentActions.handleSetContent(\n            {\n              postData: data.postData,\n              config: data.config,\n            },\n            this.appwriteManager\n          );\n        case 'add_hashtags':\n          return await contentActions.handleAddHashtags(\n            {\n              postData: data.postData,\n              config: data.config,\n            },\n            this.appwriteManager\n          );\n        case 'schedule_post':\n          return await contentActions.handleSchedulePost(\n            {\n              postData: data.postData,\n              config: data.config,\n            },\n            this.appwriteManager\n          );\n\n        // Utility Actions\n        case 'wait':\n          return await utilityActions.handleWait(\n            {\n              postData: data.postData,\n              config: data.config,\n            },\n            this.appwriteManager\n          );\n        case 'fetch_content':\n          return await utilityActions.handleFetchContent(\n            {\n              postData: data.postData,\n              config: data.config,\n            },\n            this.appwriteManager\n          );\n\n        default:\n          this.error(`Unknown action: ${action}`);\n          throw new Error(`Unknown action: ${action}`);\n      }\n    } catch (error) {\n      const errorDetails = {\n        message: error instanceof Error ? error.message : 'Unknown error',\n        stack: error instanceof Error ? error.stack : undefined,\n        details: error,\n      };\n      this.error(\n        `Error in handleWorkflowAction: ${JSON.stringify(errorDetails, null, 2)}`\n      );\n      throw error;\n    }\n  }\n\n  async handleNewPost(\n    workflowExecution: WorkflowExecution,\n    workflowId: string\n  ) {\n    this.log(`Processing workflow execution: ${workflowExecution.$id}`);\n    let processedData: any = {};\n    const nodeStates: Record<string, NodeState> = {};\n\n    try {\n      // Initialize or get existing node states\n      const existingNodeStates = workflowExecution.nodeStates\n        ? JSON.parse(workflowExecution.nodeStates)\n        : {};\n      Object.assign(nodeStates, existingNodeStates);\n\n      await this.updateExecutionStatus(workflowExecution.$id!, 'running');\n\n      const postData: PostContainer = workflowExecution.workflowData\n        ? JSON.parse(workflowExecution.workflowData).post\n        : {};\n      processedData = postData;\n\n      // Get all nodes for this workflow\n      const nodes = await this.appwriteManager.listDocuments(\n        WORKFLOW_NODE_COLL_ID,\n        [Query.equal('workflowId', workflowId), Query.limit(1000)],\n        'workflows'\n      );\n\n      if (!nodes.documents.length) {\n        throw new Error('No nodes found in workflow');\n      }\n\n      let currentNode = this.findStartingNode(nodes.documents);\n      if (!currentNode) {\n        throw new Error('No starting node found in workflow');\n      }\n\n      while (currentNode) {\n        const nodeId = currentNode.$id;\n        const config = JSON.parse(currentNode.config || '{}');\n\n        // Defensive transformation: convert null conditions to undefined\n        if (config.conditions === null) {\n          config.conditions = undefined;\n        }\n\n        const connections: NodeConnections = JSON.parse(\n          currentNode.connections || '{}'\n        );\n\n        try {\n          nodeStates[nodeId] = { status: 'running' };\n          await this.updateNodeStates(workflowExecution.$id!, nodeStates);\n          this.log(`Processing node ${nodeId} -- ${currentNode.nodeType}`);\n\n          switch (currentNode.nodeType) {\n            case 'ACTION': {\n              if (!currentNode.action) {\n                throw new Error('Action node requires an action type');\n              }\n\n              this.log(\n                `Processing action node ${nodeId} -- ${currentNode.action}`\n              );\n              processedData = await this.handleWorkflowAction(\n                currentNode.action,\n                {\n                  postData: processedData,\n                  config,\n                }\n              );\n              this.log(\n                `Action node ${nodeId} completed, processedData: ${JSON.stringify(processedData, null, 4)}`\n              );\n\n              nodeStates[nodeId] = {\n                status: 'completed',\n                output: processedData,\n              };\n\n              currentNode = connections.next\n                ? nodes.documents.find((n) => n.$id === connections.next)\n                : null;\n              this.log(\n                `Current node (after finding next node): ${JSON.stringify(\n                  currentNode,\n                  null,\n                  4\n                )}`\n              );\n              break;\n            }\n\n            case 'SWITCH': {\n              let nextNodeId = null;\n\n              // Check each case condition\n              if (connections.cases) {\n                for (const caseItem of connections.cases) {\n                  const conditionMet = await this.checkCondition(\n                    JSON.parse(caseItem.condition),\n                    processedData\n                  );\n                  if (conditionMet) {\n                    nextNodeId = caseItem.nodeId;\n                    break;\n                  }\n                }\n              }\n\n              // If no case matched, use default path\n              if (!nextNodeId && connections.default) {\n                nextNodeId = connections.default;\n              }\n\n              nodeStates[nodeId] = {\n                status: 'completed',\n                output: { nextNode: nextNodeId },\n              };\n\n              currentNode = nextNodeId\n                ? nodes.documents.find(\n                    (n) =>\n                      n.$id === nextNodeId ||\n                      nodeId === JSON.parse(n.connections).previous\n                  )\n                : null;\n              this.log(\n                `Current node (after finding next node): ${JSON.stringify(\n                  currentNode,\n                  null,\n                  4\n                )}`\n              );\n              break;\n            }\n\n            case 'PARALLEL': {\n              if (!connections.branches?.length) {\n                throw new Error('Parallel node requires branches');\n              }\n\n              // Process all branches in parallel\n              const branchNodes = connections.branches.map((branchId) =>\n                nodes.documents.find((n) => n.$id === branchId)\n              );\n\n              const branchResults = await Promise.all(\n                branchNodes.map((startNode) =>\n                  this.processNodeBranch(\n                    startNode,\n                    nodes.documents,\n                    processedData,\n                    nodeStates\n                  )\n                )\n              );\n\n              // Merge results from all branches\n              processedData = branchResults.reduce(\n                (acc, result) => ({\n                  ...acc,\n                  ...result,\n                }),\n                processedData\n              );\n\n              // Move to next node if all required branches completed\n              currentNode = connections.next\n                ? nodes.documents.find((n) => n.$id === connections.next)\n                : null;\n              this.log(\n                `Current node (after finding next node): ${JSON.stringify(\n                  currentNode,\n                  null,\n                  4\n                )}`\n              );\n              break;\n            }\n\n            default:\n              throw new Error(`Unknown node type: ${currentNode.nodeType}`);\n          }\n\n          await this.updateNodeStates(workflowExecution.$id!, nodeStates);\n        } catch (error) {\n          const errorDetails = {\n            message: error instanceof Error ? error.message : 'Unknown error',\n            stack: error instanceof Error ? error.stack : undefined,\n            details: error,\n          };\n\n          this.error(\n            `Error processing node ${nodeId}: ${JSON.stringify(errorDetails, null, 2)}`\n          );\n\n          nodeStates[nodeId] = {\n            status: 'failed',\n            error: errorDetails,\n          };\n\n          await this.updateNodeStates(workflowExecution.$id!, nodeStates);\n          await this.updateExecutionStatus(workflowExecution.$id!, 'failed');\n          throw error;\n        }\n      }\n\n      await this.updateExecutionStatus(workflowExecution.$id!, 'completed');\n      return processedData;\n    } catch (error) {\n      const errorDetails = {\n        message: error instanceof Error ? error.message : 'Unknown error',\n        stack: error instanceof Error ? error.stack : undefined,\n        details: error,\n      };\n\n      this.error(\n        `Error in workflow execution: ${JSON.stringify(errorDetails, null, 2)}`\n      );\n      await this.updateExecutionStatus(workflowExecution.$id!, 'failed');\n      throw error;\n    }\n  }\n\n  private async processNodeBranch(\n    startNode: any,\n    allNodes: any[],\n    initialData: any,\n    nodeStates: Record<string, NodeState>\n  ) {\n    let currentNode = startNode;\n    let processedData = initialData;\n\n    while (currentNode) {\n      const nodeId = currentNode.$id;\n      const config = JSON.parse(currentNode.config || '{}');\n      const connections: NodeConnections = JSON.parse(\n        currentNode.connections || '{}'\n      );\n\n      try {\n        if (currentNode.nodeType === 'ACTION' && currentNode.action) {\n          processedData = await this.handleWorkflowAction(currentNode.action, {\n            postData: processedData,\n            config,\n          });\n\n          nodeStates[nodeId] = {\n            status: 'completed',\n            output: processedData,\n          };\n        }\n\n        currentNode = connections.next\n          ? allNodes.find(\n              (n) =>\n                n.$id === connections.next ||\n                nodeId === JSON.parse(n.connections).previous\n            )\n          : null;\n        this.log(`Current node: ${JSON.stringify(currentNode, null, 4)}`);\n        if (Array.isArray(currentNode)) {\n          currentNode = currentNode.find((n) => n.$id === connections.next);\n        }\n      } catch (error) {\n        const errorDetails = {\n          message: error instanceof Error ? error.message : 'Unknown error',\n          stack: error instanceof Error ? error.stack : undefined,\n          details: error,\n        };\n\n        this.error(\n          `Error processing branch node ${nodeId}: ${JSON.stringify(errorDetails, null, 2)}`\n        );\n\n        nodeStates[nodeId] = {\n          status: 'failed',\n          error: errorDetails,\n        };\n\n        throw error;\n      }\n    }\n\n    return processedData;\n  }\n\n  private async updateExecutionStatus(\n    executionId: string,\n    status: 'running' | 'completed' | 'failed'\n  ) {\n    const executionDoc = await this.appwriteManager.getDocument(\n      WORKFLOW_EXECUTION_COLL_ID,\n      executionId,\n      'workflows'\n    );\n\n    const cleanExecution = WorkflowExecutionSchema.parse(executionDoc);\n    delete cleanExecution.$id;\n    delete cleanExecution.$createdAt;\n    delete cleanExecution.$updatedAt;\n\n    await this.appwriteManager.updateDocument(\n      WORKFLOW_EXECUTION_COLL_ID,\n      executionId,\n      {\n        ...cleanExecution,\n        status,\n      },\n      undefined,\n      'workflows'\n    );\n  }\n\n  private async updateNodeStates(\n    executionId: string,\n    nodeStates: Record<string, NodeState>\n  ) {\n    const executionDoc = await this.appwriteManager.getDocument(\n      WORKFLOW_EXECUTION_COLL_ID,\n      executionId,\n      'workflows'\n    );\n\n    const execution = WorkflowExecutionSchema.parse(executionDoc);\n\n    const cleanExecution = { ...execution };\n    delete cleanExecution.$id;\n    delete cleanExecution.$createdAt;\n    delete cleanExecution.$updatedAt;\n\n    await this.appwriteManager.updateDocument(\n      WORKFLOW_EXECUTION_COLL_ID,\n      executionId,\n      {\n        ...cleanExecution,\n        nodeStates: JSON.stringify(nodeStates),\n      },\n      undefined,\n      'workflows'\n    );\n  }\n\n  // Find node with no previous in connections (node.connections.previous) which is a ref to the\n  // $id of the previous node (if any), otherwise doesn't exist if the trigger is the previous\n  private findStartingNode(nodes: any[]): any {\n    return nodes.find((node) => {\n      const connections = JSON.parse(node.connections || '{}');\n      return !connections.previous || connections.previous === 'trigger';\n    });\n  }\n}\n","numLines":765,"startLine":1,"totalLines":765}}}
{"parentUuid":"e7b0f98a-f304-4738-af99-c4157aa5e2b9","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01WhNNVqm8c6UaGatFSB8i6z","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"thinking","thinking":"Perfect! Now I have all the information I need. Let me analyze the flow and create comprehensive documentation. Let me update the todo and start writing the new document.\n\nKey findings:\n1. **Frontend (src/utils/workflowUtils.ts + src/schemas/workflows/actionSchemas.ts)**:\n   - Defines all action types available in the UI\n   - Creates default configurations for each action\n   - Uses Zod schemas for validation\n   - Has some duplicate actions (ai_add_title vs ai_gen_title, ai_add_tags vs ai_gen_tags)\n   - ai_add_tags has incomplete config (missing maxTags and categories)\n\n2. **WorkflowManager (functions/WorkflowManager/)**:\n   - Receives workflow execution events\n   - Routes actions to appropriate handlers\n   - Maps multiple action names to same handler:\n     - ai_rewrite, ai_gen_content, ai_generate_content → handleAiRewrite\n     - ai_add_title, ai_gen_title → handleAiGenerateTitle\n     - ai_add_tags, ai_gen_tags, ai_add_hashtags → handleAiAddHashtags\n   - Creates JWT for authentication\n   - Sends requests to AI_API with specific field mappings:\n     - translate: sends \"target_language\" field\n     - All actions: wraps config in ActionConfig with action type\n\n3. **AI_API (functions/AI_API/)**:\n   - Receives ActionRequest with action type\n   - Routes to AIWorkflow\n   - Uses LlamaIndex workflows with tool calling\n   - Returns ActionResponse with ActionResult structure:\n     - content: processed content\n     - title: optional title (only for specific actions)\n   - Does NOT return tags array directly (inconsistency!)\n\nInconsistencies found:\n- Frontend ai_gen_tags expects tags in separate field, but AI_API returns content+title\n- WorkflowManager expects tags in response.result.tags but AI_API doesn't provide that\n\n\n- Routing for content generation seems misaligned with handler functionality\n- Duplicate action types create potential configuration and routing complexity\n\nI notice several architectural misalignments in the workflow routing and action handling. The content generation routing appears problematic, with ai_gen_content incorrectly mapped to handleAiRewrite. This suggests a deeper issue with action type consistency and handler assignment. The presence of duplicate actions with varying configurations further complicates the system's design, potentially leading to unexpected behavior in workflow execution.","signature":"EqcRCkYICBgCKkD5Zoot88hXUM2B3TSk1MSU0b9sNDK8L/fpsS8jzZlyjs8xYPy1YsaiwmY8se4BOc0riVM8P+s3DDEG88UHY4ZnEgzFe8tLFAZsmH79zvwaDD3XNWTlrklDYrx4CiIwNJ2Myr/v0HlYOLkbQsQW/nWeKm/ca5HNKa00z14/jb65ydQCzEEOUXKc4bLCck/fKo4QCVTtdpSWtfjU6fLDJ7O/2UPN5j6AgVdTkl02Hq7wTkRjPifVqfxW9V8Xp3r4hQFCeChOkWa5okH4kTsvdpm8a6U2sYeEY9bYqjflQ4W7aCPFOxEPDX09v+6qoAiAj7WOYiGaR5u0RbXACqgdbrtqZ/KdTdvX/eJVzRJnvlY/lVZ+a0m0Gyqy87NmOl3MVKOmuHz3Jq3X8sI6R86O6F1Vbxy8V4LXi8gPwj6ZHwROPiDFNYv2UBrMqtpKDnZmbgAnaNmykBJ8WcTXTiiGVhzJJtoXNJn02qNpEPwmMVKqM8tbIU8v13/woJwfG+3eCkmCE5zBp99C14hw75TReICRUROo1Qf2vappk3kYw2rHSNsfJGRs2hCAx71e7Rcu66Q6VOawqbZ6agiMUvmmjQRM9glBFnsgdY03wqD0dY73GD/6eUSeBCSAi2nEIhYOudVMSgrzQz6EZ58fNdg3f1S6DpVCQhddSnaJrRV2lf0TN6CVFt469SkxP/e/n6lojhgGR9XZofoyZxsVk8Lm/1CqA2NDwVJIuCZCaIC7QWEw1ujV1Pg53gk9skNF3BkboPfmQEk3HsqpBJQbG95QXcbhZ89c6TPQpjrtzaqUntmlzGSKkk+1fNuCZ98QzXfASniIJuLfPryL3qAqvIZEv0Pqp6ISLyPG6VLtLe92ksQjR8yFrlBkXocxUTMoLETdJx7YmMVnc0SA/0+HQ31JFro+T7XY+6qN0H9RGgSyvolH9bbLrGhDgO9McpRIoB4b+UafOHDbfIt9ZGKZJWGTKo0HwyMIMPNsbYZ8jiPmCnsAmkbW4O0OHB1XW8nBNswL1ABbc14l6Yp338IQ0ul8JhCYZBqABuOpzMgTjafyukvr5/awrtOCGDAX5RvAGkMv9iEuuML4qAYU9UxanS2AIFvT9binBFz7YS88EivVF4AdIDK1+UR89x8BNQBNLzOATw+xQSp03SpfK/+KK0T7dTpThulldQemdVb0A8cKRYlCuhPtqECP0+E3GuzIPQpyGH24k24txS2afxTxQV3z15bbTeFQSHOd5cGPTgEukVwr53Nj6+5xzqmPJpTxfWdKkWrbaCIaaO0B7zVwR/GtpP5TGMEI5Jv4YrFNi6yIAkR70R1t5CIQY8EPyd8W5H8augqGyLZS6AQ1psgdLrMN4oK2PpAHx7sOb1ahwwOh65XtRCfXctXw/m1tLWvmhty8sPRARF7+nMEMB89FSA7orzI31SphCE2gTwgsuSx8c9EXpnjjRtaplOfChx3Fc3enQQvpxc8UXIzpiJ9LiOHFNEdhpaG9ZLQnPbVeITarJHHz8YThDBJEd6pryV+hNYxPPI262hLYMzIGjxcL8bNc1JaZs3tm4PDGKOCqUwy9tYlWiP+rk2GhohPJ4vCyAubIJLocy/oUVM+d+H4UmJEuf2w+Eg0AaPwRb/HgNoDVUzbccSJd6eTI2dxt/PqN7AYDLyuoDND4VUPDTmX8nRHWJiDDrZxWSYukkN6AfQOag4RBhSTAstRy6AMTwMWi32xRiwQJGii2q9sgn3wdxeCD3Mf8MaKYO+gFEbG7PWSDLPrg8mp71GpuiiIlnPW36DnKLYD1ERXK3hOfhVvzuapo2geVVzzjp86IpKKhJAwDQo1iZ8YUulaC6kU2b1m+Zl+ncUYbXIuDcTPG+9+OFDeSZIpsi8wH5F6pp7NJ25ucGwMi0h6fIcjo5P/n2N71ErRuZ0GyzgdUZkKUs8P2zLKEls38kuSu2X/NSbXWZ+L+oX6J0Db6OWaS55tyx9Hi4FAsPNFH3NCIhEk9hnp6wuwGvADJTcaHmEnI6CJpK2i/rmCA9i8To7aPdP9g0prmpdsFD5q5tRfdsb74DLq+6xzv/RCt9DBOxXzZmFmGBYCFgQgps0Wk9IllPUK4neZEKa022XYoeiQPmKkUZOjIwGQOyas0QzZCc7mg0PpZEJ+z1F/kHqkTCTF4JHamJu/oaPh0wCVuVQ/kJvsmon/7bMOUcI+mGch8q5YILJMt14IMsUSUxpXeBvTJn+XRsK7ADHI3Is/suNgiCWZ1STjXQFmVVa+4Fe9wuhOMIRuwBaVeKkYjfdfjFNKKMS46e5Hl8IFaCYyKk3ct4HSUsCfVd3GQcbEruKUgUPXFIFB7E6pA5I8K+p4mS/gOmVRgjwWydhBHAFAtVXQjtEsgylnYPMqZcAIULQw4GZcX1S/DFnfyzm/KOXcob2gEzKs1nLF+IAOhMsdZ8pEWgLY/KG5/87wO7eq2wllaHkWKE/bbPx/Yg4FnriWIwnRC1vSwWY9eop2kZgujwwjbkwP3hU/wWv/ETUGTVadtvOXLhrcXN1KeCcld0iYE2x7GNHPA8ldbLdsvFFCIFdl9q30+xwC2Az3fcMi/LCFD23lxfWLfDybd92s/kgEcHO5k+wO0yMo47zG0owWBeBI3F7ycnjE8MoH/R2o1j6G+xhRsw9/x6O3+UDTLBTycK1X7y88oLaBrb0EItCfyzHB1Iq1HepKIYArt60+Ht3ao3HP38cDxnhZpw9F/pyTLWKE6clItH/HVclBtoGJoMpLTk3bi6mahzmnU8qrbgAClWw4P1RamQ1r2QlainB87V8DE5Wzuqy1OfpUn4LQC2CoVJbqbfa6NoNDZXFYO8+tDECobt+pVwKUAcLwpIZOErEUYZ+3GhRYI7X8nwAn2kQZw1uiNIwEEdsArHuSeXyLvkCsYyZ0YusztrU1aV5ojjnL0Zub2X1axr6yq4hgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":9032,"cache_read_input_tokens":67877,"cache_creation":{"ephemeral_5m_input_tokens":9032,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CTfE7XStCF4dGaj4NMXd9","type":"assistant","uuid":"1ea6c846-b449-4a92-a707-a6534eb3725e","timestamp":"2025-09-30T20:36:45.537Z"}
{"parentUuid":"1ea6c846-b449-4a92-a707-a6534eb3725e","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01WhNNVqm8c6UaGatFSB8i6z","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_01B6dFGCtzXtE9LbSGq2ZvAf","name":"TodoWrite","input":{"todos":[{"content":"Read frontend workflow utilities to understand action nodes and configs","activeForm":"Reading frontend workflow utilities","status":"completed"},{"content":"Read WorkflowManager AI action handlers","activeForm":"Reading WorkflowManager AI action handlers","status":"completed"},{"content":"Read AI_API implementation and schemas","activeForm":"Reading AI_API implementation and schemas","status":"completed"},{"content":"Analyze schemas and data flow between all three layers","activeForm":"Analyzing schemas and data flow","status":"completed"},{"content":"Create comprehensive rewritten documentation with visual diagrams","activeForm":"Creating comprehensive documentation","status":"in_progress"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":9032,"cache_read_input_tokens":67877,"cache_creation":{"ephemeral_5m_input_tokens":9032,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CTfE7XStCF4dGaj4NMXd9","type":"assistant","uuid":"343fa065-2374-469c-ad97-418826cfb470","timestamp":"2025-09-30T20:36:45.714Z"}
{"parentUuid":"343fa065-2374-469c-ad97-418826cfb470","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01WhNNVqm8c6UaGatFSB8i6z","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_014VGfEgxrgZtipbiH4w4YTD","name":"Write","input":{"file_path":"/Users/natedamstra/socialaize/AI_ACTIONS_REFERENCE.md","content":"# AI Actions Reference - Complete System Architecture\n\n## Overview\n\nThis document provides a comprehensive view of AI actions across the Socialaize platform, explaining how they flow from the frontend through the WorkflowManager to the AI_API and back.\n\n## System Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                           FRONTEND (Astro/Vue)                           │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │  User Interface - Workflow Builder                                 │ │\n│  │  - Action selection from ACTION_CATEGORIES                         │ │\n│  │  - Configuration forms for each action                             │ │\n│  │  - Default configs from getDefaultConfig()                         │ │\n│  │  - Zod validation via ActionConfigSchema                          │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n│                                   │                                      │\n│                                   │ Creates WorkflowNode with:          │\n│                                   │ - action: string                    │\n│                                   │ - config: ActionConfig              │\n│                                   ▼                                      │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    │ Saved to Appwrite DB\n                                    │\n┌─────────────────────────────────────────────────────────────────────────┐\n│                    WORKFLOW EXECUTION (Appwrite Event)                   │\n│                                                                           │\n│  User creates/publishes PostContainer → WorkflowExecution created       │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    │ Triggers function\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│                  WORKFLOWMANAGER (Node.js Function)                      │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │  WorkflowActions.handleWorkflowAction()                            │ │\n│  │  - Checks node conditions                                          │ │\n│  │  - Routes to appropriate handler based on action type             │ │\n│  │  - Extracts genericPost from postContainer                         │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n│                                   │                                      │\n│  ┌────────────────────────────────┴───────────────────────────────────┐ │\n│  │  AI Action Handlers (aiActions.ts)                                 │ │\n│  │  - handleAiRewrite()       - handleAiTranslate()                   │ │\n│  │  - handleAiSummarize()     - handleAiGenerateTitle()               │ │\n│  │  - handleAiAddHashtags()                                          │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n│                                   │                                      │\n│                                   │ 1. Creates JWT                       │\n│                                   │ 2. Builds ActionConfig               │\n│                                   │ 3. Calls AI_API                     │\n│                                   ▼                                      │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    │ HTTP POST to /action\n                                    │\n┌─────────────────────────────────────────────────────────────────────────┐\n│                      AI_API (Python FastAPI Function)                    │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │  main.py → handle_action()                                         │ │\n│  │  - Validates ActionRequest                                         │ │\n│  │  - Authenticates user via JWT                                      │ │\n│  │  - Validates credits (BillingService)                              │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n│                                   │                                      │\n│  ┌────────────────────────────────▼───────────────────────────────────┐ │\n│  │  AIService.process_action()                                        │ │\n│  │  - Estimates token usage                                           │ │\n│  │  - Selects appropriate LLM (nano/smart)                            │ │\n│  │  - Creates AIWorkflow instance                                     │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n│                                   │                                      │\n│  ┌────────────────────────────────▼───────────────────────────────────┐ │\n│  │  AIWorkflow (LlamaIndex Workflow)                                  │ │\n│  │  1. ContentAnalysisEvent → analyze_content()                       │ │\n│  │  2. ToolExecutionEvent → execute_tools()                           │ │\n│  │  3. OptimizationEvent → optimize_content()                         │ │\n│  │  4. StopEvent → returns result                                     │ │\n│  │                                                                      │ │\n│  │  Uses function calling with tools:                                 │ │\n│  │  - analyze_sentiment, check_constraints                            │ │\n│  │  - optimize_platform, validate_quality                             │ │\n│  │  - complete_optimization                                           │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n│                                   │                                      │\n│                                   │ Returns ActionResponse:             │\n│                                   │ {                                   │\n│                                   │   result: {                         │\n│                                   │     content: string,                │\n│                                   │     title: string | null            │\n│                                   │   },                                │\n│                                   │   action: string,                   │\n│                                   │   model_used: string,               │\n│                                   │   tokens: TokenUsage,               │\n│                                   │   ...                               │\n│                                   │ }                                   │\n│                                   ▼                                      │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    │ Response flows back\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│                  WORKFLOWMANAGER (Processes Response)                    │\n│  - Extracts content and title from response.result                      │\n│  - Updates genericPost.text and/or genericPost.title                    │\n│  - Returns updated PostContainer                                        │\n│  - Proceeds to next workflow node                                       │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 1. Frontend Layer\n\n### Location\n- `/src/utils/workflowUtils.ts` - Action options and default configs\n- `/src/schemas/workflows/actionSchemas.ts` - Zod validation schemas\n\n### Available AI Actions in UI\n\n| Action Value | Display Label | Status | Config Fields |\n|--------------|--------------|--------|---------------|\n| `ai_rewrite` | \"AI Rewrite Content\" | ✅ Enabled | style, tone, length, content, user_instructions |\n| `ai_translate` | \"AI Translate Content\" | ✅ Enabled | language, preserve_formatting, content, user_instructions |\n| `ai_summarize` | \"AI Summarize Content\" | ❌ Disabled | max_length, format, content, user_instructions |\n| `ai_gen_title` | \"AI Generate Title\" | ✅ Enabled | style, max_length, content, user_instructions |\n| `ai_add_title` | \"AI Add Title\" | ✅ Enabled | style, max_length, content, user_instructions |\n| `ai_gen_tags` | \"AI Generate Tags\" | ✅ Enabled | maxTags, categories, content, user_instructions |\n| `ai_add_tags` | \"AI Generate Tags\" | ✅ Enabled | content, user_instructions (⚠️ missing maxTags, categories) |\n| `ai_gen_content` | \"AI Generate Content\" | ✅ Enabled | length, tone, style, format, content, user_instructions |\n\n### Schema Definitions\n\nAll action schemas extend `BaseActionSchema`:\n```typescript\nBaseActionSchema {\n  user_instructions?: string\n  conditions?: Condition[]  // Left-to-right evaluation with AND/OR tokens\n}\n```\n\n#### AI Action Schemas\n\n**AIRewriteActionSchema**\n```typescript\n{\n  title?: string | null\n  content: string\n  style: \"professional\" | \"casual\" | \"formal\" | \"friendly\" | \"match\"\n  tone: \"positive\" | \"neutral\" | \"negative\" | \"match\"\n  length: \"shorter\" | \"same\" | \"longer\"\n}\n```\n\n**TranslateActionSchema**\n```typescript\n{\n  content: string\n  language: string           // ISO language code (e.g., \"en\", \"es\", \"fr\")\n  preserve_formatting: boolean\n}\n```\n\n**AISummarizeActionSchema**\n```typescript\n{\n  title?: string | null\n  content: string\n  max_length?: number\n  format: \"bullet_points\" | \"paragraph\" | \"key_points\"\n}\n```\n\n**AIGenerateContentActionSchema**\n```typescript\n{\n  title?: string | null\n  content: string\n  length: \"shorter\" | \"same\" | \"longer\"\n  tone: \"positive\" | \"neutral\" | \"negative\" | \"match\"\n  style: \"professional\" | \"casual\" | \"formal\" | \"friendly\" | \"match\"\n}\n```\n\n**AIAddTitleActionSchema**\n```typescript\n{\n  title?: string | null\n  content: string\n  style?: \"professional\" | \"casual\" | \"formal\" | \"friendly\" | \"match\"\n  max_length?: number\n}\n```\n\n**AIAddTagsActionSchema**\n```typescript\n{\n  title?: string | null\n  content: string\n  max_tags?: number\n  categories?: string[]\n}\n```\n\n### Validation\n\nThe frontend uses `ActionConfigSchema` (Zod discriminated union) to validate configs before saving to database. All configs are type-safe and validated at compile-time and runtime.\n\n### Inconsistencies in Frontend\n\n1. **Duplicate Actions**: `ai_add_title` and `ai_gen_title` are functionally identical\n2. **Duplicate Actions**: `ai_add_tags` and `ai_gen_tags` both show \"AI Generate Tags\" label\n3. **Incomplete Config**: `ai_add_tags` default config is missing `maxTags` and `categories` fields\n4. **Disabled Action**: `ai_summarize` is fully implemented but disabled (line 325)\n\n---\n\n## 2. WorkflowManager Layer\n\n### Location\n- `/functions/WorkflowManager/src/handlers/workflowActions.ts` - Action routing\n- `/functions/WorkflowManager/src/handlers/actions/aiActions.ts` - AI action handlers\n\n### Action Routing\n\nThe WorkflowManager routes multiple action names to the same handler:\n\n```typescript\n// Routing in handleWorkflowAction()\nswitch (action) {\n  case 'ai_rewrite':\n  case 'ai_gen_content':\n  case 'ai_generate_content':\n    return await aiActions.handleAiRewrite(...);\n\n  case 'ai_translate':\n    return await aiActions.handleAiTranslate(...);\n\n  case 'ai_summarize':\n    return await aiActions.handleAiSummarize(...);\n\n  case 'ai_add_hashtags':\n  case 'ai_add_tags':\n  case 'ai_gen_tags':\n    return await aiActions.handleAiAddHashtags(...);\n\n  case 'ai_gen_title':\n  case 'ai_add_title':\n    return await aiActions.handleAiGenerateTitle(...);\n}\n```\n\n### Handler Implementations\n\nEach handler follows this pattern:\n1. Extract `genericPost` from `postData.postData`\n2. Add platform-specific instructions (e.g., Bluesky 300 char limit)\n3. Build request data matching frontend schema\n4. Create JWT for authentication\n5. Build `ActionConfig` with action type\n6. Call AI_API via `appwriteManager.executeAIFunction()`\n7. Process response and update `genericPost`\n8. Return updated `PostContainer`\n\n#### handleAiRewrite()\n\n**Input**: `AIRewriteActionConfig` from frontend\n**Sends to AI_API**:\n```typescript\n{\n  action: 'ai_rewrite',\n  title?: string,\n  content: string,           // from genericPost.text\n  style: StyleEnum,\n  tone: ToneEnum,\n  length: LengthEnum,\n  user_instructions?: string\n}\n```\n\n**Processes Response**:\n- Updates `genericPost.text` from `response.result.content`\n- Updates `genericPost.title` from `response.result.title` (if present)\n\n**⚠️ Issue**: Also handles `ai_gen_content` action, but \"rewrite\" logic doesn't match \"generate new content\" semantics\n\n#### handleAiTranslate()\n\n**Input**: `TranslateActionConfig` from frontend\n**Sends to AI_API**:\n```typescript\n{\n  action: 'ai_translate',\n  title?: string,\n  content: string,\n  target_language: string,    // ⚠️ Field name changed from 'language'\n  preserve_formatting: boolean,\n  user_instructions?: string\n}\n```\n\n**Processes Response**:\n- Updates `genericPost.text` from `response.result.content`\n- Updates `genericPost.title` from `response.result.title` (if present)\n\n**Field Mapping**: Frontend sends `language`, WorkflowManager sends `target_language`\n\n#### handleAiSummarize()\n\n**Input**: `AISummarizeActionConfig` from frontend\n**Sends to AI_API**:\n```typescript\n{\n  action: 'ai_summarize',\n  title?: string,\n  content: string,\n  max_length?: number,\n  format: FormatEnum,\n  user_instructions?: string\n}\n```\n\n**Processes Response**:\n- Updates `genericPost.text` from `response.result.content`\n- Updates `genericPost.title` from `response.result.title` (if present)\n\n#### handleAiGenerateTitle()\n\n**Input**: `AIAddTitleActionConfig` from frontend\n**Sends to AI_API**:\n```typescript\n{\n  action: 'ai_gen_title',    // ⚠️ Always sends 'ai_gen_title'\n  title?: string,\n  content: string,\n  style: StyleEnum,\n  max_length?: number,\n  user_instructions?: string\n}\n```\n\n**Processes Response**:\n- Updates `genericPost.title` from `response.result.title`\n- Does NOT modify `genericPost.text`\n\n**⚠️ Note**: Both `ai_add_title` and `ai_gen_title` send action as `'ai_gen_title'`\n\n#### handleAiAddHashtags()\n\n**Input**: `AIAddTagsActionConfig` from frontend\n**Sends to AI_API**:\n```typescript\n{\n  action: 'ai_gen_tags',     // ⚠️ Always sends 'ai_gen_tags'\n  title?: string,\n  content: string,\n  max_tags?: number,\n  categories?: string[],\n  user_instructions?: string\n}\n```\n\n**Processes Response**:\n```typescript\n// Expects response.result.tags array\nif (response.result.tags) {\n  genericPost.text = `${genericPost.text} ${response.result.tags.join(' ')}`;\n}\n```\n\n**⚠️ CRITICAL ISSUE**: Expects `response.result.tags` array, but AI_API returns `ActionResult` with only `content` and `title` fields. This will cause tag generation to fail!\n\n### Data Flow\n\n```\nFrontend Config → WorkflowManager Handler → AI_API Request\n\nExample for ai_translate:\n{                         {                          {\n  language: \"es\"     →    target_language: \"es\"  →    target_language: \"es\"\n  content: \"Hello\"        content: \"Hello\"            content: \"Hello\"\n  preserve_formatting     preserve_formatting         action: \"ai_translate\"\n}                         user_instructions           ...\n                        }                          }\n```\n\n---\n\n## 3. AI_API Layer\n\n### Location\n- `/functions/AI_API/src/main.py` - Entry point and routing\n- `/functions/AI_API/src/services/ai_service.py` - Main AI processing\n- `/functions/AI_API/src/workflows/ai_workflow.py` - LlamaIndex workflow\n- `/functions/AI_API/src/schemas/requests.py` - Request schemas\n- `/functions/AI_API/src/schemas/responses.py` - Response schemas\n\n### Request Flow\n\n1. **main.py → handle_action()**\n   - Validates `ActionRequest` schema\n   - Extracts user_id from headers or request body\n   - Authenticates via JWT\n\n2. **AIService.process_action()**\n   - Validates user credits via `BillingService`\n   - Estimates token usage based on action type\n   - Selects LLM (nano for simple, smart for complex)\n   - Creates `AIWorkflow` instance\n\n3. **AIWorkflow (LlamaIndex)**\n   - Implements agentic workflow with events:\n     - `StartEvent` → `ContentAnalysisEvent`\n     - `ContentAnalysisEvent` → `ToolExecutionEvent`\n     - `ToolExecutionEvent` → `OptimizationEvent` or `StopEvent`\n     - `OptimizationEvent` → `StopEvent` or loop back\n   - Uses function calling with tools:\n     - `analyze_sentiment` - Analyze tone and sentiment\n     - `check_constraints` - Validate platform limits\n     - `optimize_platform` - Platform-specific optimization\n     - `validate_quality` - Quality checks\n     - `complete_optimization` - Signal completion\n\n### Request Schema\n\n```python\nclass ActionRequest(BaseModel):\n    action: Literal[\n        \"ai_translate\",\n        \"ai_rewrite\",\n        \"ai_summarize\",\n        \"ai_gen_content\",\n        \"ai_gen_title\",\n        \"ai_gen_tags\"\n    ]\n    content: str\n\n    # Action-specific parameters\n    target_language: str | None\n    tone: str | None\n    length: Literal[\"shorter\", \"longer\", \"same\"] | None\n    platform: str | None\n    style: str | None\n\n    # Common parameters\n    max_tokens: int = 2000\n    temperature: float = 0.7\n    context: dict[str, Any] = {}\n```\n\n### Response Schema\n\n```python\nclass ActionResult(BaseModel):\n    content: str                    # Processed content\n    title: str | None = None        # Optional title\n\nclass ActionResponse(BaseModel):\n    result: ActionResult            # ⚠️ Only content + title\n    action: str\n    model_used: str\n    tokens: TokenUsage\n    response_time_ms: int\n    confidence_score: float | None\n    optimizations_applied: list[str]\n    warnings: list[str]\n```\n\n### Supported Actions\n\n**ai_rewrite**\n- Routes to AIWorkflow with rewrite optimization\n- Returns: `{ content: rewritten_text, title: optional }`\n\n**ai_translate**\n- Routes to AIWorkflow with translation parameters\n- Uses `target_language` field\n- Returns: `{ content: translated_text, title: optional }`\n\n**ai_summarize**\n- Routes to AIWorkflow with summarization\n- Returns: `{ content: summary_text, title: optional }`\n\n**ai_gen_content**\n- Routes to AIWorkflow (currently same as rewrite)\n- Returns: `{ content: generated_text, title: optional }`\n\n**ai_gen_title**\n- Routes to AIWorkflow with title generation\n- Special handling in ai_service.py:\n  ```python\n  if action_request.action == \"ai_gen_title\" and not processed_title:\n      processed_title = processed_content\n      processed_content = action_request.content  # Keep original\n  ```\n- Returns: `{ content: original_or_empty, title: generated_title }`\n\n**ai_gen_tags**\n- Routes to AIWorkflow with tag generation\n- ⚠️ **PROBLEM**: Returns `{ content: tags_as_string, title: null }`\n- WorkflowManager expects `{ tags: string[] }` in result\n\n### LlamaIndex Workflow Details\n\nThe `AIWorkflow` implements a sophisticated agentic pattern:\n\n1. **Analysis Phase**\n   - Builds analysis prompt with action context\n   - LLM decides which tools to call\n   - Tools provide insights (sentiment, constraints, etc.)\n\n2. **Execution Phase**\n   - Executes tool calls\n   - Checks for `complete_optimization` tool\n   - If complete, returns final result\n   - Otherwise, proceeds to optimization\n\n3. **Optimization Phase**\n   - Builds optimization prompt with tool results\n   - LLM generates optimized content\n   - Validates quality (score 0-1)\n   - If quality ≥ 0.8 or max attempts reached, stops\n   - Otherwise, loops back to analysis\n\n4. **Safeguards**\n   - Max 3 optimization attempts\n   - Forced completion after max attempts\n   - Tool execution error handling\n\n### Token Estimation & Billing\n\n```python\ndef _estimate_action_tokens(action_request):\n    content_length = len(action_request.content)\n    input_tokens = max(100, int(content_length * TOKENS_PER_CHARACTER))\n    multiplier = ACTION_TOKEN_MULTIPLIERS.get(action_request.action, 1.5)\n    total = (input_tokens * multiplier) + SYSTEM_PROMPT_OVERHEAD\n    return int(total * TOKEN_ESTIMATION_BUFFER)\n```\n\n**Token Multipliers**:\n- `ai_translate`: 1.8x (higher due to translation accuracy)\n- `ai_rewrite`: 1.5x\n- `ai_summarize`: 1.3x (shorter output)\n- `ai_gen_content`: 2.0x (generates from scratch)\n- Default: 1.5x\n\n---\n\n## 4. Data Flow Comparison\n\n### Request Journey: ai_translate\n\n```\nFRONTEND                    WORKFLOWMANAGER                 AI_API\n─────────                   ───────────────                 ──────\n\nUser selects:\n\"Translate to Spanish\"\n\ngetDefaultConfig():\n{\n  language: \"es\",      →    Extract from config        →    ActionRequest:\n  preserve_formatting        Build request:                 {\n    : true,                  {                                action: \"ai_translate\"\n  content: \"\",                 target_language: \"es\", →      target_language: \"es\"\n  user_instructions:           content: post.text,           content: \"Hello world\"\n    \"\"                         preserve_formatting:          preserve_formatting:\n}                                true                           true\n                              }                               max_tokens: 2000\n                                                              temperature: 0.7\n                                                           }\n                                                                │\n                                                                ▼\n                                                           AIWorkflow:\n                                                           1. Analyze content\n                                                           2. Check constraints\n                                                           3. Translate\n                                                           4. Validate quality\n                                                                │\n                              Response:              ◀───      ▼\n                              {                            ActionResponse:\n                                result: {                  {\n                                  content:                   result: {\n                                    \"Hola mundo\"               content: \"Hola...\"\n                                  title: null                  title: null\n                                }                            }\n                              }                              action: \"ai_...\"\n                                                             tokens: {...}\n                                                           }\n                              │\n                              ▼\n                         Update post:\n                         post.text =\n                           \"Hola mundo\"\n```\n\n### Response Processing Patterns\n\n| Action | WorkflowManager Expects | AI_API Returns | Update Logic |\n|--------|------------------------|----------------|--------------|\n| `ai_rewrite` | `result.content`, `result.title` | ✅ `ActionResult { content, title? }` | Updates `text` and/or `title` |\n| `ai_translate` | `result.content`, `result.title` | ✅ `ActionResult { content, title? }` | Updates `text` and/or `title` |\n| `ai_summarize` | `result.content`, `result.title` | ✅ `ActionResult { content, title? }` | Updates `text` and/or `title` |\n| `ai_gen_title` | `result.title` | ✅ `ActionResult { content, title }` | Updates `title` only |\n| `ai_gen_tags` | ❌ `result.tags[]` | ⚠️ `ActionResult { content, title? }` | **MISMATCH** - expects array, gets string |\n\n---\n\n## 5. Key Inconsistencies & Issues\n\n### Issue 1: Tag Generation Response Mismatch\n\n**Problem**: WorkflowManager expects tags as array, AI_API returns as content string\n\n**Location**:\n- `functions/WorkflowManager/src/handlers/actions/aiActions.ts:289-300`\n- `functions/AI_API/src/schemas/responses.py:16-20`\n\n**Current Code**:\n```typescript\n// WorkflowManager expects:\nif (response.result.tags) {\n  genericPost.text = `${genericPost.text} ${response.result.tags.join(' ')}`;\n}\n\n// AI_API returns:\nActionResult {\n  content: string,    // Tags as string, not array\n  title: null\n}\n```\n\n**Impact**: Tag generation will fail - the `.tags` property doesn't exist\n\n**Solution Options**:\n1. Change AI_API to return tags in a `tags` field\n2. Change WorkflowManager to parse tags from `content` string\n3. Add tags field to `ActionResult` schema\n\n### Issue 2: Duplicate Action Handlers\n\n**Problem**: Multiple frontend actions map to single handler\n\n**Actions Affected**:\n- `ai_gen_content` + `ai_generate_content` → uses rewrite handler (semantically incorrect)\n- `ai_add_title` + `ai_gen_title` → identical functionality\n- `ai_add_tags` + `ai_gen_tags` → identical functionality\n\n**Impact**:\n- Confusing for users (duplicate options)\n- `ai_gen_content` doesn't actually \"generate new content\", it rewrites existing\n\n**Recommendation**:\n- Remove `ai_add_*` variants, keep only `ai_gen_*`\n- Create dedicated handler for `ai_gen_content` that actually generates new content\n\n### Issue 3: Field Name Inconsistency\n\n**Problem**: Field renamed between layers\n\n**Flow**:\n```\nFrontend: language: \"es\"\n    ↓\nWorkflowManager: target_language: \"es\"\n    ↓\nAI_API: target_language: \"es\"\n```\n\n**Impact**: Minor - doesn't break functionality but adds confusion\n\n**Recommendation**: Use consistent field names across all layers\n\n### Issue 4: Incomplete Default Config\n\n**Problem**: `ai_add_tags` missing fields in default config\n\n**Location**: `src/utils/workflowUtils.ts:104-108`\n\n```typescript\n// ai_gen_tags - complete\ncase \"ai_gen_tags\":\n  return {\n    content: \"\",\n    maxTags: undefined,\n    categories: [],\n  };\n\n// ai_add_tags - incomplete\ncase \"ai_add_tags\":\n  return {\n    content: \"\",\n    // Missing: maxTags, categories\n  };\n```\n\n**Impact**: Users can't configure max tags or categories for `ai_add_tags`\n\n**Recommendation**: Add missing fields or remove duplicate action\n\n### Issue 5: ai_summarize Disabled\n\n**Problem**: Fully implemented action is disabled in frontend\n\n**Location**: `src/utils/workflowUtils.ts:325`\n\n**Impact**: Users can't access summarization feature\n\n**Recommendation**: Enable the action or document why it's disabled\n\n---\n\n## 6. Schema Compatibility Matrix\n\n| Schema Field | Frontend | WorkflowManager Sends | AI_API Expects | Notes |\n|--------------|----------|----------------------|----------------|-------|\n| `action` | ✅ | ✅ | ✅ | All layers use same values |\n| `content` | ✅ | ✅ | ✅ | Required in all layers |\n| `title` | ✅ | ✅ Optional | ❌ Not in request | Only in response |\n| `language` | ✅ | ❌ Renamed | ❌ | Becomes `target_language` |\n| `target_language` | ❌ | ✅ | ✅ | Used in Manager & API |\n| `style` | ✅ | ✅ | ✅ | Enum validated |\n| `tone` | ✅ | ✅ | ✅ | Enum validated |\n| `length` | ✅ | ✅ | ✅ | Enum validated |\n| `format` | ✅ | ✅ | ❌ Not in request | For summarize action |\n| `max_tags` | ✅ | ✅ | ❌ Not in request | For tag actions |\n| `maxTags` | ✅ | ✅ as `max_tags` | ❌ | Naming inconsistency |\n| `categories` | ✅ | ✅ | ❌ Not in request | For tag actions |\n| `preserve_formatting` | ✅ | ✅ | ❌ Not in request | For translate |\n| `user_instructions` | ✅ | ✅ | ❌ Not in request | All actions |\n| `conditions` | ✅ | ✅ Checked | ❌ | Frontend/Manager only |\n\n**⚠️ Note**: Many frontend config fields are NOT sent to AI_API because the ActionRequest schema is simplified. The AI_API infers behavior from the `action` type and a few key parameters.\n\n---\n\n## 7. Recommendations\n\n### High Priority\n\n1. **Fix Tag Response Structure**\n   - Option A: Add `tags: string[]` field to `ActionResult`\n   - Option B: Change WorkflowManager to parse tags from content\n   - Recommended: Option A (cleaner separation)\n\n2. **Create Dedicated ai_gen_content Handler**\n   - Current: Routes to rewrite handler (incorrect semantics)\n   - New: Create handler that generates content from scratch based on prompt/instructions\n\n3. **Remove Duplicate Actions**\n   - Remove `ai_add_title` (keep `ai_gen_title`)\n   - Remove `ai_add_tags` (keep `ai_gen_tags`)\n   - Rationale: Reduces user confusion, identical functionality\n\n### Medium Priority\n\n4. **Standardize Field Names**\n   - Use `target_language` in all layers (frontend, manager, API)\n   - Use consistent naming: `maxTags` vs `max_tags`\n\n5. **Complete Default Configs**\n   - Add `maxTags` and `categories` to `ai_add_tags` default config\n   - Or remove the action entirely\n\n6. **Enable ai_summarize**\n   - Action is fully implemented\n   - Either enable it or document why it's disabled\n\n### Low Priority\n\n7. **Document Action Capabilities**\n   - Add user-facing documentation explaining each action\n   - Include examples of before/after for each action\n\n8. **Expand ActionRequest Schema**\n   - Consider adding more fields from frontend schemas\n   - Would allow more granular control from AI_API\n\n9. **Add Response Validation**\n   - Validate AI_API responses match expected structure\n   - Return user-friendly errors on validation failures\n\n---\n\n## 8. Testing Checklist\n\nAfter implementing fixes:\n\n- [ ] Test tag generation returns tags in correct format\n- [ ] Verify `ai_gen_content` generates new content (not rewrites)\n- [ ] Confirm removed duplicate actions\n- [ ] Validate consistent field names across layers\n- [ ] Test each action with various platforms (Twitter, Instagram, etc.)\n- [ ] Verify Bluesky character limit enforcement\n- [ ] Test condition evaluation with AND/OR operators\n- [ ] Validate credit deduction for each action type\n- [ ] Confirm response times are acceptable\n- [ ] Test error handling for insufficient credits\n\n---\n\n## Appendix: Complete Action Reference\n\n### ai_rewrite\n**Purpose**: Rewrite existing content with style/tone/length adjustments\n**Frontend Config**: style, tone, length, content, user_instructions\n**Manager Sends**: Same as frontend\n**API Returns**: `{ content: rewritten_text, title?: optional }`\n**Updates**: `genericPost.text` and optionally `genericPost.title`\n\n### ai_translate\n**Purpose**: Translate content to target language\n**Frontend Config**: language, preserve_formatting, content, user_instructions\n**Manager Sends**: target_language (renamed), preserve_formatting, content\n**API Returns**: `{ content: translated_text, title?: optional }`\n**Updates**: `genericPost.text` and optionally `genericPost.title`\n\n### ai_summarize\n**Purpose**: Create concise summary of content\n**Frontend Config**: max_length, format, content, user_instructions\n**Manager Sends**: Same as frontend\n**API Returns**: `{ content: summary_text, title?: optional }`\n**Updates**: `genericPost.text` and optionally `genericPost.title`\n**Status**: ⚠️ Disabled in frontend\n\n### ai_gen_content\n**Purpose**: Generate new content from scratch\n**Frontend Config**: length, tone, style, format, content, user_instructions\n**Manager Sends**: Same as frontend\n**API Returns**: `{ content: generated_text, title?: optional }`\n**Updates**: `genericPost.text` and optionally `genericPost.title`\n**⚠️ Issue**: Currently routes to rewrite handler\n\n### ai_gen_title / ai_add_title\n**Purpose**: Generate title for content\n**Frontend Config**: style, max_length, content, user_instructions\n**Manager Sends**: Always sends as `ai_gen_title`\n**API Returns**: `{ content: empty_or_original, title: generated_title }`\n**Updates**: `genericPost.title` only (text unchanged)\n**⚠️ Issue**: Duplicate actions with identical functionality\n\n### ai_gen_tags / ai_add_tags\n**Purpose**: Generate hashtags for content\n**Frontend Config**: max_tags (maxTags), categories, content, user_instructions\n**Manager Sends**: Always sends as `ai_gen_tags`, expects `result.tags` array\n**API Returns**: `{ content: tags_as_string, title: null }`\n**Updates**: Appends tags to `genericPost.text`\n**⚠️ CRITICAL**: Response format mismatch - expects array, gets string\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":9032,"cache_read_input_tokens":67877,"cache_creation":{"ephemeral_5m_input_tokens":9032,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CTfE7XStCF4dGaj4NMXd9","type":"assistant","uuid":"89d00de7-d494-43b0-bd51-73af32b7f438","timestamp":"2025-09-30T20:39:04.018Z"}
{"parentUuid":"89d00de7-d494-43b0-bd51-73af32b7f438","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01B6dFGCtzXtE9LbSGq2ZvAf","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"ad9f6d1c-d6e7-44d9-9b4a-9ebbda98c186","timestamp":"2025-09-30T20:39:04.191Z","toolUseResult":{"oldTodos":[{"content":"Read frontend workflow utilities to understand action nodes and configs","status":"completed","activeForm":"Reading frontend workflow utilities"},{"content":"Read WorkflowManager AI action handlers","status":"completed","activeForm":"Reading WorkflowManager AI action handlers"},{"content":"Read AI_API implementation and schemas","status":"completed","activeForm":"Reading AI_API implementation and schemas"},{"content":"Analyze schemas and data flow between all three layers","status":"in_progress","activeForm":"Analyzing schemas and data flow"},{"content":"Create comprehensive rewritten documentation with visual diagrams","status":"pending","activeForm":"Creating comprehensive documentation"}],"newTodos":[{"content":"Read frontend workflow utilities to understand action nodes and configs","status":"completed","activeForm":"Reading frontend workflow utilities"},{"content":"Read WorkflowManager AI action handlers","status":"completed","activeForm":"Reading WorkflowManager AI action handlers"},{"content":"Read AI_API implementation and schemas","status":"completed","activeForm":"Reading AI_API implementation and schemas"},{"content":"Analyze schemas and data flow between all three layers","status":"completed","activeForm":"Analyzing schemas and data flow"},{"content":"Create comprehensive rewritten documentation with visual diagrams","status":"in_progress","activeForm":"Creating comprehensive documentation"}]}}
{"type":"file-history-snapshot","messageId":"89d00de7-d494-43b0-bd51-73af32b7f438","snapshot":{"messageId":"5c08f8cc-c1a4-4ffc-ae95-8afd527b2f85","trackedFileBackups":{"AI_ACTIONS_REFERENCE.md":{"backupFileName":"7309823f6007dd8e@v1","version":1,"backupTime":"2025-09-30T20:39:27.533Z"}},"timestamp":"2025-09-30T20:35:19.383Z"},"isSnapshotUpdate":true}
{"parentUuid":"ad9f6d1c-d6e7-44d9-9b4a-9ebbda98c186","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014VGfEgxrgZtipbiH4w4YTD","type":"tool_result","content":"The file /Users/natedamstra/socialaize/AI_ACTIONS_REFERENCE.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     1→# AI Actions Reference - Complete System Architecture\n     2→\n     3→## Overview\n     4→\n     5→This document provides a comprehensive view of AI actions across the Socialaize platform, explaining how they flow from the frontend through the WorkflowManager to the AI_API and back.\n     6→\n     7→## System Architecture\n     8→\n     9→```\n    10→┌─────────────────────────────────────────────────────────────────────────┐\n    11→│                           FRONTEND (Astro/Vue)                           │\n    12→│  ┌────────────────────────────────────────────────────────────────────┐ │\n    13→│  │  User Interface - Workflow Builder                                 │ │\n    14→│  │  - Action selection from ACTION_CATEGORIES                         │ │\n    15→│  │  - Configuration forms for each action                             │ │\n    16→│  │  - Default configs from getDefaultConfig()                         │ │\n    17→│  │  - Zod validation via ActionConfigSchema                          │ │\n    18→│  └────────────────────────────────────────────────────────────────────┘ │\n    19→│                                   │                                      │\n    20→│                                   │ Creates WorkflowNode with:          │\n    21→│                                   │ - action: string                    │\n    22→│                                   │ - config: ActionConfig              │\n    23→│                                   ▼                                      │\n    24→└─────────────────────────────────────────────────────────────────────────┘\n    25→                                    │\n    26→                                    │ Saved to Appwrite DB\n    27→                                    │\n    28→┌─────────────────────────────────────────────────────────────────────────┐\n    29→│                    WORKFLOW EXECUTION (Appwrite Event)                   │\n    30→│                                                                           │\n    31→│  User creates/publishes PostContainer → WorkflowExecution created       │\n    32→└─────────────────────────────────────────────────────────────────────────┘\n    33→                                    │\n    34→                                    │ Triggers function\n    35→                                    ▼\n    36→┌─────────────────────────────────────────────────────────────────────────┐\n    37→│                  WORKFLOWMANAGER (Node.js Function)                      │\n    38→│  ┌────────────────────────────────────────────────────────────────────┐ │\n    39→│  │  WorkflowActions.handleWorkflowAction()                            │ │\n    40→│  │  - Checks node conditions                                          │ │\n    41→│  │  - Routes to appropriate handler based on action type             │ │\n    42→│  │  - Extracts genericPost from postContainer                         │ │\n    43→│  └────────────────────────────────────────────────────────────────────┘ │\n    44→│                                   │                                      │\n    45→│  ┌────────────────────────────────┴───────────────────────────────────┐ │\n    46→│  │  AI Action Handlers (aiActions.ts)                                 │ │\n    47→│  │  - handleAiRewrite()       - handleAiTranslate()                   │ │\n    48→│  │  - handleAiSummarize()     - handleAiGenerateTitle()               │ │\n    49→│  │  - handleAiAddHashtags()                                          │ │\n    50→│  └────────────────────────────────────────────────────────────────────┘ │\n    51→│                                   │                                      │\n    52→│                                   │ 1. Creates JWT                       │\n    53→│                                   │ 2. Builds ActionConfig               │\n    54→│                                   │ 3. Calls AI_API                     │\n    55→│                                   ▼                                      │\n    56→└─────────────────────────────────────────────────────────────────────────┘\n    57→                                    │\n    58→                                    │ HTTP POST to /action\n    59→                                    │\n    60→┌─────────────────────────────────────────────────────────────────────────┐\n    61→│                      AI_API (Python FastAPI Function)                    │\n    62→│  ┌────────────────────────────────────────────────────────────────────┐ │\n    63→│  │  main.py → handle_action()                                         │ │\n    64→│  │  - Validates ActionRequest                                         │ │\n    65→│  │  - Authenticates user via JWT                                      │ │\n    66→│  │  - Validates credits (BillingService)                              │ │\n    67→│  └────────────────────────────────────────────────────────────────────┘ │\n    68→│                                   │                                      │\n    69→│  ┌────────────────────────────────▼───────────────────────────────────┐ │\n    70→│  │  AIService.process_action()                                        │ │\n    71→│  │  - Estimates token usage                                           │ │\n    72→│  │  - Selects appropriate LLM (nano/smart)                            │ │\n    73→│  │  - Creates AIWorkflow instance                                     │ │\n    74→│  └────────────────────────────────────────────────────────────────────┘ │\n    75→│                                   │                                      │\n    76→│  ┌────────────────────────────────▼───────────────────────────────────┐ │\n    77→│  │  AIWorkflow (LlamaIndex Workflow)                                  │ │\n    78→│  │  1. ContentAnalysisEvent → analyze_content()                       │ │\n    79→│  │  2. ToolExecutionEvent → execute_tools()                           │ │\n    80→│  │  3. OptimizationEvent → optimize_content()                         │ │\n    81→│  │  4. StopEvent → returns result                                     │ │\n    82→│  │                                                                      │ │\n    83→│  │  Uses function calling with tools:                                 │ │\n    84→│  │  - analyze_sentiment, check_constraints                            │ │\n    85→│  │  - optimize_platform, validate_quality                             │ │\n    86→│  │  - complete_optimization                                           │ │\n    87→│  └────────────────────────────────────────────────────────────────────┘ │\n    88→│                                   │                                      │\n    89→│                                   │ Returns ActionResponse:             │\n    90→│                                   │ {                                   │\n    91→│                                   │   result: {                         │\n    92→│                                   │     content: string,                │\n    93→│                                   │     title: string | null            │\n    94→│                                   │   },                                │\n    95→│                                   │   action: string,                   │\n    96→│                                   │   model_used: string,               │\n    97→│                                   │   tokens: TokenUsage,               │\n    98→│                                   │   ...                               │\n    99→│                                   │ }                                   │\n   100→│                                   ▼                                      │\n   101→└─────────────────────────────────────────────────────────────────────────┘\n   102→                                    │\n   103→                                    │ Response flows back\n   104→                                    ▼\n   105→┌─────────────────────────────────────────────────────────────────────────┐\n   106→│                  WORKFLOWMANAGER (Processes Response)                    │\n   107→│  - Extracts content and title from response.result                      │\n   108→│  - Updates genericPost.text and/or genericPost.title                    │\n   109→│  - Returns updated PostContainer                                        │\n   110→│  - Proceeds to next workflow node                                       │\n   111→└─────────────────────────────────────────────────────────────────────────┘\n   112→```\n   113→\n   114→---\n   115→\n   116→## 1. Frontend Layer\n   117→\n   118→### Location\n   119→- `/src/utils/workflowUtils.ts` - Action options and default configs\n   120→- `/src/schemas/workflows/actionSchemas.ts` - Zod validation schemas\n   121→\n   122→### Available AI Actions in UI\n   123→\n   124→| Action Value | Display Label | Status | Config Fields |\n   125→|--------------|--------------|--------|---------------|\n   126→| `ai_rewrite` | \"AI Rewrite Content\" | ✅ Enabled | style, tone, length, content, user_instructions |\n   127→| `ai_translate` | \"AI Translate Content\" | ✅ Enabled | language, preserve_formatting, content, user_instructions |\n   128→| `ai_summarize` | \"AI Summarize Content\" | ❌ Disabled | max_length, format, content, user_instructions |\n   129→| `ai_gen_title` | \"AI Generate Title\" | ✅ Enabled | style, max_length, content, user_instructions |\n   130→| `ai_add_title` | \"AI Add Title\" | ✅ Enabled | style, max_length, content, user_instructions |\n   131→| `ai_gen_tags` | \"AI Generate Tags\" | ✅ Enabled | maxTags, categories, content, user_instructions |\n   132→| `ai_add_tags` | \"AI Generate Tags\" | ✅ Enabled | content, user_instructions (⚠️ missing maxTags, categories) |\n   133→| `ai_gen_content` | \"AI Generate Content\" | ✅ Enabled | length, tone, style, format, content, user_instructions |\n   134→\n   135→### Schema Definitions\n   136→\n   137→All action schemas extend `BaseActionSchema`:\n   138→```typescript\n   139→BaseActionSchema {\n   140→  user_instructions?: string\n   141→  conditions?: Condition[]  // Left-to-right evaluation with AND/OR tokens\n   142→}\n   143→```\n   144→\n   145→#### AI Action Schemas\n   146→\n   147→**AIRewriteActionSchema**\n   148→```typescript\n   149→{\n   150→  title?: string | null\n   151→  content: string\n   152→  style: \"professional\" | \"casual\" | \"formal\" | \"friendly\" | \"match\"\n   153→  tone: \"positive\" | \"neutral\" | \"negative\" | \"match\"\n   154→  length: \"shorter\" | \"same\" | \"longer\"\n   155→}\n   156→```\n   157→\n   158→**TranslateActionSchema**\n   159→```typescript\n   160→{\n   161→  content: string\n   162→  language: string           // ISO language code (e.g., \"en\", \"es\", \"fr\")\n   163→  preserve_formatting: boolean\n   164→}\n   165→```\n   166→\n   167→**AISummarizeActionSchema**\n   168→```typescript\n   169→{\n   170→  title?: string | null\n   171→  content: string\n   172→  max_length?: number\n   173→  format: \"bullet_points\" | \"paragraph\" | \"key_points\"\n   174→}\n   175→```\n   176→\n   177→**AIGenerateContentActionSchema**\n   178→```typescript\n   179→{\n   180→  title?: string | null\n   181→  content: string\n   182→  length: \"shorter\" | \"same\" | \"longer\"\n   183→  tone: \"positive\" | \"neutral\" | \"negative\" | \"match\"\n   184→  style: \"professional\" | \"casual\" | \"formal\" | \"friendly\" | \"match\"\n   185→}\n   186→```\n   187→\n   188→**AIAddTitleActionSchema**\n   189→```typescript\n   190→{\n   191→  title?: string | null\n   192→  content: string\n   193→  style?: \"professional\" | \"casual\" | \"formal\" | \"friendly\" | \"match\"\n   194→  max_length?: number\n   195→}\n   196→```\n   197→\n   198→**AIAddTagsActionSchema**\n   199→```typescript\n   200→{\n   201→  title?: string | null\n   202→  content: string\n   203→  max_tags?: number\n   204→  categories?: string[]\n   205→}\n   206→```\n   207→\n   208→### Validation\n   209→\n   210→The frontend uses `ActionConfigSchema` (Zod discriminated union) to validate configs before saving to database. All configs are type-safe and validated at compile-time and runtime.\n   211→\n   212→### Inconsistencies in Frontend\n   213→\n   214→1. **Duplicate Actions**: `ai_add_title` and `ai_gen_title` are functionally identical\n   215→2. **Duplicate Actions**: `ai_add_tags` and `ai_gen_tags` both show \"AI Generate Tags\" label\n   216→3. **Incomplete Config**: `ai_add_tags` default config is missing `maxTags` and `categories` fields\n   217→4. **Disabled Action**: `ai_summarize` is fully implemented but disabled (line 325)\n   218→\n   219→---\n   220→\n   221→## 2. WorkflowManager Layer\n   222→\n   223→### Location\n   224→- `/functions/WorkflowManager/src/handlers/workflowActions.ts` - Action routing\n   225→- `/functions/WorkflowManager/src/handlers/actions/aiActions.ts` - AI action handlers\n   226→\n   227→### Action Routing\n   228→\n   229→The WorkflowManager routes multiple action names to the same handler:\n   230→\n   231→```typescript\n   232→// Routing in handleWorkflowAction()\n   233→switch (action) {\n   234→  case 'ai_rewrite':\n   235→  case 'ai_gen_content':\n   236→  case 'ai_generate_content':\n   237→    return await aiActions.handleAiRewrite(...);\n   238→\n   239→  case 'ai_translate':\n   240→    return await aiActions.handleAiTranslate(...);\n   241→\n   242→  case 'ai_summarize':\n   243→    return await aiActions.handleAiSummarize(...);\n   244→\n   245→  case 'ai_add_hashtags':\n   246→  case 'ai_add_tags':\n   247→  case 'ai_gen_tags':\n   248→    return await aiActions.handleAiAddHashtags(...);\n   249→\n   250→  case 'ai_gen_title':\n   251→  case 'ai_add_title':\n   252→    return await aiActions.handleAiGenerateTitle(...);\n   253→}\n   254→```\n   255→\n   256→### Handler Implementations\n   257→\n   258→Each handler follows this pattern:\n   259→1. Extract `genericPost` from `postData.postData`\n   260→2. Add platform-specific instructions (e.g., Bluesky 300 char limit)\n   261→3. Build request data matching frontend schema\n   262→4. Create JWT for authentication\n   263→5. Build `ActionConfig` with action type\n   264→6. Call AI_API via `appwriteManager.executeAIFunction()`\n   265→7. Process response and update `genericPost`\n   266→8. Return updated `PostContainer`\n   267→\n   268→#### handleAiRewrite()\n   269→\n   270→**Input**: `AIRewriteActionConfig` from frontend\n   271→**Sends to AI_API**:\n   272→```typescript\n   273→{\n   274→  action: 'ai_rewrite',\n   275→  title?: string,\n   276→  content: string,           // from genericPost.text\n   277→  style: StyleEnum,\n   278→  tone: ToneEnum,\n   279→  length: LengthEnum,\n   280→  user_instructions?: string\n   281→}\n   282→```\n   283→\n   284→**Processes Response**:\n   285→- Updates `genericPost.text` from `response.result.content`\n   286→- Updates `genericPost.title` from `response.result.title` (if present)\n   287→\n   288→**⚠️ Issue**: Also handles `ai_gen_content` action, but \"rewrite\" logic doesn't match \"generate new content\" semantics\n   289→\n   290→#### handleAiTranslate()\n   291→\n   292→**Input**: `TranslateActionConfig` from frontend\n   293→**Sends to AI_API**:\n   294→```typescript\n   295→{\n   296→  action: 'ai_translate',\n   297→  title?: string,\n   298→  content: string,\n   299→  target_language: string,    // ⚠️ Field name changed from 'language'\n   300→  preserve_formatting: boolean,\n   301→  user_instructions?: string\n   302→}\n   303→```\n   304→\n   305→**Processes Response**:\n   306→- Updates `genericPost.text` from `response.result.content`\n   307→- Updates `genericPost.title` from `response.result.title` (if present)\n   308→\n   309→**Field Mapping**: Frontend sends `language`, WorkflowManager sends `target_language`\n   310→\n   311→#### handleAiSummarize()\n   312→\n   313→**Input**: `AISummarizeActionConfig` from frontend\n   314→**Sends to AI_API**:\n   315→```typescript\n   316→{\n   317→  action: 'ai_summarize',\n   318→  title?: string,\n   319→  content: string,\n   320→  max_length?: number,\n   321→  format: FormatEnum,\n   322→  user_instructions?: string\n   323→}\n   324→```\n   325→\n   326→**Processes Response**:\n   327→- Updates `genericPost.text` from `response.result.content`\n   328→- Updates `genericPost.title` from `response.result.title` (if present)\n   329→\n   330→#### handleAiGenerateTitle()\n   331→\n   332→**Input**: `AIAddTitleActionConfig` from frontend\n   333→**Sends to AI_API**:\n   334→```typescript\n   335→{\n   336→  action: 'ai_gen_title',    // ⚠️ Always sends 'ai_gen_title'\n   337→  title?: string,\n   338→  content: string,\n   339→  style: StyleEnum,\n   340→  max_length?: number,\n   341→  user_instructions?: string\n   342→}\n   343→```\n   344→\n   345→**Processes Response**:\n   346→- Updates `genericPost.title` from `response.result.title`\n   347→- Does NOT modify `genericPost.text`\n   348→\n   349→**⚠️ Note**: Both `ai_add_title` and `ai_gen_title` send action as `'ai_gen_title'`\n   350→\n   351→#### handleAiAddHashtags()\n   352→\n   353→**Input**: `AIAddTagsActionConfig` from frontend\n   354→**Sends to AI_API**:\n   355→```typescript\n   356→{\n   357→  action: 'ai_gen_tags',     // ⚠️ Always sends 'ai_gen_tags'\n   358→  title?: string,\n   359→  content: string,\n   360→  max_tags?: number,\n   361→  categories?: string[],\n   362→  user_instructions?: string\n   363→}\n   364→```\n   365→\n   366→**Processes Response**:\n   367→```typescript\n   368→// Expects response.result.tags array\n   369→if (response.result.tags) {\n   370→  genericPost.text = `${genericPost.text} ${response.result.tags.join(' ')}`;\n   371→}\n   372→```\n   373→\n   374→**⚠️ CRITICAL ISSUE**: Expects `response.result.tags` array, but AI_API returns `ActionResult` with only `content` and `title` fields. This will cause tag generation to fail!\n   375→\n   376→### Data Flow\n   377→\n   378→```\n   379→Frontend Config → WorkflowManager Handler → AI_API Request\n   380→\n   381→Example for ai_translate:\n   382→{                         {                          {\n   383→  language: \"es\"     →    target_language: \"es\"  →    target_language: \"es\"\n   384→  content: \"Hello\"        content: \"Hello\"            content: \"Hello\"\n   385→  preserve_formatting     preserve_formatting         action: \"ai_translate\"\n   386→}                         user_instructions           ...\n   387→                        }                          }\n   388→```\n   389→\n   390→---\n   391→\n   392→## 3. AI_API Layer\n   393→\n   394→### Location\n   395→- `/functions/AI_API/src/main.py` - Entry point and routing\n   396→- `/functions/AI_API/src/services/ai_service.py` - Main AI processing\n   397→- `/functions/AI_API/src/workflows/ai_workflow.py` - LlamaIndex workflow\n   398→- `/functions/AI_API/src/schemas/requests.py` - Request schemas\n   399→- `/functions/AI_API/src/schemas/responses.py` - Response schemas\n   400→\n   401→### Request Flow\n   402→\n   403→1. **main.py → handle_action()**\n   404→   - Validates `ActionRequest` schema\n   405→   - Extracts user_id from headers or request body\n   406→   - Authenticates via JWT\n   407→\n   408→2. **AIService.process_action()**\n   409→   - Validates user credits via `BillingService`\n   410→   - Estimates token usage based on action type\n   411→   - Selects LLM (nano for simple, smart for complex)\n   412→   - Creates `AIWorkflow` instance\n   413→\n   414→3. **AIWorkflow (LlamaIndex)**\n   415→   - Implements agentic workflow with events:\n   416→     - `StartEvent` → `ContentAnalysisEvent`\n   417→     - `ContentAnalysisEvent` → `ToolExecutionEvent`\n   418→     - `ToolExecutionEvent` → `OptimizationEvent` or `StopEvent`\n   419→     - `OptimizationEvent` → `StopEvent` or loop back\n   420→   - Uses function calling with tools:\n   421→     - `analyze_sentiment` - Analyze tone and sentiment\n   422→     - `check_constraints` - Validate platform limits\n   423→     - `optimize_platform` - Platform-specific optimization\n   424→     - `validate_quality` - Quality checks\n   425→     - `complete_optimization` - Signal completion\n   426→\n   427→### Request Schema\n   428→\n   429→```python\n   430→class ActionRequest(BaseModel):\n   431→    action: Literal[\n   432→        \"ai_translate\",\n   433→        \"ai_rewrite\",\n   434→        \"ai_summarize\",\n   435→        \"ai_gen_content\",\n   436→        \"ai_gen_title\",\n   437→        \"ai_gen_tags\"\n   438→    ]\n   439→    content: str\n   440→\n   441→    # Action-specific parameters\n   442→    target_language: str | None\n   443→    tone: str | None\n   444→    length: Literal[\"shorter\", \"longer\", \"same\"] | None\n   445→    platform: str | None\n   446→    style: str | None\n   447→\n   448→    # Common parameters\n   449→    max_tokens: int = 2000\n   450→    temperature: float = 0.7\n   451→    context: dict[str, Any] = {}\n   452→```\n   453→\n   454→### Response Schema\n   455→\n   456→```python\n   457→class ActionResult(BaseModel):\n   458→    content: str                    # Processed content\n   459→    title: str | None = None        # Optional title\n   460→\n   461→class ActionResponse(BaseModel):\n   462→    result: ActionResult            # ⚠️ Only content + title\n   463→    action: str\n   464→    model_used: str\n   465→    tokens: TokenUsage\n   466→    response_time_ms: int\n   467→    confidence_score: float | None\n   468→    optimizations_applied: list[str]\n   469→    warnings: list[str]\n   470→```\n   471→\n   472→### Supported Actions\n   473→\n   474→**ai_rewrite**\n   475→- Routes to AIWorkflow with rewrite optimization\n   476→- Returns: `{ content: rewritten_text, title: optional }`\n   477→\n   478→**ai_translate**\n   479→- Routes to AIWorkflow with translation parameters\n   480→- Uses `target_language` field\n   481→- Returns: `{ content: translated_text, title: optional }`\n   482→\n   483→**ai_summarize**\n   484→- Routes to AIWorkflow with summarization\n   485→- Returns: `{ content: summary_text, title: optional }`\n   486→\n   487→**ai_gen_content**\n   488→- Routes to AIWorkflow (currently same as rewrite)\n   489→- Returns: `{ content: generated_text, title: optional }`\n   490→\n   491→**ai_gen_title**\n   492→- Routes to AIWorkflow with title generation\n   493→- Special handling in ai_service.py:\n   494→  ```python\n   495→  if action_request.action == \"ai_gen_title\" and not processed_title:\n   496→      processed_title = processed_content\n   497→      processed_content = action_request.content  # Keep original\n   498→  ```\n   499→- Returns: `{ content: original_or_empty, title: generated_title }`\n   500→\n   501→**ai_gen_tags**\n   502→- Routes to AIWorkflow with tag generation\n   503→- ⚠️ **PROBLEM**: Returns `{ content: tags_as_string, title: null }`\n   504→- WorkflowManager expects `{ tags: string[] }` in result\n   505→\n   506→### LlamaIndex Workflow Details\n   507→\n   508→The `AIWorkflow` implements a sophisticated agentic pattern:\n   509→\n   510→1. **Analysis Phase**\n   511→   - Builds analysis prompt with action context\n   512→   - LLM decides which tools to call\n   513→   - Tools provide insights (sentiment, constraints, etc.)\n   514→\n   515→2. **Execution Phase**\n   516→   - Executes tool calls\n   517→   - Checks for `complete_optimization` tool\n   518→   - If complete, returns final result\n   519→   - Otherwise, proceeds to optimization\n   520→\n   521→3. **Optimization Phase**\n   522→   - Builds optimization prompt with tool results\n   523→   - LLM generates optimized content\n   524→   - Validates quality (score 0-1)\n   525→   - If quality ≥ 0.8 or max attempts reached, stops\n   526→   - Otherwise, loops back to analysis\n   527→\n   528→4. **Safeguards**\n   529→   - Max 3 optimization attempts\n   530→   - Forced completion after max attempts\n   531→   - Tool execution error handling\n   532→\n   533→### Token Estimation & Billing\n   534→\n   535→```python\n   536→def _estimate_action_tokens(action_request):\n   537→    content_length = len(action_request.content)\n   538→    input_tokens = max(100, int(content_length * TOKENS_PER_CHARACTER))\n   539→    multiplier = ACTION_TOKEN_MULTIPLIERS.get(action_request.action, 1.5)\n   540→    total = (input_tokens * multiplier) + SYSTEM_PROMPT_OVERHEAD\n   541→    return int(total * TOKEN_ESTIMATION_BUFFER)\n   542→```\n   543→\n   544→**Token Multipliers**:\n   545→- `ai_translate`: 1.8x (higher due to translation accuracy)\n   546→- `ai_rewrite`: 1.5x\n   547→- `ai_summarize`: 1.3x (shorter output)\n   548→- `ai_gen_content`: 2.0x (generates from scratch)\n   549→- Default: 1.5x\n   550→\n   551→---\n   552→\n   553→## 4. Data Flow Comparison\n   554→\n   555→### Request Journey: ai_translate\n   556→\n   557→```\n   558→FRONTEND                    WORKFLOWMANAGER                 AI_API\n   559→─────────                   ───────────────                 ──────\n   560→\n   561→User selects:\n   562→\"Translate to Spanish\"\n   563→\n   564→getDefaultConfig():\n   565→{\n   566→  language: \"es\",      →    Extract from config        →    ActionRequest:\n   567→  preserve_formatting        Build request:                 {\n   568→    : true,                  {                                action: \"ai_translate\"\n   569→  content: \"\",                 target_language: \"es\", →      target_language: \"es\"\n   570→  user_instructions:           content: post.text,           content: \"Hello world\"\n   571→    \"\"                         preserve_formatting:          preserve_formatting:\n   572→}                                true                           true\n   573→                              }                               max_tokens: 2000\n   574→                                                              temperature: 0.7\n   575→                                                           }\n   576→                                                                │\n   577→                                                                ▼\n   578→                                                           AIWorkflow:\n   579→                                                           1. Analyze content\n   580→                                                           2. Check constraints\n   581→                                                           3. Translate\n   582→                                                           4. Validate quality\n   583→                                                                │\n   584→                              Response:              ◀───      ▼\n   585→                              {                            ActionResponse:\n   586→                                result: {                  {\n   587→                                  content:                   result: {\n   588→                                    \"Hola mundo\"               content: \"Hola...\"\n   589→                                  title: null                  title: null\n   590→                                }                            }\n   591→                              }                              action: \"ai_...\"\n   592→                                                             tokens: {...}\n   593→                                                           }\n   594→                              │\n   595→                              ▼\n   596→                         Update post:\n   597→                         post.text =\n   598→                           \"Hola mundo\"\n   599→```\n   600→\n   601→### Response Processing Patterns\n   602→\n   603→| Action | WorkflowManager Expects | AI_API Returns | Update Logic |\n   604→|--------|------------------------|----------------|--------------|\n   605→| `ai_rewrite` | `result.content`, `result.title` | ✅ `ActionResult { content, title? }` | Updates `text` and/or `title` |\n   606→| `ai_translate` | `result.content`, `result.title` | ✅ `ActionResult { content, title? }` | Updates `text` and/or `title` |\n   607→| `ai_summarize` | `result.content`, `result.title` | ✅ `ActionResult { content, title? }` | Updates `text` and/or `title` |\n   608→| `ai_gen_title` | `result.title` | ✅ `ActionResult { content, title }` | Updates `title` only |\n   609→| `ai_gen_tags` | ❌ `result.tags[]` | ⚠️ `ActionResult { content, title? }` | **MISMATCH** - expects array, gets string |\n   610→\n   611→---\n   612→\n   613→## 5. Key Inconsistencies & Issues\n   614→\n   615→### Issue 1: Tag Generation Response Mismatch\n   616→\n   617→**Problem**: WorkflowManager expects tags as array, AI_API returns as content string\n   618→\n   619→**Location**:\n   620→- `functions/WorkflowManager/src/handlers/actions/aiActions.ts:289-300`\n   621→- `functions/AI_API/src/schemas/responses.py:16-20`\n   622→\n   623→**Current Code**:\n   624→```typescript\n   625→// WorkflowManager expects:\n   626→if (response.result.tags) {\n   627→  genericPost.text = `${genericPost.text} ${response.result.tags.join(' ')}`;\n   628→}\n   629→\n   630→// AI_API returns:\n   631→ActionResult {\n   632→  content: string,    // Tags as string, not array\n   633→  title: null\n   634→}\n   635→```\n   636→\n   637→**Impact**: Tag generation will fail - the `.tags` property doesn't exist\n   638→\n   639→**Solution Options**:\n   640→1. Change AI_API to return tags in a `tags` field\n   641→2. Change WorkflowManager to parse tags from `content` string\n   642→3. Add tags field to `ActionResult` schema\n   643→\n   644→### Issue 2: Duplicate Action Handlers\n   645→\n   646→**Problem**: Multiple frontend actions map to single handler\n   647→\n   648→**Actions Affected**:\n   649→- `ai_gen_content` + `ai_generate_content` → uses rewrite handler (semantically incorrect)\n   650→- `ai_add_title` + `ai_gen_title` → identical functionality\n   651→- `ai_add_tags` + `ai_gen_tags` → identical functionality\n   652→\n   653→**Impact**:\n   654→- Confusing for users (duplicate options)\n   655→- `ai_gen_content` doesn't actually \"generate new content\", it rewrites existing\n   656→\n   657→**Recommendation**:\n   658→- Remove `ai_add_*` variants, keep only `ai_gen_*`\n   659→- Create dedicated handler for `ai_gen_content` that actually generates new content\n   660→\n   661→### Issue 3: Field Name Inconsistency\n   662→\n   663→**Problem**: Field renamed between layers\n   664→\n   665→**Flow**:\n   666→```\n   667→Frontend: language: \"es\"\n   668→    ↓\n   669→WorkflowManager: target_language: \"es\"\n   670→    ↓\n   671→AI_API: target_language: \"es\"\n   672→```\n   673→\n   674→**Impact**: Minor - doesn't break functionality but adds confusion\n   675→\n   676→**Recommendation**: Use consistent field names across all layers\n   677→\n   678→### Issue 4: Incomplete Default Config\n   679→\n   680→**Problem**: `ai_add_tags` missing fields in default config\n   681→\n   682→**Location**: `src/utils/workflowUtils.ts:104-108`\n   683→\n   684→```typescript\n   685→// ai_gen_tags - complete\n   686→case \"ai_gen_tags\":\n   687→  return {\n   688→    content: \"\",\n   689→    maxTags: undefined,\n   690→    categories: [],\n   691→  };\n   692→\n   693→// ai_add_tags - incomplete\n   694→case \"ai_add_tags\":\n   695→  return {\n   696→    content: \"\",\n   697→    // Missing: maxTags, categories\n   698→  };\n   699→```\n   700→\n   701→**Impact**: Users can't configure max tags or categories for `ai_add_tags`\n   702→\n   703→**Recommendation**: Add missing fields or remove duplicate action\n   704→\n   705→### Issue 5: ai_summarize Disabled\n   706→\n   707→**Problem**: Fully implemented action is disabled in frontend\n   708→\n   709→**Location**: `src/utils/workflowUtils.ts:325`\n   710→\n   711→**Impact**: Users can't access summarization feature\n   712→\n   713→**Recommendation**: Enable the action or document why it's disabled\n   714→\n   715→---\n   716→\n   717→## 6. Schema Compatibility Matrix\n   718→\n   719→| Schema Field | Frontend | WorkflowManager Sends | AI_API Expects | Notes |\n   720→|--------------|----------|----------------------|----------------|-------|\n   721→| `action` | ✅ | ✅ | ✅ | All layers use same values |\n   722→| `content` | ✅ | ✅ | ✅ | Required in all layers |\n   723→| `title` | ✅ | ✅ Optional | ❌ Not in request | Only in response |\n   724→| `language` | ✅ | ❌ Renamed | ❌ | Becomes `target_language` |\n   725→| `target_language` | ❌ | ✅ | ✅ | Used in Manager & API |\n   726→| `style` | ✅ | ✅ | ✅ | Enum validated |\n   727→| `tone` | ✅ | ✅ | ✅ | Enum validated |\n   728→| `length` | ✅ | ✅ | ✅ | Enum validated |\n   729→| `format` | ✅ | ✅ | ❌ Not in request | For summarize action |\n   730→| `max_tags` | ✅ | ✅ | ❌ Not in request | For tag actions |\n   731→| `maxTags` | ✅ | ✅ as `max_tags` | ❌ | Naming inconsistency |\n   732→| `categories` | ✅ | ✅ | ❌ Not in request | For tag actions |\n   733→| `preserve_formatting` | ✅ | ✅ | ❌ Not in request | For translate |\n   734→| `user_instructions` | ✅ | ✅ | ❌ Not in request | All actions |\n   735→| `conditions` | ✅ | ✅ Checked | ❌ | Frontend/Manager only |\n   736→\n   737→**⚠️ Note**: Many frontend config fields are NOT sent to AI_API because the ActionRequest schema is simplified. The AI_API infers behavior from the `action` type and a few key parameters.\n   738→\n   739→---\n   740→\n   741→## 7. Recommendations\n   742→\n   743→### High Priority\n   744→\n   745→1. **Fix Tag Response Structure**\n   746→   - Option A: Add `tags: string[]` field to `ActionResult`\n   747→   - Option B: Change WorkflowManager to parse tags from content\n   748→   - Recommended: Option A (cleaner separation)\n   749→\n   750→2. **Create Dedicated ai_gen_content Handler**\n   751→   - Current: Routes to rewrite handler (incorrect semantics)\n   752→   - New: Create handler that generates content from scratch based on prompt/instructions\n   753→\n   754→3. **Remove Duplicate Actions**\n   755→   - Remove `ai_add_title` (keep `ai_gen_title`)\n   756→   - Remove `ai_add_tags` (keep `ai_gen_tags`)\n   757→   - Rationale: Reduces user confusion, identical functionality\n   758→\n   759→### Medium Priority\n   760→\n   761→4. **Standardize Field Names**\n   762→   - Use `target_language` in all layers (frontend, manager, API)\n   763→   - Use consistent naming: `maxTags` vs `max_tags`\n   764→\n   765→5. **Complete Default Configs**\n   766→   - Add `maxTags` and `categories` to `ai_add_tags` default config\n   767→   - Or remove the action entirely\n   768→\n   769→6. **Enable ai_summarize**\n   770→   - Action is fully implemented\n   771→   - Either enable it or document why it's disabled\n   772→\n   773→### Low Priority\n   774→\n   775→7. **Document Action Capabilities**\n   776→   - Add user-facing documentation explaining each action\n   777→   - Include examples of before/after for each action\n   778→\n   779→8. **Expand ActionRequest Schema**\n   780→   - Consider adding more fields from frontend schemas\n   781→   - Would allow more granular control from AI_API\n   782→\n   783→9. **Add Response Validation**\n   784→   - Validate AI_API responses match expected structure\n   785→   - Return user-friendly errors on validation failures\n   786→\n   787→---\n   788→\n   789→## 8. Testing Checklist\n   790→\n   791→After implementing fixes:\n   792→\n   793→- [ ] Test tag generation returns tags in correct format\n   794→- [ ] Verify `ai_gen_content` generates new content (not rewrites)\n   795→- [ ] Confirm removed duplicate actions\n   796→- [ ] Validate consistent field names across layers\n   797→- [ ] Test each action with various platforms (Twitter, Instagram, etc.)\n   798→- [ ] Verify Bluesky character limit enforcement\n   799→- [ ] Test condition evaluation with AND/OR operators\n   800→- [ ] Validate credit deduction for each action type\n   801→- [ ] Confirm response times are acceptable\n   802→- [ ] Test error handling for insufficient credits\n   803→\n   804→---\n   805→\n   806→## Appendix: Complete Action Reference\n   807→\n   808→### ai_rewrite\n   809→**Purpose**: Rewrite existing content with style/tone/length adjustments\n   810→**Frontend Config**: style, tone, length, content, user_instructions\n   811→**Manager Sends**: Same as frontend\n   812→**API Returns**: `{ content: rewritten_text, title?: optional }`\n   813→**Updates**: `genericPost.text` and optionally `genericPost.title`\n   814→\n   815→### ai_translate\n   816→**Purpose**: Translate content to target language\n   817→**Frontend Config**: language, preserve_formatting, content, user_instructions\n   818→**Manager Sends**: target_language (renamed), preserve_formatting, content\n   819→**API Returns**: `{ content: translated_text, title?: optional }`\n   820→**Updates**: `genericPost.text` and optionally `genericPost.title`\n   821→\n   822→### ai_summarize\n   823→**Purpose**: Create concise summary of content\n   824→**Frontend Config**: max_length, format, content, user_instructions\n   825→**Manager Sends**: Same as frontend\n   826→**API Returns**: `{ content: summary_text, title?: optional }`\n   827→**Updates**: `genericPost.text` and optionally `genericPost.title`\n   828→**Status**: ⚠️ Disabled in frontend\n   829→\n   830→### ai_gen_content\n   831→**Purpose**: Generate new content from scratch\n   832→**Frontend Config**: length, tone, style, format, content, user_instructions\n   833→**Manager Sends**: Same as frontend\n   834→**API Returns**: `{ content: generated_text, title?: optional }`\n   835→**Updates**: `genericPost.text` and optionally `genericPost.title`\n   836→**⚠️ Issue**: Currently routes to rewrite handler\n   837→\n   838→### ai_gen_title / ai_add_title\n   839→**Purpose**: Generate title for content\n   840→**Frontend Config**: style, max_length, content, user_instructions\n   841→**Manager Sends**: Always sends as `ai_gen_title`\n   842→**API Returns**: `{ content: empty_or_original, title: generated_title }`\n   843→**Updates**: `genericPost.title` only (text unchanged)\n   844→**⚠️ Issue**: Duplicate actions with identical functionality\n   845→\n   846→### ai_gen_tags / ai_add_tags\n   847→**Purpose**: Generate hashtags for content\n   848→**Frontend Config**: max_tags (maxTags), categories, content, user_instructions\n   849→**Manager Sends**: Always sends as `ai_gen_tags`, expects `result.tags` array\n   850→**API Returns**: `{ content: tags_as_string, title: null }`\n   851→**Updates**: Appends tags to `genericPost.text`\n   852→**⚠️ CRITICAL**: Response format mismatch - expects array, gets string\n   853→"}]},"uuid":"18aa4793-ab43-4ef8-b43f-d8dc5bd690a6","timestamp":"2025-09-30T20:39:27.681Z","toolUseResult":{"type":"update","filePath":"/Users/natedamstra/socialaize/AI_ACTIONS_REFERENCE.md","content":"# AI Actions Reference - Complete System Architecture\n\n## Overview\n\nThis document provides a comprehensive view of AI actions across the Socialaize platform, explaining how they flow from the frontend through the WorkflowManager to the AI_API and back.\n\n## System Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                           FRONTEND (Astro/Vue)                           │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │  User Interface - Workflow Builder                                 │ │\n│  │  - Action selection from ACTION_CATEGORIES                         │ │\n│  │  - Configuration forms for each action                             │ │\n│  │  - Default configs from getDefaultConfig()                         │ │\n│  │  - Zod validation via ActionConfigSchema                          │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n│                                   │                                      │\n│                                   │ Creates WorkflowNode with:          │\n│                                   │ - action: string                    │\n│                                   │ - config: ActionConfig              │\n│                                   ▼                                      │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    │ Saved to Appwrite DB\n                                    │\n┌─────────────────────────────────────────────────────────────────────────┐\n│                    WORKFLOW EXECUTION (Appwrite Event)                   │\n│                                                                           │\n│  User creates/publishes PostContainer → WorkflowExecution created       │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    │ Triggers function\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│                  WORKFLOWMANAGER (Node.js Function)                      │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │  WorkflowActions.handleWorkflowAction()                            │ │\n│  │  - Checks node conditions                                          │ │\n│  │  - Routes to appropriate handler based on action type             │ │\n│  │  - Extracts genericPost from postContainer                         │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n│                                   │                                      │\n│  ┌────────────────────────────────┴───────────────────────────────────┐ │\n│  │  AI Action Handlers (aiActions.ts)                                 │ │\n│  │  - handleAiRewrite()       - handleAiTranslate()                   │ │\n│  │  - handleAiSummarize()     - handleAiGenerateTitle()               │ │\n│  │  - handleAiAddHashtags()                                          │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n│                                   │                                      │\n│                                   │ 1. Creates JWT                       │\n│                                   │ 2. Builds ActionConfig               │\n│                                   │ 3. Calls AI_API                     │\n│                                   ▼                                      │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    │ HTTP POST to /action\n                                    │\n┌─────────────────────────────────────────────────────────────────────────┐\n│                      AI_API (Python FastAPI Function)                    │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │  main.py → handle_action()                                         │ │\n│  │  - Validates ActionRequest                                         │ │\n│  │  - Authenticates user via JWT                                      │ │\n│  │  - Validates credits (BillingService)                              │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n│                                   │                                      │\n│  ┌────────────────────────────────▼───────────────────────────────────┐ │\n│  │  AIService.process_action()                                        │ │\n│  │  - Estimates token usage                                           │ │\n│  │  - Selects appropriate LLM (nano/smart)                            │ │\n│  │  - Creates AIWorkflow instance                                     │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n│                                   │                                      │\n│  ┌────────────────────────────────▼───────────────────────────────────┐ │\n│  │  AIWorkflow (LlamaIndex Workflow)                                  │ │\n│  │  1. ContentAnalysisEvent → analyze_content()                       │ │\n│  │  2. ToolExecutionEvent → execute_tools()                           │ │\n│  │  3. OptimizationEvent → optimize_content()                         │ │\n│  │  4. StopEvent → returns result                                     │ │\n│  │                                                                      │ │\n│  │  Uses function calling with tools:                                 │ │\n│  │  - analyze_sentiment, check_constraints                            │ │\n│  │  - optimize_platform, validate_quality                             │ │\n│  │  - complete_optimization                                           │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n│                                   │                                      │\n│                                   │ Returns ActionResponse:             │\n│                                   │ {                                   │\n│                                   │   result: {                         │\n│                                   │     content: string,                │\n│                                   │     title: string | null            │\n│                                   │   },                                │\n│                                   │   action: string,                   │\n│                                   │   model_used: string,               │\n│                                   │   tokens: TokenUsage,               │\n│                                   │   ...                               │\n│                                   │ }                                   │\n│                                   ▼                                      │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    │ Response flows back\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│                  WORKFLOWMANAGER (Processes Response)                    │\n│  - Extracts content and title from response.result                      │\n│  - Updates genericPost.text and/or genericPost.title                    │\n│  - Returns updated PostContainer                                        │\n│  - Proceeds to next workflow node                                       │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 1. Frontend Layer\n\n### Location\n- `/src/utils/workflowUtils.ts` - Action options and default configs\n- `/src/schemas/workflows/actionSchemas.ts` - Zod validation schemas\n\n### Available AI Actions in UI\n\n| Action Value | Display Label | Status | Config Fields |\n|--------------|--------------|--------|---------------|\n| `ai_rewrite` | \"AI Rewrite Content\" | ✅ Enabled | style, tone, length, content, user_instructions |\n| `ai_translate` | \"AI Translate Content\" | ✅ Enabled | language, preserve_formatting, content, user_instructions |\n| `ai_summarize` | \"AI Summarize Content\" | ❌ Disabled | max_length, format, content, user_instructions |\n| `ai_gen_title` | \"AI Generate Title\" | ✅ Enabled | style, max_length, content, user_instructions |\n| `ai_add_title` | \"AI Add Title\" | ✅ Enabled | style, max_length, content, user_instructions |\n| `ai_gen_tags` | \"AI Generate Tags\" | ✅ Enabled | maxTags, categories, content, user_instructions |\n| `ai_add_tags` | \"AI Generate Tags\" | ✅ Enabled | content, user_instructions (⚠️ missing maxTags, categories) |\n| `ai_gen_content` | \"AI Generate Content\" | ✅ Enabled | length, tone, style, format, content, user_instructions |\n\n### Schema Definitions\n\nAll action schemas extend `BaseActionSchema`:\n```typescript\nBaseActionSchema {\n  user_instructions?: string\n  conditions?: Condition[]  // Left-to-right evaluation with AND/OR tokens\n}\n```\n\n#### AI Action Schemas\n\n**AIRewriteActionSchema**\n```typescript\n{\n  title?: string | null\n  content: string\n  style: \"professional\" | \"casual\" | \"formal\" | \"friendly\" | \"match\"\n  tone: \"positive\" | \"neutral\" | \"negative\" | \"match\"\n  length: \"shorter\" | \"same\" | \"longer\"\n}\n```\n\n**TranslateActionSchema**\n```typescript\n{\n  content: string\n  language: string           // ISO language code (e.g., \"en\", \"es\", \"fr\")\n  preserve_formatting: boolean\n}\n```\n\n**AISummarizeActionSchema**\n```typescript\n{\n  title?: string | null\n  content: string\n  max_length?: number\n  format: \"bullet_points\" | \"paragraph\" | \"key_points\"\n}\n```\n\n**AIGenerateContentActionSchema**\n```typescript\n{\n  title?: string | null\n  content: string\n  length: \"shorter\" | \"same\" | \"longer\"\n  tone: \"positive\" | \"neutral\" | \"negative\" | \"match\"\n  style: \"professional\" | \"casual\" | \"formal\" | \"friendly\" | \"match\"\n}\n```\n\n**AIAddTitleActionSchema**\n```typescript\n{\n  title?: string | null\n  content: string\n  style?: \"professional\" | \"casual\" | \"formal\" | \"friendly\" | \"match\"\n  max_length?: number\n}\n```\n\n**AIAddTagsActionSchema**\n```typescript\n{\n  title?: string | null\n  content: string\n  max_tags?: number\n  categories?: string[]\n}\n```\n\n### Validation\n\nThe frontend uses `ActionConfigSchema` (Zod discriminated union) to validate configs before saving to database. All configs are type-safe and validated at compile-time and runtime.\n\n### Inconsistencies in Frontend\n\n1. **Duplicate Actions**: `ai_add_title` and `ai_gen_title` are functionally identical\n2. **Duplicate Actions**: `ai_add_tags` and `ai_gen_tags` both show \"AI Generate Tags\" label\n3. **Incomplete Config**: `ai_add_tags` default config is missing `maxTags` and `categories` fields\n4. **Disabled Action**: `ai_summarize` is fully implemented but disabled (line 325)\n\n---\n\n## 2. WorkflowManager Layer\n\n### Location\n- `/functions/WorkflowManager/src/handlers/workflowActions.ts` - Action routing\n- `/functions/WorkflowManager/src/handlers/actions/aiActions.ts` - AI action handlers\n\n### Action Routing\n\nThe WorkflowManager routes multiple action names to the same handler:\n\n```typescript\n// Routing in handleWorkflowAction()\nswitch (action) {\n  case 'ai_rewrite':\n  case 'ai_gen_content':\n  case 'ai_generate_content':\n    return await aiActions.handleAiRewrite(...);\n\n  case 'ai_translate':\n    return await aiActions.handleAiTranslate(...);\n\n  case 'ai_summarize':\n    return await aiActions.handleAiSummarize(...);\n\n  case 'ai_add_hashtags':\n  case 'ai_add_tags':\n  case 'ai_gen_tags':\n    return await aiActions.handleAiAddHashtags(...);\n\n  case 'ai_gen_title':\n  case 'ai_add_title':\n    return await aiActions.handleAiGenerateTitle(...);\n}\n```\n\n### Handler Implementations\n\nEach handler follows this pattern:\n1. Extract `genericPost` from `postData.postData`\n2. Add platform-specific instructions (e.g., Bluesky 300 char limit)\n3. Build request data matching frontend schema\n4. Create JWT for authentication\n5. Build `ActionConfig` with action type\n6. Call AI_API via `appwriteManager.executeAIFunction()`\n7. Process response and update `genericPost`\n8. Return updated `PostContainer`\n\n#### handleAiRewrite()\n\n**Input**: `AIRewriteActionConfig` from frontend\n**Sends to AI_API**:\n```typescript\n{\n  action: 'ai_rewrite',\n  title?: string,\n  content: string,           // from genericPost.text\n  style: StyleEnum,\n  tone: ToneEnum,\n  length: LengthEnum,\n  user_instructions?: string\n}\n```\n\n**Processes Response**:\n- Updates `genericPost.text` from `response.result.content`\n- Updates `genericPost.title` from `response.result.title` (if present)\n\n**⚠️ Issue**: Also handles `ai_gen_content` action, but \"rewrite\" logic doesn't match \"generate new content\" semantics\n\n#### handleAiTranslate()\n\n**Input**: `TranslateActionConfig` from frontend\n**Sends to AI_API**:\n```typescript\n{\n  action: 'ai_translate',\n  title?: string,\n  content: string,\n  target_language: string,    // ⚠️ Field name changed from 'language'\n  preserve_formatting: boolean,\n  user_instructions?: string\n}\n```\n\n**Processes Response**:\n- Updates `genericPost.text` from `response.result.content`\n- Updates `genericPost.title` from `response.result.title` (if present)\n\n**Field Mapping**: Frontend sends `language`, WorkflowManager sends `target_language`\n\n#### handleAiSummarize()\n\n**Input**: `AISummarizeActionConfig` from frontend\n**Sends to AI_API**:\n```typescript\n{\n  action: 'ai_summarize',\n  title?: string,\n  content: string,\n  max_length?: number,\n  format: FormatEnum,\n  user_instructions?: string\n}\n```\n\n**Processes Response**:\n- Updates `genericPost.text` from `response.result.content`\n- Updates `genericPost.title` from `response.result.title` (if present)\n\n#### handleAiGenerateTitle()\n\n**Input**: `AIAddTitleActionConfig` from frontend\n**Sends to AI_API**:\n```typescript\n{\n  action: 'ai_gen_title',    // ⚠️ Always sends 'ai_gen_title'\n  title?: string,\n  content: string,\n  style: StyleEnum,\n  max_length?: number,\n  user_instructions?: string\n}\n```\n\n**Processes Response**:\n- Updates `genericPost.title` from `response.result.title`\n- Does NOT modify `genericPost.text`\n\n**⚠️ Note**: Both `ai_add_title` and `ai_gen_title` send action as `'ai_gen_title'`\n\n#### handleAiAddHashtags()\n\n**Input**: `AIAddTagsActionConfig` from frontend\n**Sends to AI_API**:\n```typescript\n{\n  action: 'ai_gen_tags',     // ⚠️ Always sends 'ai_gen_tags'\n  title?: string,\n  content: string,\n  max_tags?: number,\n  categories?: string[],\n  user_instructions?: string\n}\n```\n\n**Processes Response**:\n```typescript\n// Expects response.result.tags array\nif (response.result.tags) {\n  genericPost.text = `${genericPost.text} ${response.result.tags.join(' ')}`;\n}\n```\n\n**⚠️ CRITICAL ISSUE**: Expects `response.result.tags` array, but AI_API returns `ActionResult` with only `content` and `title` fields. This will cause tag generation to fail!\n\n### Data Flow\n\n```\nFrontend Config → WorkflowManager Handler → AI_API Request\n\nExample for ai_translate:\n{                         {                          {\n  language: \"es\"     →    target_language: \"es\"  →    target_language: \"es\"\n  content: \"Hello\"        content: \"Hello\"            content: \"Hello\"\n  preserve_formatting     preserve_formatting         action: \"ai_translate\"\n}                         user_instructions           ...\n                        }                          }\n```\n\n---\n\n## 3. AI_API Layer\n\n### Location\n- `/functions/AI_API/src/main.py` - Entry point and routing\n- `/functions/AI_API/src/services/ai_service.py` - Main AI processing\n- `/functions/AI_API/src/workflows/ai_workflow.py` - LlamaIndex workflow\n- `/functions/AI_API/src/schemas/requests.py` - Request schemas\n- `/functions/AI_API/src/schemas/responses.py` - Response schemas\n\n### Request Flow\n\n1. **main.py → handle_action()**\n   - Validates `ActionRequest` schema\n   - Extracts user_id from headers or request body\n   - Authenticates via JWT\n\n2. **AIService.process_action()**\n   - Validates user credits via `BillingService`\n   - Estimates token usage based on action type\n   - Selects LLM (nano for simple, smart for complex)\n   - Creates `AIWorkflow` instance\n\n3. **AIWorkflow (LlamaIndex)**\n   - Implements agentic workflow with events:\n     - `StartEvent` → `ContentAnalysisEvent`\n     - `ContentAnalysisEvent` → `ToolExecutionEvent`\n     - `ToolExecutionEvent` → `OptimizationEvent` or `StopEvent`\n     - `OptimizationEvent` → `StopEvent` or loop back\n   - Uses function calling with tools:\n     - `analyze_sentiment` - Analyze tone and sentiment\n     - `check_constraints` - Validate platform limits\n     - `optimize_platform` - Platform-specific optimization\n     - `validate_quality` - Quality checks\n     - `complete_optimization` - Signal completion\n\n### Request Schema\n\n```python\nclass ActionRequest(BaseModel):\n    action: Literal[\n        \"ai_translate\",\n        \"ai_rewrite\",\n        \"ai_summarize\",\n        \"ai_gen_content\",\n        \"ai_gen_title\",\n        \"ai_gen_tags\"\n    ]\n    content: str\n\n    # Action-specific parameters\n    target_language: str | None\n    tone: str | None\n    length: Literal[\"shorter\", \"longer\", \"same\"] | None\n    platform: str | None\n    style: str | None\n\n    # Common parameters\n    max_tokens: int = 2000\n    temperature: float = 0.7\n    context: dict[str, Any] = {}\n```\n\n### Response Schema\n\n```python\nclass ActionResult(BaseModel):\n    content: str                    # Processed content\n    title: str | None = None        # Optional title\n\nclass ActionResponse(BaseModel):\n    result: ActionResult            # ⚠️ Only content + title\n    action: str\n    model_used: str\n    tokens: TokenUsage\n    response_time_ms: int\n    confidence_score: float | None\n    optimizations_applied: list[str]\n    warnings: list[str]\n```\n\n### Supported Actions\n\n**ai_rewrite**\n- Routes to AIWorkflow with rewrite optimization\n- Returns: `{ content: rewritten_text, title: optional }`\n\n**ai_translate**\n- Routes to AIWorkflow with translation parameters\n- Uses `target_language` field\n- Returns: `{ content: translated_text, title: optional }`\n\n**ai_summarize**\n- Routes to AIWorkflow with summarization\n- Returns: `{ content: summary_text, title: optional }`\n\n**ai_gen_content**\n- Routes to AIWorkflow (currently same as rewrite)\n- Returns: `{ content: generated_text, title: optional }`\n\n**ai_gen_title**\n- Routes to AIWorkflow with title generation\n- Special handling in ai_service.py:\n  ```python\n  if action_request.action == \"ai_gen_title\" and not processed_title:\n      processed_title = processed_content\n      processed_content = action_request.content  # Keep original\n  ```\n- Returns: `{ content: original_or_empty, title: generated_title }`\n\n**ai_gen_tags**\n- Routes to AIWorkflow with tag generation\n- ⚠️ **PROBLEM**: Returns `{ content: tags_as_string, title: null }`\n- WorkflowManager expects `{ tags: string[] }` in result\n\n### LlamaIndex Workflow Details\n\nThe `AIWorkflow` implements a sophisticated agentic pattern:\n\n1. **Analysis Phase**\n   - Builds analysis prompt with action context\n   - LLM decides which tools to call\n   - Tools provide insights (sentiment, constraints, etc.)\n\n2. **Execution Phase**\n   - Executes tool calls\n   - Checks for `complete_optimization` tool\n   - If complete, returns final result\n   - Otherwise, proceeds to optimization\n\n3. **Optimization Phase**\n   - Builds optimization prompt with tool results\n   - LLM generates optimized content\n   - Validates quality (score 0-1)\n   - If quality ≥ 0.8 or max attempts reached, stops\n   - Otherwise, loops back to analysis\n\n4. **Safeguards**\n   - Max 3 optimization attempts\n   - Forced completion after max attempts\n   - Tool execution error handling\n\n### Token Estimation & Billing\n\n```python\ndef _estimate_action_tokens(action_request):\n    content_length = len(action_request.content)\n    input_tokens = max(100, int(content_length * TOKENS_PER_CHARACTER))\n    multiplier = ACTION_TOKEN_MULTIPLIERS.get(action_request.action, 1.5)\n    total = (input_tokens * multiplier) + SYSTEM_PROMPT_OVERHEAD\n    return int(total * TOKEN_ESTIMATION_BUFFER)\n```\n\n**Token Multipliers**:\n- `ai_translate`: 1.8x (higher due to translation accuracy)\n- `ai_rewrite`: 1.5x\n- `ai_summarize`: 1.3x (shorter output)\n- `ai_gen_content`: 2.0x (generates from scratch)\n- Default: 1.5x\n\n---\n\n## 4. Data Flow Comparison\n\n### Request Journey: ai_translate\n\n```\nFRONTEND                    WORKFLOWMANAGER                 AI_API\n─────────                   ───────────────                 ──────\n\nUser selects:\n\"Translate to Spanish\"\n\ngetDefaultConfig():\n{\n  language: \"es\",      →    Extract from config        →    ActionRequest:\n  preserve_formatting        Build request:                 {\n    : true,                  {                                action: \"ai_translate\"\n  content: \"\",                 target_language: \"es\", →      target_language: \"es\"\n  user_instructions:           content: post.text,           content: \"Hello world\"\n    \"\"                         preserve_formatting:          preserve_formatting:\n}                                true                           true\n                              }                               max_tokens: 2000\n                                                              temperature: 0.7\n                                                           }\n                                                                │\n                                                                ▼\n                                                           AIWorkflow:\n                                                           1. Analyze content\n                                                           2. Check constraints\n                                                           3. Translate\n                                                           4. Validate quality\n                                                                │\n                              Response:              ◀───      ▼\n                              {                            ActionResponse:\n                                result: {                  {\n                                  content:                   result: {\n                                    \"Hola mundo\"               content: \"Hola...\"\n                                  title: null                  title: null\n                                }                            }\n                              }                              action: \"ai_...\"\n                                                             tokens: {...}\n                                                           }\n                              │\n                              ▼\n                         Update post:\n                         post.text =\n                           \"Hola mundo\"\n```\n\n### Response Processing Patterns\n\n| Action | WorkflowManager Expects | AI_API Returns | Update Logic |\n|--------|------------------------|----------------|--------------|\n| `ai_rewrite` | `result.content`, `result.title` | ✅ `ActionResult { content, title? }` | Updates `text` and/or `title` |\n| `ai_translate` | `result.content`, `result.title` | ✅ `ActionResult { content, title? }` | Updates `text` and/or `title` |\n| `ai_summarize` | `result.content`, `result.title` | ✅ `ActionResult { content, title? }` | Updates `text` and/or `title` |\n| `ai_gen_title` | `result.title` | ✅ `ActionResult { content, title }` | Updates `title` only |\n| `ai_gen_tags` | ❌ `result.tags[]` | ⚠️ `ActionResult { content, title? }` | **MISMATCH** - expects array, gets string |\n\n---\n\n## 5. Key Inconsistencies & Issues\n\n### Issue 1: Tag Generation Response Mismatch\n\n**Problem**: WorkflowManager expects tags as array, AI_API returns as content string\n\n**Location**:\n- `functions/WorkflowManager/src/handlers/actions/aiActions.ts:289-300`\n- `functions/AI_API/src/schemas/responses.py:16-20`\n\n**Current Code**:\n```typescript\n// WorkflowManager expects:\nif (response.result.tags) {\n  genericPost.text = `${genericPost.text} ${response.result.tags.join(' ')}`;\n}\n\n// AI_API returns:\nActionResult {\n  content: string,    // Tags as string, not array\n  title: null\n}\n```\n\n**Impact**: Tag generation will fail - the `.tags` property doesn't exist\n\n**Solution Options**:\n1. Change AI_API to return tags in a `tags` field\n2. Change WorkflowManager to parse tags from `content` string\n3. Add tags field to `ActionResult` schema\n\n### Issue 2: Duplicate Action Handlers\n\n**Problem**: Multiple frontend actions map to single handler\n\n**Actions Affected**:\n- `ai_gen_content` + `ai_generate_content` → uses rewrite handler (semantically incorrect)\n- `ai_add_title` + `ai_gen_title` → identical functionality\n- `ai_add_tags` + `ai_gen_tags` → identical functionality\n\n**Impact**:\n- Confusing for users (duplicate options)\n- `ai_gen_content` doesn't actually \"generate new content\", it rewrites existing\n\n**Recommendation**:\n- Remove `ai_add_*` variants, keep only `ai_gen_*`\n- Create dedicated handler for `ai_gen_content` that actually generates new content\n\n### Issue 3: Field Name Inconsistency\n\n**Problem**: Field renamed between layers\n\n**Flow**:\n```\nFrontend: language: \"es\"\n    ↓\nWorkflowManager: target_language: \"es\"\n    ↓\nAI_API: target_language: \"es\"\n```\n\n**Impact**: Minor - doesn't break functionality but adds confusion\n\n**Recommendation**: Use consistent field names across all layers\n\n### Issue 4: Incomplete Default Config\n\n**Problem**: `ai_add_tags` missing fields in default config\n\n**Location**: `src/utils/workflowUtils.ts:104-108`\n\n```typescript\n// ai_gen_tags - complete\ncase \"ai_gen_tags\":\n  return {\n    content: \"\",\n    maxTags: undefined,\n    categories: [],\n  };\n\n// ai_add_tags - incomplete\ncase \"ai_add_tags\":\n  return {\n    content: \"\",\n    // Missing: maxTags, categories\n  };\n```\n\n**Impact**: Users can't configure max tags or categories for `ai_add_tags`\n\n**Recommendation**: Add missing fields or remove duplicate action\n\n### Issue 5: ai_summarize Disabled\n\n**Problem**: Fully implemented action is disabled in frontend\n\n**Location**: `src/utils/workflowUtils.ts:325`\n\n**Impact**: Users can't access summarization feature\n\n**Recommendation**: Enable the action or document why it's disabled\n\n---\n\n## 6. Schema Compatibility Matrix\n\n| Schema Field | Frontend | WorkflowManager Sends | AI_API Expects | Notes |\n|--------------|----------|----------------------|----------------|-------|\n| `action` | ✅ | ✅ | ✅ | All layers use same values |\n| `content` | ✅ | ✅ | ✅ | Required in all layers |\n| `title` | ✅ | ✅ Optional | ❌ Not in request | Only in response |\n| `language` | ✅ | ❌ Renamed | ❌ | Becomes `target_language` |\n| `target_language` | ❌ | ✅ | ✅ | Used in Manager & API |\n| `style` | ✅ | ✅ | ✅ | Enum validated |\n| `tone` | ✅ | ✅ | ✅ | Enum validated |\n| `length` | ✅ | ✅ | ✅ | Enum validated |\n| `format` | ✅ | ✅ | ❌ Not in request | For summarize action |\n| `max_tags` | ✅ | ✅ | ❌ Not in request | For tag actions |\n| `maxTags` | ✅ | ✅ as `max_tags` | ❌ | Naming inconsistency |\n| `categories` | ✅ | ✅ | ❌ Not in request | For tag actions |\n| `preserve_formatting` | ✅ | ✅ | ❌ Not in request | For translate |\n| `user_instructions` | ✅ | ✅ | ❌ Not in request | All actions |\n| `conditions` | ✅ | ✅ Checked | ❌ | Frontend/Manager only |\n\n**⚠️ Note**: Many frontend config fields are NOT sent to AI_API because the ActionRequest schema is simplified. The AI_API infers behavior from the `action` type and a few key parameters.\n\n---\n\n## 7. Recommendations\n\n### High Priority\n\n1. **Fix Tag Response Structure**\n   - Option A: Add `tags: string[]` field to `ActionResult`\n   - Option B: Change WorkflowManager to parse tags from content\n   - Recommended: Option A (cleaner separation)\n\n2. **Create Dedicated ai_gen_content Handler**\n   - Current: Routes to rewrite handler (incorrect semantics)\n   - New: Create handler that generates content from scratch based on prompt/instructions\n\n3. **Remove Duplicate Actions**\n   - Remove `ai_add_title` (keep `ai_gen_title`)\n   - Remove `ai_add_tags` (keep `ai_gen_tags`)\n   - Rationale: Reduces user confusion, identical functionality\n\n### Medium Priority\n\n4. **Standardize Field Names**\n   - Use `target_language` in all layers (frontend, manager, API)\n   - Use consistent naming: `maxTags` vs `max_tags`\n\n5. **Complete Default Configs**\n   - Add `maxTags` and `categories` to `ai_add_tags` default config\n   - Or remove the action entirely\n\n6. **Enable ai_summarize**\n   - Action is fully implemented\n   - Either enable it or document why it's disabled\n\n### Low Priority\n\n7. **Document Action Capabilities**\n   - Add user-facing documentation explaining each action\n   - Include examples of before/after for each action\n\n8. **Expand ActionRequest Schema**\n   - Consider adding more fields from frontend schemas\n   - Would allow more granular control from AI_API\n\n9. **Add Response Validation**\n   - Validate AI_API responses match expected structure\n   - Return user-friendly errors on validation failures\n\n---\n\n## 8. Testing Checklist\n\nAfter implementing fixes:\n\n- [ ] Test tag generation returns tags in correct format\n- [ ] Verify `ai_gen_content` generates new content (not rewrites)\n- [ ] Confirm removed duplicate actions\n- [ ] Validate consistent field names across layers\n- [ ] Test each action with various platforms (Twitter, Instagram, etc.)\n- [ ] Verify Bluesky character limit enforcement\n- [ ] Test condition evaluation with AND/OR operators\n- [ ] Validate credit deduction for each action type\n- [ ] Confirm response times are acceptable\n- [ ] Test error handling for insufficient credits\n\n---\n\n## Appendix: Complete Action Reference\n\n### ai_rewrite\n**Purpose**: Rewrite existing content with style/tone/length adjustments\n**Frontend Config**: style, tone, length, content, user_instructions\n**Manager Sends**: Same as frontend\n**API Returns**: `{ content: rewritten_text, title?: optional }`\n**Updates**: `genericPost.text` and optionally `genericPost.title`\n\n### ai_translate\n**Purpose**: Translate content to target language\n**Frontend Config**: language, preserve_formatting, content, user_instructions\n**Manager Sends**: target_language (renamed), preserve_formatting, content\n**API Returns**: `{ content: translated_text, title?: optional }`\n**Updates**: `genericPost.text` and optionally `genericPost.title`\n\n### ai_summarize\n**Purpose**: Create concise summary of content\n**Frontend Config**: max_length, format, content, user_instructions\n**Manager Sends**: Same as frontend\n**API Returns**: `{ content: summary_text, title?: optional }`\n**Updates**: `genericPost.text` and optionally `genericPost.title`\n**Status**: ⚠️ Disabled in frontend\n\n### ai_gen_content\n**Purpose**: Generate new content from scratch\n**Frontend Config**: length, tone, style, format, content, user_instructions\n**Manager Sends**: Same as frontend\n**API Returns**: `{ content: generated_text, title?: optional }`\n**Updates**: `genericPost.text` and optionally `genericPost.title`\n**⚠️ Issue**: Currently routes to rewrite handler\n\n### ai_gen_title / ai_add_title\n**Purpose**: Generate title for content\n**Frontend Config**: style, max_length, content, user_instructions\n**Manager Sends**: Always sends as `ai_gen_title`\n**API Returns**: `{ content: empty_or_original, title: generated_title }`\n**Updates**: `genericPost.title` only (text unchanged)\n**⚠️ Issue**: Duplicate actions with identical functionality\n\n### ai_gen_tags / ai_add_tags\n**Purpose**: Generate hashtags for content\n**Frontend Config**: max_tags (maxTags), categories, content, user_instructions\n**Manager Sends**: Always sends as `ai_gen_tags`, expects `result.tags` array\n**API Returns**: `{ content: tags_as_string, title: null }`\n**Updates**: Appends tags to `genericPost.text`\n**⚠️ CRITICAL**: Response format mismatch - expects array, gets string\n","structuredPatch":[{"oldStart":1,"oldLines":456,"newStart":1,"newLines":852,"lines":["-# AI Actions Reference - Frontend vs Backend Analysis","+# AI Actions Reference - Complete System Architecture"," "," ## Overview","-This document explains the differences between AI action options in the frontend node library and their backend implementations, including naming inconsistencies and functional differences."," ","----","+This document provides a comprehensive view of AI actions across the Socialaize platform, explaining how they flow from the frontend through the WorkflowManager to the AI_API and back."," ","-## Frontend Action Library (User-Facing)","+## System Architecture"," ","-Located in: `/src/utils/workflowUtils.ts` (lines 305-358)","+```","+┌─────────────────────────────────────────────────────────────────────────┐","+│                           FRONTEND (Astro/Vue)                           │","+│  ┌────────────────────────────────────────────────────────────────────┐ │","+│  │  User Interface - Workflow Builder                                 │ │","+│  │  - Action selection from ACTION_CATEGORIES                         │ │","+│  │  - Configuration forms for each action                             │ │","+│  │  - Default configs from getDefaultConfig()                         │ │","+│  │  - Zod validation via ActionConfigSchema                          │ │","+│  └────────────────────────────────────────────────────────────────────┘ │","+│                                   │                                      │","+│                                   │ Creates WorkflowNode with:          │","+│                                   │ - action: string                    │","+│                                   │ - config: ActionConfig              │","+│                                   ▼                                      │","+└─────────────────────────────────────────────────────────────────────────┘","+                                    │","+                                    │ Saved to Appwrite DB","+                                    │","+┌─────────────────────────────────────────────────────────────────────────┐","+│                    WORKFLOW EXECUTION (Appwrite Event)                   │","+│                                                                           │","+│  User creates/publishes PostContainer → WorkflowExecution created       │","+└─────────────────────────────────────────────────────────────────────────┘","+                                    │","+                                    │ Triggers function","+                                    ▼","+┌─────────────────────────────────────────────────────────────────────────┐","+│                  WORKFLOWMANAGER (Node.js Function)                      │","+│  ┌────────────────────────────────────────────────────────────────────┐ │","+│  │  WorkflowActions.handleWorkflowAction()                            │ │","+│  │  - Checks node conditions                                          │ │","+│  │  - Routes to appropriate handler based on action type             │ │","+│  │  - Extracts genericPost from postContainer                         │ │","+│  └────────────────────────────────────────────────────────────────────┘ │","+│                                   │                                      │","+│  ┌────────────────────────────────┴───────────────────────────────────┐ │","+│  │  AI Action Handlers (aiActions.ts)                                 │ │","+│  │  - handleAiRewrite()       - handleAiTranslate()                   │ │","+│  │  - handleAiSummarize()     - handleAiGenerateTitle()               │ │","+│  │  - handleAiAddHashtags()                                          │ │","+│  └────────────────────────────────────────────────────────────────────┘ │","+│                                   │                                      │","+│                                   │ 1. Creates JWT                       │","+│                                   │ 2. Builds ActionConfig               │","+│                                   │ 3. Calls AI_API                     │","+│                                   ▼                                      │","+└─────────────────────────────────────────────────────────────────────────┘","+                                    │","+                                    │ HTTP POST to /action","+                                    │","+┌─────────────────────────────────────────────────────────────────────────┐","+│                      AI_API (Python FastAPI Function)                    │","+│  ┌────────────────────────────────────────────────────────────────────┐ │","+│  │  main.py → handle_action()                                         │ │","+│  │  - Validates ActionRequest                                         │ │","+│  │  - Authenticates user via JWT                                      │ │","+│  │  - Validates credits (BillingService)                              │ │","+│  └────────────────────────────────────────────────────────────────────┘ │","+│                                   │                                      │","+│  ┌────────────────────────────────▼───────────────────────────────────┐ │","+│  │  AIService.process_action()                                        │ │","+│  │  - Estimates token usage                                           │ │","+│  │  - Selects appropriate LLM (nano/smart)                            │ │","+│  │  - Creates AIWorkflow instance                                     │ │","+│  └────────────────────────────────────────────────────────────────────┘ │","+│                                   │                                      │","+│  ┌────────────────────────────────▼───────────────────────────────────┐ │","+│  │  AIWorkflow (LlamaIndex Workflow)                                  │ │","+│  │  1. ContentAnalysisEvent → analyze_content()                       │ │","+│  │  2. ToolExecutionEvent → execute_tools()                           │ │","+│  │  3. OptimizationEvent → optimize_content()                         │ │","+│  │  4. StopEvent → returns result                                     │ │","+│  │                                                                      │ │","+│  │  Uses function calling with tools:                                 │ │","+│  │  - analyze_sentiment, check_constraints                            │ │","+│  │  - optimize_platform, validate_quality                             │ │","+│  │  - complete_optimization                                           │ │","+│  └────────────────────────────────────────────────────────────────────┘ │","+│                                   │                                      │","+│                                   │ Returns ActionResponse:             │","+│                                   │ {                                   │","+│                                   │   result: {                         │","+│                                   │     content: string,                │","+│                                   │     title: string | null            │","+│                                   │   },                                │","+│                                   │   action: string,                   │","+│                                   │   model_used: string,               │","+│                                   │   tokens: TokenUsage,               │","+│                                   │   ...                               │","+│                                   │ }                                   │","+│                                   ▼                                      │","+└─────────────────────────────────────────────────────────────────────────┘","+                                    │","+                                    │ Response flows back","+                                    ▼","+┌─────────────────────────────────────────────────────────────────────────┐","+│                  WORKFLOWMANAGER (Processes Response)                    │","+│  - Extracts content and title from response.result                      │","+│  - Updates genericPost.text and/or genericPost.title                    │","+│  - Returns updated PostContainer                                        │","+│  - Proceeds to next workflow node                                       │","+└─────────────────────────────────────────────────────────────────────────┘","+```"," ","-### Available AI Actions in UI","+---"," ","-| Action Value | Display Label | Enabled | Description |","-|--------------|--------------|---------|-------------|","-| `ai_rewrite` | \"AI Rewrite Content\" | ✅ Yes | Rewrite your content using AI while maintaining the same meaning |","-| `ai_translate` | \"AI Translate Content\" | ✅ Yes | Translate your content to different languages using AI |","-| `ai_summarize` | \"AI Summarize Content\" | ❌ No | Create a concise summary of your content using AI |","-| `ai_add_title` | \"AI Add Title\" | ✅ Yes | Add a title to your content using AI |","-| `ai_gen_title` | \"AI Generate Title\" | ✅ Yes | Generate an engaging title for your content using AI |","-| `ai_add_tags` | \"AI Generate Tags\" | ✅ Yes | Generate relevant tags for your content using AI |","-| `ai_gen_tags` | \"AI Generate Tags\" | ✅ Yes | Generate relevant tags for your content using AI |","-| `ai_gen_content` | \"AI Generate Content\" | ✅ Yes | Generate new content from scratch using AI |","+## 1. Frontend Layer"," ","----","+### Location","+- `/src/utils/workflowUtils.ts` - Action options and default configs","+- `/src/schemas/workflows/actionSchemas.ts` - Zod validation schemas"," ","-## Critical Finding: `ai_add_*` vs `ai_gen_*` Naming Confusion","+### Available AI Actions in UI"," ","-### The Problem","-There are **TWO SETS** of similar-sounding actions with different internal names but **identical functionality**:","+| Action Value | Display Label | Status | Config Fields |","+|--------------|--------------|--------|---------------|","+| `ai_rewrite` | \"AI Rewrite Content\" | ✅ Enabled | style, tone, length, content, user_instructions |","+| `ai_translate` | \"AI Translate Content\" | ✅ Enabled | language, preserve_formatting, content, user_instructions |","+| `ai_summarize` | \"AI Summarize Content\" | ❌ Disabled | max_length, format, content, user_instructions |","+| `ai_gen_title` | \"AI Generate Title\" | ✅ Enabled | style, max_length, content, user_instructions |","+| `ai_add_title` | \"AI Add Title\" | ✅ Enabled | style, max_length, content, user_instructions |","+| `ai_gen_tags` | \"AI Generate Tags\" | ✅ Enabled | maxTags, categories, content, user_instructions |","+| `ai_add_tags` | \"AI Generate Tags\" | ✅ Enabled | content, user_instructions (⚠️ missing maxTags, categories) |","+| `ai_gen_content` | \"AI Generate Content\" | ✅ Enabled | length, tone, style, format, content, user_instructions |"," ","-1. **Title Actions:**","-   - `ai_add_title` - \"AI Add Title\"","-   - `ai_gen_title` - \"AI Generate Title\"","+### Schema Definitions"," ","-2. **Tag Actions:**","-   - `ai_add_tags` - \"AI Generate Tags\" (note: same label as gen_tags!)","-   - `ai_gen_tags` - \"AI Generate Tags\"","+All action schemas extend `BaseActionSchema`:","+```typescript","+BaseActionSchema {","+  user_instructions?: string","+  conditions?: Condition[]  // Left-to-right evaluation with AND/OR tokens","+}","+```"," ","-### Frontend Configuration Comparison","+#### AI Action Schemas"," ","-#### `ai_add_title` vs `ai_gen_title`","-**File:** `/src/utils/workflowUtils.ts` (lines 80-94)","+**AIRewriteActionSchema**","+```typescript","+{","+  title?: string | null","+  content: string","+  style: \"professional\" | \"casual\" | \"formal\" | \"friendly\" | \"match\"","+  tone: \"positive\" | \"neutral\" | \"negative\" | \"match\"","+  length: \"shorter\" | \"same\" | \"longer\"","+}","+```"," ","-Both return **IDENTICAL** default configs:","+**TranslateActionSchema**"," ```typescript","-// ai_gen_title (line 80-86)","-case \"ai_gen_title\":","-  return {","-    ...baseConfig,","-    content: \"\",","-    style: \"professional\",","-    max_length: undefined,","-  } as AIAddTitleActionConfig;","+{","+  content: string","+  language: string           // ISO language code (e.g., \"en\", \"es\", \"fr\")","+  preserve_formatting: boolean","+}","+```"," ","-// ai_add_title (line 88-94)","-case \"ai_add_title\":","-  return {","-    ...baseConfig,","-    content: \"\",","-    style: \"professional\",","-    max_length: undefined,","-  } as AIAddTitleActionConfig;  // ← SAME TYPE!","+**AISummarizeActionSchema**","+```typescript","+{","+  title?: string | null","+  content: string","+  max_length?: number","+  format: \"bullet_points\" | \"paragraph\" | \"key_points\"","+}"," ```"," ","-**⚠️ BUG #8:** Both use `AIAddTitleActionConfig` type - they are functionally identical aliases.","+**AIGenerateContentActionSchema**","+```typescript","+{","+  title?: string | null","+  content: string","+  length: \"shorter\" | \"same\" | \"longer\"","+  tone: \"positive\" | \"neutral\" | \"negative\" | \"match\"","+  style: \"professional\" | \"casual\" | \"formal\" | \"friendly\" | \"match\"","+}","+```"," ","-#### `ai_add_tags` vs `ai_gen_tags`","-**File:** `/src/utils/workflowUtils.ts` (lines 96-108)","-","+**AIAddTitleActionSchema**"," ```typescript","-// ai_gen_tags (line 96-102)","-case \"ai_gen_tags\":","-  return {","-    ...baseConfig,","-    content: \"\",","-    maxTags: undefined,       // ← Has maxTags","-    categories: [],           // ← Has categories","-  } as AIAddTagsActionConfig;","+{","+  title?: string | null","+  content: string","+  style?: \"professional\" | \"casual\" | \"formal\" | \"friendly\" | \"match\"","+  max_length?: number","+}","+```"," ","-// ai_add_tags (line 104-108)","-case \"ai_add_tags\":","-  return {","-    ...baseConfig,","-    content: \"\",","-    // ← Missing maxTags and categories!","-  } as AIAddTagsActionConfig;","+**AIAddTagsActionSchema**","+```typescript","+{","+  title?: string | null","+  content: string","+  max_tags?: number","+  categories?: string[]","+}"," ```"," ","-**⚠️ BUG #9:** `ai_add_tags` is a **degraded version** of `ai_gen_tags` - it doesn't include `maxTags` or `categories` in default config.","+### Validation"," ","+The frontend uses `ActionConfigSchema` (Zod discriminated union) to validate configs before saving to database. All configs are type-safe and validated at compile-time and runtime.","+","+### Inconsistencies in Frontend","+","+1. **Duplicate Actions**: `ai_add_title` and `ai_gen_title` are functionally identical","+2. **Duplicate Actions**: `ai_add_tags` and `ai_gen_tags` both show \"AI Generate Tags\" label","+3. **Incomplete Config**: `ai_add_tags` default config is missing `maxTags` and `categories` fields","+4. **Disabled Action**: `ai_summarize` is fully implemented but disabled (line 325)","+"," ---"," ","-## Backend Implementation Analysis","+## 2. WorkflowManager Layer"," ","-### Actions That Exist in Backend","-**File:** `/functions/WorkflowManager/src/handlers/actions/aiActions.ts`","+### Location","+- `/functions/WorkflowManager/src/handlers/workflowActions.ts` - Action routing","+- `/functions/WorkflowManager/src/handlers/actions/aiActions.ts` - AI action handlers"," ","-| Backend Handler | Frontend Action(s) | Notes |","-|----------------|-------------------|-------|","-| `handleAiRewrite()` | `ai_rewrite`, `ai_gen_content`, `ai_generate_content` | ⚠️ Three actions → one handler |","-| `handleAiTranslate()` | `ai_translate` | ✅ Correct mapping |","-| `handleAiSummarize()` | `ai_summarize` | ✅ Correct mapping |","-| `handleAiGenerateTitle()` | `ai_gen_title`, `ai_add_title` | ⚠️ Two actions → one handler |","-| `handleAiAddHashtags()` | `ai_gen_tags`, `ai_add_tags` | ⚠️ Two actions → one handler |","+### Action Routing"," ","-### Missing Backend Handlers","-None! But several actions share the same handler.","+The WorkflowManager routes multiple action names to the same handler:"," ","----","+```typescript","+// Routing in handleWorkflowAction()","+switch (action) {","+  case 'ai_rewrite':","+  case 'ai_gen_content':","+  case 'ai_generate_content':","+    return await aiActions.handleAiRewrite(...);"," ","-## Detailed Action Specifications","+  case 'ai_translate':","+    return await aiActions.handleAiTranslate(...);"," ","-### 1. `ai_rewrite`","-**Frontend Label:** \"AI Rewrite Content\"","-**Backend Handler:** `handleAiRewrite()` (line 36)","-**Status:** ✅ Fully implemented","+  case 'ai_summarize':","+    return await aiActions.handleAiSummarize(...);"," ","-**Purpose:** Rewrite existing content with style/tone/length changes","+  case 'ai_add_hashtags':","+  case 'ai_add_tags':","+  case 'ai_gen_tags':","+    return await aiActions.handleAiAddHashtags(...);"," ","-**Frontend Config:**","+  case 'ai_gen_title':","+  case 'ai_add_title':","+    return await aiActions.handleAiGenerateTitle(...);","+}","+```","+","+### Handler Implementations","+","+Each handler follows this pattern:","+1. Extract `genericPost` from `postData.postData`","+2. Add platform-specific instructions (e.g., Bluesky 300 char limit)","+3. Build request data matching frontend schema","+4. Create JWT for authentication","+5. Build `ActionConfig` with action type","+6. Call AI_API via `appwriteManager.executeAIFunction()`","+7. Process response and update `genericPost`","+8. Return updated `PostContainer`","+","+#### handleAiRewrite()","+","+**Input**: `AIRewriteActionConfig` from frontend","+**Sends to AI_API**:"," ```typescript"," {","-  user_instructions: \"\",","-  conditions: [],","-  style: \"professional\",      // professional, casual, formal, friendly, match","-  tone: \"neutral\",           // positive, neutral, negative, match","-  length: \"same\",            // shorter, same, longer","-  content: \"\",","+  action: 'ai_rewrite',","+  title?: string,","+  content: string,           // from genericPost.text","+  style: StyleEnum,","+  tone: ToneEnum,","+  length: LengthEnum,","+  user_instructions?: string"," }"," ```"," ","-**Backend Processing:**","-- Replaces `genericPost.text` with rewritten content","-- Updates `genericPost.title` if AI returns one","-- Applies Bluesky character limit if platform is Bluesky","+**Processes Response**:","+- Updates `genericPost.text` from `response.result.content`","+- Updates `genericPost.title` from `response.result.title` (if present)"," ","----","+**⚠️ Issue**: Also handles `ai_gen_content` action, but \"rewrite\" logic doesn't match \"generate new content\" semantics"," ","-### 2. `ai_translate`","-**Frontend Label:** \"AI Translate Content\"","-**Backend Handler:** `handleAiTranslate()` (line 113)","-**Status:** ✅ Fully implemented (after field fix)","+#### handleAiTranslate()"," ","-**Purpose:** Translate content to target language","-","-**Frontend Config:**","+**Input**: `TranslateActionConfig` from frontend","+**Sends to AI_API**:"," ```typescript"," {","-  user_instructions: \"\",","-  conditions: [],","-  content: \"\",","-  language: \"en\",                    // Target language code","-  preserve_formatting: true,","+  action: 'ai_translate',","+  title?: string,","+  content: string,","+  target_language: string,    // ⚠️ Field name changed from 'language'","+  preserve_formatting: boolean,","+  user_instructions?: string"," }"," ```"," ","-**Backend Processing:**","-- Sends as `target_language` to AI_API (fixed!)","-- Replaces `genericPost.text` with translated content","-- Updates `genericPost.title` if present","+**Processes Response**:","+- Updates `genericPost.text` from `response.result.content`","+- Updates `genericPost.title` from `response.result.title` (if present)"," ","----","+**Field Mapping**: Frontend sends `language`, WorkflowManager sends `target_language`"," ","-### 3. `ai_summarize`","-**Frontend Label:** \"AI Summarize Content\"","-**Backend Handler:** `handleAiSummarize()` (line 181)","-**Status:** ⚠️ Disabled in frontend","+#### handleAiSummarize()"," ","-**Purpose:** Condense content into summary","-","-**Frontend Config:**","+**Input**: `AISummarizeActionConfig` from frontend","+**Sends to AI_API**:"," ```typescript"," {","-  user_instructions: \"\",","-  conditions: [],","-  max_length: undefined,","-  format: \"paragraph\",          // bullet_points, paragraph, key_points","-  content: \"\",","+  action: 'ai_summarize',","+  title?: string,","+  content: string,","+  max_length?: number,","+  format: FormatEnum,","+  user_instructions?: string"," }"," ```"," ","-**Backend Processing:**","-- Replaces `genericPost.text` with summary","-- Updates `genericPost.title` if AI returns one","+**Processes Response**:","+- Updates `genericPost.text` from `response.result.content`","+- Updates `genericPost.title` from `response.result.title` (if present)"," ","-**⚠️ NOTE:** Disabled in frontend (line 325: `enabled: false`)","+#### handleAiGenerateTitle()"," ","----","+**Input**: `AIAddTitleActionConfig` from frontend","+**Sends to AI_API**:","+```typescript","+{","+  action: 'ai_gen_title',    // ⚠️ Always sends 'ai_gen_title'","+  title?: string,","+  content: string,","+  style: StyleEnum,","+  max_length?: number,","+  user_instructions?: string","+}","+```"," ","-### 4. `ai_gen_content` (and alias `ai_generate_content`)","-**Frontend Label:** \"AI Generate Content\"","-**Backend Handler:** `handleAiRewrite()` ⚠️","-**Status:** ⚠️ No dedicated implementation","+**Processes Response**:","+- Updates `genericPost.title` from `response.result.title`","+- Does NOT modify `genericPost.text`"," ","-**Purpose:** Generate NEW content from scratch","+**⚠️ Note**: Both `ai_add_title` and `ai_gen_title` send action as `'ai_gen_title'`"," ","-**Frontend Config:**","+#### handleAiAddHashtags()","+","+**Input**: `AIAddTagsActionConfig` from frontend","+**Sends to AI_API**:"," ```typescript"," {","-  user_instructions: \"\",","-  conditions: [],","-  length: \"same\",","-  tone: \"match\",","-  style: \"match\",","-  format: \"paragraph\",","-  content: \"\",","+  action: 'ai_gen_tags',     // ⚠️ Always sends 'ai_gen_tags'","+  title?: string,","+  content: string,","+  max_tags?: number,","+  categories?: string[],","+  user_instructions?: string"," }"," ```"," ","-**Backend Routing:**","+**Processes Response**:"," ```typescript","-// From workflowActions.ts","-case 'ai_rewrite':","-case 'ai_gen_content':","-case 'ai_generate_content':","-  return await aiActions.handleAiRewrite(...);","+// Expects response.result.tags array","+if (response.result.tags) {","+  genericPost.text = `${genericPost.text} ${response.result.tags.join(' ')}`;","+}"," ```"," ","-**⚠️ BUG #10:** `ai_gen_content` routes to `handleAiRewrite()`, so it **rewrites** existing content instead of generating new content. The action name is misleading.","+**⚠️ CRITICAL ISSUE**: Expects `response.result.tags` array, but AI_API returns `ActionResult` with only `content` and `title` fields. This will cause tag generation to fail!"," ","-**What SHOULD happen:** Generate completely new content based on prompt/instructions, not rewrite existing text.","+### Data Flow"," ","+```","+Frontend Config → WorkflowManager Handler → AI_API Request","+","+Example for ai_translate:","+{                         {                          {","+  language: \"es\"     →    target_language: \"es\"  →    target_language: \"es\"","+  content: \"Hello\"        content: \"Hello\"            content: \"Hello\"","+  preserve_formatting     preserve_formatting         action: \"ai_translate\"","+}                         user_instructions           ...","+                        }                          }","+```","+"," ---"," ","-### 5. `ai_add_title` and `ai_gen_title`","-**Frontend Labels:** \"AI Add Title\" and \"AI Generate Title\"","-**Backend Handler:** `handleAiGenerateTitle()` (line 313)","-**Status:** ⚠️ Duplicate/alias actions","+## 3. AI_API Layer"," ","-**Purpose:** Generate a title for content","+### Location","+- `/functions/AI_API/src/main.py` - Entry point and routing","+- `/functions/AI_API/src/services/ai_service.py` - Main AI processing","+- `/functions/AI_API/src/workflows/ai_workflow.py` - LlamaIndex workflow","+- `/functions/AI_API/src/schemas/requests.py` - Request schemas","+- `/functions/AI_API/src/schemas/responses.py` - Response schemas"," ","-**Frontend Config (IDENTICAL for both):**","-```typescript","-{","-  user_instructions: \"\",","-  conditions: [],","-  content: \"\",","-  style: \"professional\",      // Optional style","-  max_length: undefined,","-}","-```","+### Request Flow"," ","-**Backend Processing:**","-- Sets `genericPost.title` to generated title","-- Does NOT modify `genericPost.text`","-- Sends as `action: 'ai_gen_title'` to AI_API","+1. **main.py → handle_action()**","+   - Validates `ActionRequest` schema","+   - Extracts user_id from headers or request body","+   - Authenticates via JWT"," ","-**⚠️ BUG #11:** Both `ai_add_title` and `ai_gen_title` are **functionally identical**. The distinction is purely naming/UI labels. This creates confusion for users - what's the difference between \"Add Title\" vs \"Generate Title\"?","+2. **AIService.process_action()**","+   - Validates user credits via `BillingService`","+   - Estimates token usage based on action type","+   - Selects LLM (nano for simple, smart for complex)","+   - Creates `AIWorkflow` instance"," ","-**Recommendation:** Remove one of these actions, or differentiate them:","-- `ai_add_title` - Add title to posts that don't have one","-- `ai_gen_title` - Replace existing title with new AI-generated one","+3. **AIWorkflow (LlamaIndex)**","+   - Implements agentic workflow with events:","+     - `StartEvent` → `ContentAnalysisEvent`","+     - `ContentAnalysisEvent` → `ToolExecutionEvent`","+     - `ToolExecutionEvent` → `OptimizationEvent` or `StopEvent`","+     - `OptimizationEvent` → `StopEvent` or loop back","+   - Uses function calling with tools:","+     - `analyze_sentiment` - Analyze tone and sentiment","+     - `check_constraints` - Validate platform limits","+     - `optimize_platform` - Platform-specific optimization","+     - `validate_quality` - Quality checks","+     - `complete_optimization` - Signal completion"," ","----","+### Request Schema"," ","-### 6. `ai_add_tags` and `ai_gen_tags`","-**Frontend Labels:** Both show \"AI Generate Tags\" (!!)","-**Backend Handler:** `handleAiAddHashtags()` (line 246)","-**Status:** ⚠️ Duplicate/alias actions with config differences","+```python","+class ActionRequest(BaseModel):","+    action: Literal[","+        \"ai_translate\",","+        \"ai_rewrite\",","+        \"ai_summarize\",","+        \"ai_gen_content\",","+        \"ai_gen_title\",","+        \"ai_gen_tags\"","+    ]","+    content: str"," ","-**Purpose:** Generate and append hashtags","+    # Action-specific parameters","+    target_language: str | None","+    tone: str | None","+    length: Literal[\"shorter\", \"longer\", \"same\"] | None","+    platform: str | None","+    style: str | None"," ","-**Frontend Config Comparison:**","-```typescript","-// ai_gen_tags - FULL config","-{","-  user_instructions: \"\",","-  conditions: [],","-  content: \"\",","-  maxTags: undefined,         // ✅ Can limit number of tags","-  categories: [],             // ✅ Can specify tag themes","-}","+    # Common parameters","+    max_tokens: int = 2000","+    temperature: float = 0.7","+    context: dict[str, Any] = {}","+```"," ","-// ai_add_tags - INCOMPLETE config","-{","-  user_instructions: \"\",","-  conditions: [],","-  content: \"\",","-  // ❌ Missing maxTags","-  // ❌ Missing categories","-}","+### Response Schema","+","+```python","+class ActionResult(BaseModel):","+    content: str                    # Processed content","+    title: str | None = None        # Optional title","+","+class ActionResponse(BaseModel):","+    result: ActionResult            # ⚠️ Only content + title","+    action: str","+    model_used: str","+    tokens: TokenUsage","+    response_time_ms: int","+    confidence_score: float | None","+    optimizations_applied: list[str]","+    warnings: list[str]"," ```"," ","-**Backend Processing:**","-- Expects `response.result.tags` array","-- **APPENDS** hashtags to existing `genericPost.text`","-- Does NOT modify `genericPost.title`","-- Sends as `action: 'ai_gen_tags'` to AI_API","+### Supported Actions"," ","-**⚠️ BUG #12:**","-1. Both actions have identical UI labels: \"AI Generate Tags\"","-2. `ai_add_tags` has incomplete default config (missing `maxTags` and `categories`)","-3. Both send `action: 'ai_gen_tags'` to backend","-4. Users have no way to distinguish between them in the UI","+**ai_rewrite**","+- Routes to AIWorkflow with rewrite optimization","+- Returns: `{ content: rewritten_text, title: optional }`"," ","-**⚠️ BUG #13:** Response validation expects `response.result.tags` but with ActionResult structure, tags might be in different location.","+**ai_translate**","+- Routes to AIWorkflow with translation parameters","+- Uses `target_language` field","+- Returns: `{ content: translated_text, title: optional }`"," ","----","+**ai_summarize**","+- Routes to AIWorkflow with summarization","+- Returns: `{ content: summary_text, title: optional }`"," ","-## Naming Convention Issues","+**ai_gen_content**","+- Routes to AIWorkflow (currently same as rewrite)","+- Returns: `{ content: generated_text, title: optional }`"," ","-### Inconsistent Naming Patterns","+**ai_gen_title**","+- Routes to AIWorkflow with title generation","+- Special handling in ai_service.py:","+  ```python","+  if action_request.action == \"ai_gen_title\" and not processed_title:","+      processed_title = processed_content","+      processed_content = action_request.content  # Keep original","+  ```","+- Returns: `{ content: original_or_empty, title: generated_title }`"," ","-**Pattern 1: `ai_*` (verb-based)**","-- `ai_rewrite` ✅","-- `ai_translate` ✅","-- `ai_summarize` ✅","+**ai_gen_tags**","+- Routes to AIWorkflow with tag generation","+- ⚠️ **PROBLEM**: Returns `{ content: tags_as_string, title: null }`","+- WorkflowManager expects `{ tags: string[] }` in result"," ","-**Pattern 2: `ai_gen_*` (generate-based)**","-- `ai_gen_content` ⚠️","-- `ai_gen_title` ⚠️","-- `ai_gen_tags` ⚠️","+### LlamaIndex Workflow Details"," ","-**Pattern 3: `ai_add_*` (add-based)**","-- `ai_add_title` ⚠️ Duplicate of ai_gen_title","-- `ai_add_tags` ⚠️ Duplicate of ai_gen_tags","+The `AIWorkflow` implements a sophisticated agentic pattern:"," ","-### Recommended Naming Cleanup","+1. **Analysis Phase**","+   - Builds analysis prompt with action context","+   - LLM decides which tools to call","+   - Tools provide insights (sentiment, constraints, etc.)"," ","-**Option A: Remove `ai_add_*` variants (Recommended)**","-Keep only:","-- `ai_rewrite`","-- `ai_translate`","-- `ai_summarize`","-- `ai_gen_content` (fix to actually generate)","-- `ai_gen_title`","-- `ai_gen_tags`","+2. **Execution Phase**","+   - Executes tool calls","+   - Checks for `complete_optimization` tool","+   - If complete, returns final result","+   - Otherwise, proceeds to optimization"," ","-**Option B: Differentiate Clearly**","-- `ai_gen_title` - Generate new title from scratch","-- `ai_add_title` - Add title only if missing","-- `ai_gen_tags` - Generate new tags (with control)","-- `ai_add_tags` - Quick tag generation (no config)","+3. **Optimization Phase**","+   - Builds optimization prompt with tool results","+   - LLM generates optimized content","+   - Validates quality (score 0-1)","+   - If quality ≥ 0.8 or max attempts reached, stops","+   - Otherwise, loops back to analysis"," ","+4. **Safeguards**","+   - Max 3 optimization attempts","+   - Forced completion after max attempts","+   - Tool execution error handling","+","+### Token Estimation & Billing","+","+```python","+def _estimate_action_tokens(action_request):","+    content_length = len(action_request.content)","+    input_tokens = max(100, int(content_length * TOKENS_PER_CHARACTER))","+    multiplier = ACTION_TOKEN_MULTIPLIERS.get(action_request.action, 1.5)","+    total = (input_tokens * multiplier) + SYSTEM_PROMPT_OVERHEAD","+    return int(total * TOKEN_ESTIMATION_BUFFER)","+```","+","+**Token Multipliers**:","+- `ai_translate`: 1.8x (higher due to translation accuracy)","+- `ai_rewrite`: 1.5x","+- `ai_summarize`: 1.3x (shorter output)","+- `ai_gen_content`: 2.0x (generates from scratch)","+- Default: 1.5x","+"," ---"," ","-## Schema Type Hierarchy","+## 4. Data Flow Comparison"," ","+### Request Journey: ai_translate","+","+```","+FRONTEND                    WORKFLOWMANAGER                 AI_API","+─────────                   ───────────────                 ──────","+","+User selects:","+\"Translate to Spanish\"","+","+getDefaultConfig():","+{","+  language: \"es\",      →    Extract from config        →    ActionRequest:","+  preserve_formatting        Build request:                 {","+    : true,                  {                                action: \"ai_translate\"","+  content: \"\",                 target_language: \"es\", →      target_language: \"es\"","+  user_instructions:           content: post.text,           content: \"Hello world\"","+    \"\"                         preserve_formatting:          preserve_formatting:","+}                                true                           true","+                              }                               max_tokens: 2000","+                                                              temperature: 0.7","+                                                           }","+                                                                │","+                                                                ▼","+                                                           AIWorkflow:","+                                                           1. Analyze content","+                                                           2. Check constraints","+                                                           3. Translate","+                                                           4. Validate quality","+                                                                │","+                              Response:              ◀───      ▼","+                              {                            ActionResponse:","+                                result: {                  {","+                                  content:                   result: {","+                                    \"Hola mundo\"               content: \"Hola...\"","+                                  title: null                  title: null","+                                }                            }","+                              }                              action: \"ai_...\"","+                                                             tokens: {...}","+                                                           }","+                              │","+                              ▼","+                         Update post:","+                         post.text =","+                           \"Hola mundo\"","+```","+","+### Response Processing Patterns","+","+| Action | WorkflowManager Expects | AI_API Returns | Update Logic |","+|--------|------------------------|----------------|--------------|","+| `ai_rewrite` | `result.content`, `result.title` | ✅ `ActionResult { content, title? }` | Updates `text` and/or `title` |","+| `ai_translate` | `result.content`, `result.title` | ✅ `ActionResult { content, title? }` | Updates `text` and/or `title` |","+| `ai_summarize` | `result.content`, `result.title` | ✅ `ActionResult { content, title? }` | Updates `text` and/or `title` |","+| `ai_gen_title` | `result.title` | ✅ `ActionResult { content, title }` | Updates `title` only |","+| `ai_gen_tags` | ❌ `result.tags[]` | ⚠️ `ActionResult { content, title? }` | **MISMATCH** - expects array, gets string |","+","+---","+","+## 5. Key Inconsistencies & Issues","+","+### Issue 1: Tag Generation Response Mismatch","+","+**Problem**: WorkflowManager expects tags as array, AI_API returns as content string","+","+**Location**:","+- `functions/WorkflowManager/src/handlers/actions/aiActions.ts:289-300`","+- `functions/AI_API/src/schemas/responses.py:16-20`","+","+**Current Code**:"," ```typescript","-// Frontend: /src/schemas/workflows/actionSchemas.ts","-BaseActionSchema {","-  user_instructions?: string","-  conditions?: Condition[]","+// WorkflowManager expects:","+if (response.result.tags) {","+  genericPost.text = `${genericPost.text} ${response.result.tags.join(' ')}`;"," }"," ","-AIRewriteActionSchema extends BaseActionSchema {","-  title?: string | null","-  content: string","-  style: StyleEnum","-  tone: ToneEnum","-  length: LengthEnum","+// AI_API returns:","+ActionResult {","+  content: string,    // Tags as string, not array","+  title: null"," }","+```"," ","-TranslateActionSchema extends BaseActionSchema {","-  content: string","-  language: string","-  preserve_formatting: boolean","-}","+**Impact**: Tag generation will fail - the `.tags` property doesn't exist"," ","-AISummarizeActionSchema extends BaseActionSchema {","-  title?: string | null","-  content: string","-  max_length?: number","-  format: FormatEnum","-}","+**Solution Options**:","+1. Change AI_API to return tags in a `tags` field","+2. Change WorkflowManager to parse tags from `content` string","+3. Add tags field to `ActionResult` schema"," ","-AIGenerateContentActionSchema extends BaseActionSchema {","-  title?: string | null","-  content: string","-  length: LengthEnum","-  tone: ToneEnum","-  style: StyleEnum","-}","+### Issue 2: Duplicate Action Handlers"," ","-AIAddTitleActionSchema extends BaseActionSchema {","-  title?: string | null","-  content: string","-  style?: StyleEnum","-  max_length?: number","-}","+**Problem**: Multiple frontend actions map to single handler"," ","-AIAddTagsActionSchema extends BaseActionSchema {","-  title?: string | null","-  content: string","-  max_tags?: number","-  categories?: string[]","-}","+**Actions Affected**:","+- `ai_gen_content` + `ai_generate_content` → uses rewrite handler (semantically incorrect)","+- `ai_add_title` + `ai_gen_title` → identical functionality","+- `ai_add_tags` + `ai_gen_tags` → identical functionality","+","+**Impact**:","+- Confusing for users (duplicate options)","+- `ai_gen_content` doesn't actually \"generate new content\", it rewrites existing","+","+**Recommendation**:","+- Remove `ai_add_*` variants, keep only `ai_gen_*`","+- Create dedicated handler for `ai_gen_content` that actually generates new content","+","+### Issue 3: Field Name Inconsistency","+","+**Problem**: Field renamed between layers","+","+**Flow**:"," ```","+Frontend: language: \"es\"","+    ↓","+WorkflowManager: target_language: \"es\"","+    ↓","+AI_API: target_language: \"es\"","+```"," ","----","+**Impact**: Minor - doesn't break functionality but adds confusion"," ","-## Bug Summary","+**Recommendation**: Use consistent field names across all layers"," ","-### 🐛 Bug #8: Identical Title Action Aliases","-**Actions:** `ai_add_title` and `ai_gen_title`","-**Issue:** Both use identical config and type, no functional difference","-**Impact:** Confusing for users, duplicate UI options","+### Issue 4: Incomplete Default Config"," ","-### 🐛 Bug #9: Incomplete Tag Action Config","-**Action:** `ai_add_tags`","-**Issue:** Missing `maxTags` and `categories` in default config","-**Impact:** Less control than `ai_gen_tags`, inconsistent behavior","+**Problem**: `ai_add_tags` missing fields in default config"," ","-### 🐛 Bug #10: Content Generation Routes to Rewrite","-**Action:** `ai_gen_content`","-**Issue:** Routes to `handleAiRewrite()` instead of generating new content","-**Impact:** Misleading action name, doesn't actually generate content","+**Location**: `src/utils/workflowUtils.ts:104-108`"," ","-### 🐛 Bug #11: Duplicate Title Actions","-**Actions:** `ai_add_title`, `ai_gen_title`","-**Issue:** Functionally identical, both enabled in UI","-**Impact:** User confusion, unnecessary duplication","+```typescript","+// ai_gen_tags - complete","+case \"ai_gen_tags\":","+  return {","+    content: \"\",","+    maxTags: undefined,","+    categories: [],","+  };"," ","-### 🐛 Bug #12: Duplicate Tag Actions with Same Label","-**Actions:** `ai_add_tags`, `ai_gen_tags`","-**Issue:** Both show \"AI Generate Tags\" label in UI","-**Impact:** Users cannot distinguish between them","+// ai_add_tags - incomplete","+case \"ai_add_tags\":","+  return {","+    content: \"\",","+    // Missing: maxTags, categories","+  };","+```"," ","-### 🐛 Bug #13: Tag Response Structure Mismatch","-**Action:** `ai_gen_tags`, `ai_add_tags`","-**Issue:** Expects `response.result.tags` but ActionResult has `{content, title}`","-**Impact:** Tag generation will fail","+**Impact**: Users can't configure max tags or categories for `ai_add_tags`"," ","+**Recommendation**: Add missing fields or remove duplicate action","+","+### Issue 5: ai_summarize Disabled","+","+**Problem**: Fully implemented action is disabled in frontend","+","+**Location**: `src/utils/workflowUtils.ts:325`","+","+**Impact**: Users can't access summarization feature","+","+**Recommendation**: Enable the action or document why it's disabled","+"," ---"," ","-## Recommendations","+## 6. Schema Compatibility Matrix"," ","+| Schema Field | Frontend | WorkflowManager Sends | AI_API Expects | Notes |","+|--------------|----------|----------------------|----------------|-------|","+| `action` | ✅ | ✅ | ✅ | All layers use same values |","+| `content` | ✅ | ✅ | ✅ | Required in all layers |","+| `title` | ✅ | ✅ Optional | ❌ Not in request | Only in response |","+| `language` | ✅ | ❌ Renamed | ❌ | Becomes `target_language` |","+| `target_language` | ❌ | ✅ | ✅ | Used in Manager & API |","+| `style` | ✅ | ✅ | ✅ | Enum validated |","+| `tone` | ✅ | ✅ | ✅ | Enum validated |","+| `length` | ✅ | ✅ | ✅ | Enum validated |","+| `format` | ✅ | ✅ | ❌ Not in request | For summarize action |","+| `max_tags` | ✅ | ✅ | ❌ Not in request | For tag actions |","+| `maxTags` | ✅ | ✅ as `max_tags` | ❌ | Naming inconsistency |","+| `categories` | ✅ | ✅ | ❌ Not in request | For tag actions |","+| `preserve_formatting` | ✅ | ✅ | ❌ Not in request | For translate |","+| `user_instructions` | ✅ | ✅ | ❌ Not in request | All actions |","+| `conditions` | ✅ | ✅ Checked | ❌ | Frontend/Manager only |","+","+**⚠️ Note**: Many frontend config fields are NOT sent to AI_API because the ActionRequest schema is simplified. The AI_API infers behavior from the `action` type and a few key parameters.","+","+---","+","+## 7. Recommendations","+"," ### High Priority","-1. **Remove duplicate actions:** Keep only `ai_gen_title` and `ai_gen_tags`, remove `ai_add_*` variants","-2. **Fix `ai_gen_content`:** Create dedicated handler that actually generates new content","-3. **Fix tag response validation:** Update to match ActionResult structure","-4. **Update UI labels:** Ensure all actions have unique, descriptive labels"," ","+1. **Fix Tag Response Structure**","+   - Option A: Add `tags: string[]` field to `ActionResult`","+   - Option B: Change WorkflowManager to parse tags from content","+   - Recommended: Option A (cleaner separation)","+","+2. **Create Dedicated ai_gen_content Handler**","+   - Current: Routes to rewrite handler (incorrect semantics)","+   - New: Create handler that generates content from scratch based on prompt/instructions","+","+3. **Remove Duplicate Actions**","+   - Remove `ai_add_title` (keep `ai_gen_title`)","+   - Remove `ai_add_tags` (keep `ai_gen_tags`)","+   - Rationale: Reduces user confusion, identical functionality","+"," ### Medium Priority","-5. **Standardize naming:** Use consistent `ai_verb_*` or `ai_gen_*` pattern","-6. **Enable `ai_summarize`:** Currently disabled but fully implemented","-7. **Document action differences:** Clear user-facing docs explaining each action"," ","+4. **Standardize Field Names**","+   - Use `target_language` in all layers (frontend, manager, API)","+   - Use consistent naming: `maxTags` vs `max_tags`","+","+5. **Complete Default Configs**","+   - Add `maxTags` and `categories` to `ai_add_tags` default config","+   - Or remove the action entirely","+","+6. **Enable ai_summarize**","+   - Action is fully implemented","+   - Either enable it or document why it's disabled","+"," ### Low Priority","-8. **Consider merging configs:** Standardize config options across similar actions","-9. **Add action categories:** Group related actions in UI for better UX","-10. **Implement action validation:** Warn users when selecting duplicate-function actions"," ","+7. **Document Action Capabilities**","+   - Add user-facing documentation explaining each action","+   - Include examples of before/after for each action","+","+8. **Expand ActionRequest Schema**","+   - Consider adding more fields from frontend schemas","+   - Would allow more granular control from AI_API","+","+9. **Add Response Validation**","+   - Validate AI_API responses match expected structure","+   - Return user-friendly errors on validation failures","+"," ---"," ","-## Testing Checklist","+## 8. Testing Checklist"," ","-After fixes:","-- [ ] Remove `ai_add_title` from UI or differentiate from `ai_gen_title`","-- [ ] Remove `ai_add_tags` from UI or fix its default config","-- [ ] Create `handleAiGenerateContent()` for `ai_gen_content`","-- [ ] Update tag response validation","-- [ ] Verify unique labels for all actions","-- [ ] Test each action produces expected output","-- [ ] Ensure backend handlers match frontend action names","\\ No newline at end of file","+After implementing fixes:","+","+- [ ] Test tag generation returns tags in correct format","+- [ ] Verify `ai_gen_content` generates new content (not rewrites)","+- [ ] Confirm removed duplicate actions","+- [ ] Validate consistent field names across layers","+- [ ] Test each action with various platforms (Twitter, Instagram, etc.)","+- [ ] Verify Bluesky character limit enforcement","+- [ ] Test condition evaluation with AND/OR operators","+- [ ] Validate credit deduction for each action type","+- [ ] Confirm response times are acceptable","+- [ ] Test error handling for insufficient credits","+","+---","+","+## Appendix: Complete Action Reference","+","+### ai_rewrite","+**Purpose**: Rewrite existing content with style/tone/length adjustments","+**Frontend Config**: style, tone, length, content, user_instructions","+**Manager Sends**: Same as frontend","+**API Returns**: `{ content: rewritten_text, title?: optional }`","+**Updates**: `genericPost.text` and optionally `genericPost.title`","+","+### ai_translate","+**Purpose**: Translate content to target language","+**Frontend Config**: language, preserve_formatting, content, user_instructions","+**Manager Sends**: target_language (renamed), preserve_formatting, content","+**API Returns**: `{ content: translated_text, title?: optional }`","+**Updates**: `genericPost.text` and optionally `genericPost.title`","+","+### ai_summarize","+**Purpose**: Create concise summary of content","+**Frontend Config**: max_length, format, content, user_instructions","+**Manager Sends**: Same as frontend","+**API Returns**: `{ content: summary_text, title?: optional }`","+**Updates**: `genericPost.text` and optionally `genericPost.title`","+**Status**: ⚠️ Disabled in frontend","+","+### ai_gen_content","+**Purpose**: Generate new content from scratch","+**Frontend Config**: length, tone, style, format, content, user_instructions","+**Manager Sends**: Same as frontend","+**API Returns**: `{ content: generated_text, title?: optional }`","+**Updates**: `genericPost.text` and optionally `genericPost.title`","+**⚠️ Issue**: Currently routes to rewrite handler","+","+### ai_gen_title / ai_add_title","+**Purpose**: Generate title for content","+**Frontend Config**: style, max_length, content, user_instructions","+**Manager Sends**: Always sends as `ai_gen_title`","+**API Returns**: `{ content: empty_or_original, title: generated_title }`","+**Updates**: `genericPost.title` only (text unchanged)","+**⚠️ Issue**: Duplicate actions with identical functionality","+","+### ai_gen_tags / ai_add_tags","+**Purpose**: Generate hashtags for content","+**Frontend Config**: max_tags (maxTags), categories, content, user_instructions","+**Manager Sends**: Always sends as `ai_gen_tags`, expects `result.tags` array","+**API Returns**: `{ content: tags_as_string, title: null }`","+**Updates**: Appends tags to `genericPost.text`","+**⚠️ CRITICAL**: Response format mismatch - expects array, gets string"]}]}}
{"parentUuid":"18aa4793-ab43-4ef8-b43f-d8dc5bd690a6","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01AGp2F9wBShh7qgDhGG9ipt","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"thinking","thinking":"Perfect! I've created a comprehensive document that explains the entire AI actions system. Let me mark the todo as complete.","signature":"EqcCCkYICBgCKkDm4SPfR5KRGzWQWrvv+oJ2hQ4f2cTW8nUayZ1vbx3AvBtWrH4jrRLKf4UNTLSAJeU9UbFN3+jspeT7dcPTNMs+EgwYQLd9b6vn4KgmHzAaDM9HG0AcxWCGgYU+bCIwKXXLhz/Bl1EhYPR+ocYhjmQ+hLwQqrnDlAuX4slhCo3hilGwZMVh0ndmIrjo0/33Ko4Bo1Ycn9jOLe8io2y1AmV5JnxcUA80aWTEiTImmqVDCstxg0Vwtx6bZVBH9MEd+t6eGQOcfk3IRPdrDTWix18ng0WlcgilIGk8M9GFYtJ54tbmrPjrXDy+5T2TH2CBoU/3TlorRR92NfzDcK5+DS07xRpNmkDvlIfUvkt0ybgDw7KIqsqWKCu9iuoCLDU4rBgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":21152,"cache_read_input_tokens":76909,"cache_creation":{"ephemeral_5m_input_tokens":21152,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CTfEM3QZ4FtJq8VbdAB4T","type":"assistant","uuid":"ec7ae6b6-6db3-498f-ab3a-becdea058aa0","timestamp":"2025-09-30T20:39:32.906Z"}
{"parentUuid":"ec7ae6b6-6db3-498f-ab3a-becdea058aa0","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01AGp2F9wBShh7qgDhGG9ipt","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"tool_use","id":"toolu_015r3yrV1F87ymJo71GV4LLh","name":"TodoWrite","input":{"todos":[{"content":"Read frontend workflow utilities to understand action nodes and configs","activeForm":"Reading frontend workflow utilities","status":"completed"},{"content":"Read WorkflowManager AI action handlers","activeForm":"Reading WorkflowManager AI action handlers","status":"completed"},{"content":"Read AI_API implementation and schemas","activeForm":"Reading AI_API implementation and schemas","status":"completed"},{"content":"Analyze schemas and data flow between all three layers","activeForm":"Analyzing schemas and data flow","status":"completed"},{"content":"Create comprehensive rewritten documentation with visual diagrams","activeForm":"Creating comprehensive documentation","status":"completed"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":21152,"cache_read_input_tokens":76909,"cache_creation":{"ephemeral_5m_input_tokens":21152,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CTfEM3QZ4FtJq8VbdAB4T","type":"assistant","uuid":"8a2dd362-86db-46c1-8631-6307a3baf708","timestamp":"2025-09-30T20:39:36.097Z"}
{"parentUuid":"8a2dd362-86db-46c1-8631-6307a3baf708","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015r3yrV1F87ymJo71GV4LLh","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"14eac83c-2f23-4058-b30d-247ab1020cd6","timestamp":"2025-09-30T20:39:36.255Z","toolUseResult":{"oldTodos":[{"content":"Read frontend workflow utilities to understand action nodes and configs","status":"completed","activeForm":"Reading frontend workflow utilities"},{"content":"Read WorkflowManager AI action handlers","status":"completed","activeForm":"Reading WorkflowManager AI action handlers"},{"content":"Read AI_API implementation and schemas","status":"completed","activeForm":"Reading AI_API implementation and schemas"},{"content":"Analyze schemas and data flow between all three layers","status":"completed","activeForm":"Analyzing schemas and data flow"},{"content":"Create comprehensive rewritten documentation with visual diagrams","status":"in_progress","activeForm":"Creating comprehensive documentation"}],"newTodos":[{"content":"Read frontend workflow utilities to understand action nodes and configs","status":"completed","activeForm":"Reading frontend workflow utilities"},{"content":"Read WorkflowManager AI action handlers","status":"completed","activeForm":"Reading WorkflowManager AI action handlers"},{"content":"Read AI_API implementation and schemas","status":"completed","activeForm":"Reading AI_API implementation and schemas"},{"content":"Analyze schemas and data flow between all three layers","status":"completed","activeForm":"Analyzing schemas and data flow"},{"content":"Create comprehensive rewritten documentation with visual diagrams","status":"completed","activeForm":"Creating comprehensive documentation"}]}}
{"parentUuid":"14eac83c-2f23-4058-b30d-247ab1020cd6","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01XajGgGcmVoTo5DzYNghGdQ","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"thinking","thinking":"Great! All todos are complete. Let me provide a summary to the user about what I've done.","signature":"EoQCCkYICBgCKkC9haASZe2Ad5So9RWh7GnF2LSqTI5mqdl48E6qrX4qbqFEkCobqLB0oTvqnAZgFDWCe523PndY0UHvALkDmlCjEgz3gMVVY1fYlEIHy18aDIySkf/t1Vm284M2gyIwK1cjfGl9UYJIf+QLF4opohBxCgXpErizwX6BLBPM2NsUlFF2UQkW09qUMUOBdMGOKmydN/Aw6yheUa35XOkpCycJKE8OmTt3MfeX16g+gu8FQiW1BG5XE8MUWIq/gSY6q20uGP6FbBX6h8jRzyvihYRFTCgEY44CG2hzy1px+vMkb6td5H4B5N197K2aZb779TxDjSfoMVv384mZKEEYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":293,"cache_read_input_tokens":98061,"cache_creation":{"ephemeral_5m_input_tokens":293,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard"}},"requestId":"req_011CTfEMbzsUrEJ9uUBPc3co","type":"assistant","uuid":"c4e4592c-9b54-407d-9117-841ca3838546","timestamp":"2025-09-30T20:39:39.764Z"}
{"parentUuid":"c4e4592c-9b54-407d-9117-841ca3838546","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"117c566f-7389-4f0a-a37b-952822e9d9f1","version":"2.0.0","gitBranch":"functions-WorkflowManager","message":{"id":"msg_01XajGgGcmVoTo5DzYNghGdQ","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"text","text":"I've successfully rewritten the AI_ACTIONS_REFERENCE.md file with a comprehensive system architecture view. Here's what the new document includes:\n\n## Key Improvements\n\n**1. Visual System Architecture**\n- Complete data flow diagram showing Frontend → WorkflowManager → AI_API and back\n- Shows exactly how data transforms at each layer\n\n**2. Layer-by-Layer Breakdown**\n- **Frontend Layer**: All action schemas, configs, validation, and UI options\n- **WorkflowManager Layer**: Action routing, handler implementations, field mappings\n- **AI_API Layer**: Request flow, LlamaIndex workflow details, token estimation\n\n**3. Detailed Data Flow Examples**\n- Request journey visualization for `ai_translate`\n- Response processing patterns for all actions\n- Field mapping comparisons across layers\n\n**4. Critical Issues Identified (No Bug Documentation)**\n\n**Issue 1: Tag Generation Mismatch** \n- WorkflowManager expects `response.result.tags` array\n- AI_API returns `ActionResult { content, title }` without tags field\n- **This will cause tag generation to fail**\n\n**Issue 2: Duplicate Action Handlers**\n- `ai_gen_content` incorrectly routes to rewrite handler\n- `ai_add_title` / `ai_gen_title` are functionally identical\n- `ai_add_tags` / `ai_gen_tags` are functionally identical\n\n**Issue 3: Field Name Inconsistency**\n- Frontend uses `language`, WorkflowManager/API use `target_language`\n\n**Issue 4: Incomplete Default Config**\n- `ai_add_tags` missing `maxTags` and `categories` fields\n\n**Issue 5: ai_summarize Disabled**\n- Fully implemented but disabled in frontend\n\n**5. Comprehensive Reference**\n- Schema compatibility matrix showing all field mappings\n- Complete action reference with purpose, configs, and data flow\n- Testing checklist for validation\n- Prioritized recommendations (High/Medium/Low priority)\n\nThe document now provides a complete understanding of how AI actions work across the entire system, making it easy to understand data flow, identify issues, and implement fixes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":293,"cache_read_input_tokens":98061,"cache_creation":{"ephemeral_5m_input_tokens":293,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard"}},"requestId":"req_011CTfEMbzsUrEJ9uUBPc3co","type":"assistant","uuid":"585fa1f1-c2a1-4786-8d9c-0987cafff2ff","timestamp":"2025-09-30T20:39:48.949Z"}
