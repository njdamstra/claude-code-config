{"type":"file-history-snapshot","messageId":"07ac87d5-7f16-4760-9fad-fbe2122ef43f","snapshot":{"messageId":"07ac87d5-7f16-4760-9fad-fbe2122ef43f","trackedFileBackups":{},"timestamp":"2025-10-08T00:22:20.009Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":"Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."},"isMeta":true,"uuid":"7a1cf313-7345-4e26-8adc-e0ae4d852d2d","timestamp":"2025-10-08T00:22:20.008Z"}
{"parentUuid":"7a1cf313-7345-4e26-8adc-e0ae4d852d2d","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":"<command-name>/clear</command-name>\n            <command-message>clear</command-message>\n            <command-args></command-args>"},"uuid":"07ac87d5-7f16-4760-9fad-fbe2122ef43f","timestamp":"2025-10-08T00:22:19.991Z"}
{"parentUuid":"07ac87d5-7f16-4760-9fad-fbe2122ef43f","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":"<local-command-stdout></local-command-stdout>"},"uuid":"c89681bd-c417-49c7-9b45-57c1f6fff9fa","timestamp":"2025-10-08T00:22:20.007Z"}
{"type":"file-history-snapshot","messageId":"80d86c42-0e4b-40c1-b7c3-a774db966fac","snapshot":{"messageId":"80d86c42-0e4b-40c1-b7c3-a774db966fac","trackedFileBackups":{},"timestamp":"2025-10-08T00:26:29.747Z"},"isSnapshotUpdate":false}
{"parentUuid":"c89681bd-c417-49c7-9b45-57c1f6fff9fa","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":"review @FLOATING_REFACTOR_BLOCKERS.md and @src/components/composables/useAnimation.ts @src/components/composables/useAnimateElement.ts and @src/components/vue/ui/AnimatedFloatingElement.vue . the goal of this plan is to delete useAnimateElement and fully migrate to useAnimation. so there is no need to added missing presets to useAnimateElemenet. rewrite the entire plan in a doc called @FLOATING_V2.md with an entire plan of migrating @src/components/vue/ui/AnimatedFloatingElement.vue from using the old composable to solely using the new composable. ultrathink what do we have to add to @src/components/composables/useAnimation.ts ? ensure the refactor doesn't break @src/components/vue/ui/AiConductorGraphicV2.vue and can support all animations which we'll eventually migrate to use @src/components/vue/ui/AnimatedFloatingElement.vue such as @src/components/vue/views/home/workflows/AIEnhancementTheater.vue "},"uuid":"80d86c42-0e4b-40c1-b7c3-a774db966fac","timestamp":"2025-10-08T00:26:29.737Z","thinkingMetadata":{"level":"high","disabled":false,"triggers":[{"start":554,"end":564,"text":"ultrathink"}]}}
{"parentUuid":"80d86c42-0e4b-40c1-b7c3-a774db966fac","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0149Ny3NSrK82dhFyZvhLurz","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to review the blocker document and create a comprehensive migration plan. Let me analyze what's needed:\n\n1. **Goal**: Delete `useAnimateElement.ts` entirely and migrate `AnimatedFloatingElement.vue` to use only `useAnimation.ts`\n2. **Critical constraint**: Don't break `AiConductorGraphicV2.vue` \n3. **Future compatibility**: Support all animations that will eventually use `AnimatedFloatingElement.vue` like `AIEnhancementTheater.vue`\n\nLet me review the blockers document first to understand what was identified:\n\n**Blocker #1: Missing Exit Presets**\n- `fadeOut`, `scaleIn`, `scaleOut` don't exist in `animationPresets`\n- The plan says to add them to `useAnimateElement.ts`, but since we're DELETING that file, we need to add them to `useAnimation.ts` instead\n- Actually, looking at the code, `animationPresets` is defined in `useAnimateElement.ts` and imported into `useAnimation.ts`\n- So we need to move `animationPresets` definition INTO `useAnimation.ts` and add the missing presets there\n\n**Blocker #2: useAnimation Doesn't Create animateIn/animateOut with enterExit**\n- The blocker document recommends NOT using `enterExit` pattern\n- Instead, use manual coordination with `watch(() => props.modelValue)`\n- This is because `AnimatedFloatingElement` has complex mount/unmount lifecycle\n\n**Blocker #3: reverse() Behavior Not Equivalent to animateOut()**\n- Need to preserve `reverse()` behavior using Web Animations API\n- The recommendation is to expose the animation ref and call `.reverse()` on it\n\n**Blocker #4: isVisible Lifecycle Conflicts**\n- Need to preserve exact legacy `isVisible` behavior\n- The `shouldRender` computed depends on `isVisible`, `props.modelValue`, and `isAnimating`\n\n\nI'll focus on enhancing `useAnimation.ts` with the necessary modifications:\n\n1. Integrate missing animation presets directly into the module\n2. Implement a robust reverse mechanism for animations\n3. Ensure comprehensive animation environment support\n\nThe key priorities involve moving `animationPresets`, adding missing presets, and creating a flexible reverse animation method that maintains existing component behaviors.\n\nFor `AnimatedFloatingElement.vue`, I'll map the transition from `useAnimateElement` to `useAnimation` by examining the current component usage. The migration requires carefully translating existing animation configurations and preserving core interaction patterns like visibility management and event handling.\n\nThe component's prop structure suggests a need for granular animation control, with options for preset selection, teleportation, positioning, and animation lifecycle management. Mapping these requirements will be crucial for maintaining the component's current functionality.\n\nThe migration strategy involves ensuring `useAnimation` can replicate the precise behavior of `useAnimateElement`, particularly around enter/exit animations triggered by `v-model` state changes. This means developing a configuration approach that supports equivalent animation presets and event emission patterns.\n\nKey focus areas include translating the existing animation preset definitions and ensuring the new implementation supports the same event callbacks like `animation-start` and `animation-complete`. The goal is a seamless transition that doesn't disrupt existing component implementations.\n\nThe migration will proceed methodically: first updating animation presets, then refactoring the `AnimatedFloatingElement` component, verifying compatibility across dependent components, and finally removing the legacy animation utility.\n\nCritical implementation details involve manually watching `modelValue` prop changes, preserving visibility state management, and maintaining the ability to programmatically reverse animations - all while keeping the external API consistent.\n\nI'll validate each stage through comprehensive testing, ensuring no visual or behavioral changes impact existing implementations like `AiConductorGraphicV2.vue`.","signature":"EokkCkYICBgCKkAIHLnP7F+/goD+rT7TZVou497tXYUzACsP+eiH0ARpjaoJK8kzzGmoomqI7oY1bIf7n3cizzv3UBKOAwPXxzd/EgwYws+/0a/+axOebAkaDKExowxcU1D9nMbsBCIwajNmCk1kU2zGTh5jwWtyQQzgOoWhW+Vdb6Wo+84lMSySTLmM0r2jgGZRW4UytUjqKvAiXVkL/UC8ZO+u7V++KczsCe3imvwLiH5WMdS9wRDRfy8vgjPPoenEoZD34vg6CxfaW0N+K4fOPa3n4FN5FB1N5TKgy9qgKuh6ex3MdnxDt3cTLCBjlQ6EK00cTLeghx+84YIETfaHGVBDqtCr1h8JuUPJcihOAq6C4Yc9Q0rZGwhkaEcQxmR8IbMPBtQ7A8N6lKfq/pY5CrJxDusHGSdt0LTndKFQ3/xdwSt7WrJwRHbDOjPukhG7U6UeBblxXGif0zdiMh3kgcwkQ7Pbl1FBp/oCJgDSiOo8PfMX6jBjFBNqMZeOyA6gwbKHG/klxJkx8uIUEQFDLs6v+Wd9aWvR13Mj1reo+nkX5az3Angcw1v2wTpkC1eVey+2dvqvGKNWdhxeoiA/IByx0S1uVjYpOpmrB7GX/ue6c5t52Ms7B3yBkC0hNktUg7xHP5Rf3mOrqJ1pLADrVm6iHJA+UsMg2Za5rMoCTYYbu/Kt6/LVoOmmHkm54u3GhR6NRQ87Kn0vP0CPU2a1Lks5V+BtPcSeC66xciRq6Eo6elUTM3LudI8hTdAA3DXgTKA3ck3GWscw7WJeKeENkfJljMsmTu7qdzjLQjfCgb4IUti6IaZuogRtEgetghAaUGaVaQsAvHRhFQj0bLP/E4MzPBvjHDzZwkMlWPUCWlaB2gzUb1B+qcwSznJVj8uAXVsLfThfeu+H2WthF+7uYxdTJFaX4czGuiYH2nYoqKsCaEPnmHa75LHd6qPTUWh874h5b2dpiMlKQ/T5IqSqKeoiMCHd4Ta09w4lLtOHOXpNTD/lTcCcb7BK+I6w3dWOlZNk3W+6vawZe4Zi+6HaL1tk2wT4hNG9sbyH8ksBJ3da4WGw+UfyAVZDMFrNT1+j+/UD4HKIIxlJEbc/lxgCU4p801ZEt/slfeOQugYAWHBEy6pCPxcP6fsVsLbvKo2AaZayyd9PkZFOaSQkrfKURp50jkLjfQAtnDaPSK0k3gDZjGG8KN4NH/qqyrFR4J/i2B7oZAIQduvvBEofCvvY99/iohWDklUU8nWMOkqBb4ITvwbRM20qr8sz+4lYcNTEc4O8EMN1Bc8hN4VLBq6JD2brYVzk7L0d2Fwl3Qm3dLWqUFyaxAM/bwID/wPqPviy2xy8WiFm5bB6XpQsJfzaiVsqvO07MqqB4DxjqCC54aG4FhngYmysUBDOgfBWs24pDfl4rlVhXVLpIa3V2s0cpMRx6vZmYZhJfXB/ykviMhaG4V89Kq+z7EHMTgc2tNipVea34lEB0FEZXZT9yCAmc84523AQ/+SvrOcPtGSBTz8vRDt9tyPxio1xi7oZKXifHFuyJAcdBQA7PYvSLPaWNoqrGYPLyr/s30jRMeQNohUXfZqyam+fTuAaq0fuDN/P4/XcClgxroU0INxab68/svzlB2ENe9lX42BxRBbC8BM+r5NlJHwEcRIcoDeXkm7o3ozvKRCrDa0womSp6Mg/dvdt50AUH9hALZlxIlp8ntrsowme3Ywo5qIu0f7/itHJq3KHLgEOcFwAuhWhLfW3vHJdady+TOoNWlO/aSWh8C5wcpmnxX03htPQMbasDdXIzvWuwoXvwqQin+sYdB2IJnzADlWdsnVpVwpbRDglsg0FnvE58Htfa+QpsJLAYxYKD6dpVQAF6F0WRrcTS7hQxLPwC7Hqh25CACRRbUQ/fTdQw5kvJIUJnuDDBpRBO1n4B/AQDtUPi3CJoWlo+T3KDlw0uwm2U0dxmK6qGJadjHh/BQn8Lvri347Ofdz8cApstiXtTf2OMVMijDiHvIWyTwOxA/VTwgFFCHEsTZ7gm5aO2S/85GgGT5Ie5rX3cK7r2ipqfURoj13QNvFIXwWPrlYlC+bqdA6Mttfmxdabqigd1G6es4JbaXcZxri7r1QtK55cbRRv7UfkM24WyKbqfIk5wRRYN6tbGREeEzhi/y9TRc1T1Y+6rDr0w+Lfpz3PYCcQkIphhpmVdoyx01s5Q0oG0Do2McitRf6TaVvBj3zRL+wLqa0B/1Ej5KP6DS0dNUXE8cHFDS80Hsf1v36WM7HqFhqLcarAGka9TC1wDWRzf80hRCgbyLGCu9kYklRESFaSOniqNjBmUFrQ+jh0JZofCa+ii5/KysN+swqgVz1jYI8586MbDWlZG0TymBJJMIKxaySvOCgGFAbsi1O3A7AOwHdGaLWyLhowj3aQ4JoICMeR09xAZwxY5Y51FeJg6B4T18hdbXdpELwtmS3X2QKhmvTS1yVpsK/xthEAcGtERdoRp2XuEmSQ4J7NhjCJTyawi1JzyndvX2BqmGpK6mBP/xUeSpCn1luBdcxBB2IzrXPK20cIsTChgxWNDxgRE+y/UuCNcJA7x7nv22kzgDgqgqMpDfKPMIW7gFbskXRXEMGKNvS2NS4dLlD+TdErbR7w6DFuaFRAytVULPyoJjmWRDdV5tJmJrcYnad6eJL2FJSKm9ftzfALHTXERu5h3pqkPGjQzsdMFvWkUVI+9uThgmCH3P/DpT3k+h/PULhWsZZrXbF4BduB6A524TglhAV6RD+LudhFd7tawhygMS+6hcAy8TyJQdJLbkKoqsW1qNWT6Z9GAFFR2LWRf9vwJSfCrx/QMWPGJRWLpn8WXwmpZLAkB7Nxq2uB4bpfBnSBeX6ktRJNmYhDRp0DNjp0KvtmVSyp4hQyi3qIpbbGuaR/0z/sGv9YZhttCPz3EWhg9ZItrdTwh48xuL2vQJKg7IoOCZNcK7T+I+vzLdpTJPE285cXoHHRmUncN+VdbEu9c4wv+RypQCmzEb/L4D3/kuSV3owIIP1f/asTQQzRjWpq/GUgByyB4bbcfRdfVqePuDb9iYHPAb1jx0Uv6nWmgPpAxuH62lgF7q2+51YIPEKLf9CfSnk8mXCDiGNwLglViQtUeVlt5JXTuZp6cJp2L77R6bDDA3AvU9JNeojUeMZsh0BXJu/BBGj3Q6SrTON6Z4AvwVNyQmC2ROy/eLrtDzE4cZNOYuXqa48h6i60KfgOS2a2FjPHMe0CGHpH/bFY5PIfFw5x9/jAGqdBdGxAriAgBsIBFtE8pSKca54fXshevuVZt7NwjXnjWTdxjKwlkc2tzQ7a54gGo4qzm0fPHkwJDXJ2+OOoJWgOJMqv7tNBqHGGBx8WwdZnGUCmM8bZUqTzQV/HjV4EMyqjZFsG0UD0rOBP5VKgN2hooNUouW0RqmNJDgVy89zAvRhSnQXopEWi7D4A/DQ3SIr6q9691RK9jxv6UbresS47D/a3/0SfQb2QNeUT9T1SWi7IKzzLEKmItn2+i6BBX18771DV6otbjMBM1doUtgabF78sB9Hr/qKJwSbMhHDZm3sUDHjsrIJtqd0OeoN5wAwkM7ulT7DBKma0lLtgy2RGDeMiZoOlt0AYPVrpAuRUGsj88qKH3aiPn8LsflXcKCULmgsoA+1el/dT7lb/FYb56VVyEbXjUhD2GQXH/+V1738/XxlJDOSeQDn6cttneCPtbbIUQiLw5fiu/Q4eZwifo4EMxz0Qqk0Uhtnfh6H7b//6xknlejPNmaHj4gSyiPlY2JC17o19+EA8dJ1x5LHLfXkZfMe44LrzMNU4L9N0uv/pJ8NqYZidcUczv+WSjFu1Gd1d2x+ky66ItoECGp7jzVdt0MMXdLmM+0tmn1tsk6n1belap8Hs/j2RXBigJo7PxXrEHVdyGUPmybj9I+6kgyLCvwjDat0wsSiU4KnY9nJNfxlqJ79+QAcC0HCogQzt2lr+SRmNQfwSuy4dq+OkRgKgzshSxDFjCyKGX3e3yc4ZFBAzhnRnANADmdkbTgiF3DMOw3KcMHy6rjxg1zuf3sV/ILjkCFSM4TFNbje2XeVjyHe7rqAA8meOggC1y8St96KxHsGCK9GHJ+X8n9MJjjAxjj4C5cLp/3reJHOgpQeul/ptswvtC+UViU4KvPs2pW2kOnL/nJ7VrPEdeOtBUkH4aiYSATDpG5RL+1yZMt+jwT5LEHjuL/HV4eSuCWX+h+R3Wgs4tYhNBLBxYqCCW6JlKDlLH9twpTmPiJmyi993WFzpkbQ6WePWzDRqM0EK9rY4nTX3sJmXnehdm/x8+Ag+LYYpf9lZHCyIUuw2YT6bjVO/hGZdMKSPXg43zsrdhzpwhgi09z8TzxC93NvPsklvtIp0eHxZVu3UUhE8CcIlwEKAYmShJx2tgKyUsy5ZxzmzD+m0LzTMmUjSJ5rw+6t2Qjiv19E5JmdCtrI/GKdabAWphUeZOhLVPUiRVLFF72PUNT41nEAatwCWSFAEwu4n3PIxbNFhNUbr5crrXdfF9hTvoQPg0RZKLOIkVI8EYsDeHyUa6C8ufPHm2R2yFq97EJffxVzK/CvXkRNi9J0UQOxKKV6z+PC8neSMC5jjUJvRURWGye4pN99hjDFKxfSL8GRRcgwGdaiEFBHb+Z/4ZiLLeQqvksP41PrXlemT2OVwHH6N8KwG2ibCzi5Uf96V/LGPtl83UzVO37LT7ynm5Tk8QQQhvp6zvMx79cu4ligHz20Oy5ZNG1XpKbwkKjyc73w6m/iqsLFQUK+rBIcWCNKmomsyhgkaCbpEGtmiDnUdzyy4ULLpdQMcPsaTfKpdib+VqyYWi3PzvXSf/dIi58nKr04IDROxtCw10le6zAQhdp8lAZqKw10dig+wbDiPBCSdeCKTNQyZeYYEZPCTVBAfQ3dyGbUA4xrGIs70yc9ojtavCUAxUBbGDL6FNQSId+vU0GPxu+wxj35t4OsnIb1PR0z6MNOsoZVM3quSSaEy9a/OVk00/0A3kKZv82dnw0aqiZ60sM+0fQ1dSLbcenaA2VI5LdAQ/JVf2XFiOBr/fW5ouL7q6A4ZbUe+KXgqOSRIOnmWb5fV9V9SyATaPWaqY3eu60d7zMBg8gZrvXuAvPE/iJSHrb/p32I1bLa0QnJY/yhc5UTpTQbZVXek/JAjdOQsOMUmZWgy/aEzHUYK+W4hWkOk0gaCt7sKfpgsf8Oko2jrG95QpoLjw2qQM1SOVCsqH+f95U0gaz9uuPw/8TTEyIzPQAG94cj4RR/O7KZ/Xdg/4/PMY+JgOj/76vqEQiWy4igRXUaBLwc4y2egRVM+JUNNILo/SKUQOMFzGJQt1eHyWSdc9c+2mOrBcogxTBSOjPmCrV6nkFzcEVFBmTRPhwwQsR6UcDRV05CZGV1Tb907B2/0fLupih1cD4krAo9bws3nCtiAkUjrvKhpFyRXeUk1+D5Rf5EuLB71NmPutM7y+a9Vx3vNTP5eJf+oZ2FFcZrypFt5xwo/AIZW+FrEFwQE67KCASra8LrI8JNckvZYTiyuxBwAkUEbxDsAQ+Vu3kAwX99iGoqpAlnsp/D9d3ru07Oy/JASDfjzkowZ6juE3ztd8PB9F1R2bimf3dgjjr43+IDJhjg6RbS/hUPqRIWbGnqWjjIWGkWSfD+G1G3+1Yn4pOGSYmAEHiYYFJ+nfIpjxzfSX8pacxJCbijVi+Umx57LfJt1exJh30wcwzVFpcgzWm0yk0s3+PgHveBBbDCuR3RHAxnaN4sJgzA4+wKX/S8pZ9OhHPv/fZyrA8xh7rO2xFFUqk3+uGbYXcBACpIoku0f3GhYVYvZkLAsmo/dEY2Wp0qTCdH0rTTcxsv/aJfO7Ybqx3/Rdi3hl4MFdjoPqKMJWOiHc68rwSkBzYoTqiqJTJ0FQ7AnukaaI0mVU+YHIEeB/LXLGhfp/ZP/E5Vx/qc0AjTwQIjO9WUHypkA9rQN8+zqsFnrMNCV99ejchGmtqNZHcMHOvwfnnEslGJ51U57fQYdP+LmB03TDaSz2IBUj2wrLAJ1e4L5WtyhTrHQsE7UgLD1rPmK6ivEeCZTx979VDfa1p84ZJSVXKHm2adWOyuWcp4808xW3zQ2NpKFM+rFuMZZyTTbMF0/Vjmy6DJdvQ5yfX3KO8JSo3hVgm8KGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":126574,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":126574,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CTtnKb81PM1yx95DXzHnY","type":"assistant","uuid":"cbb9a77b-ec36-4d32-a1d6-f76e59a0af21","timestamp":"2025-10-08T00:27:03.434Z"}
{"parentUuid":"cbb9a77b-ec36-4d32-a1d6-f76e59a0af21","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0149Ny3NSrK82dhFyZvhLurz","type":"message","role":"assistant","content":[{"type":"text","text":"I'll create a comprehensive migration plan that addresses all blockers and ensures no breaking changes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":126574,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":126574,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CTtnKb81PM1yx95DXzHnY","type":"assistant","uuid":"d1adb9dc-ce10-42da-b855-a833f77def96","timestamp":"2025-10-08T00:27:03.449Z"}
{"type":"file-history-snapshot","messageId":"81680616-54b4-47d7-a819-45d1def2d7eb","snapshot":{"messageId":"80d86c42-0e4b-40c1-b7c3-a774db966fac","trackedFileBackups":{"FLOATING_V2.md":{"backupFileName":null,"version":1,"backupTime":"2025-10-08T00:28:46.386Z"}},"timestamp":"2025-10-08T00:26:29.747Z"},"isSnapshotUpdate":true}
{"parentUuid":"d1adb9dc-ce10-42da-b855-a833f77def96","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0149Ny3NSrK82dhFyZvhLurz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TBXMS37iDgkAgJiMvzN6ou","name":"Write","input":{"file_path":"/Users/natedamstra/socialaize/FLOATING_V2.md","content":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// Extract what we need\nconst animateIn = animation.animateIn\nconst animateOut = animation.animateOut\nconst isAnimating = animation.isPlaying\nconst isAnimationSupported = animation.canAnimate\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    // Reverse the current animation\n    anim.reverse()\n    await anim.finished\n  } else {\n    // Fallback: play exit animation if no animation running\n    await animateOut?.()\n  }\n}\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n\n### Step 2.3: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.4: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.5: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.6: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.2: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.3: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.4: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":126574,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":126574,"ephemeral_1h_input_tokens":0},"output_tokens":7806,"service_tier":"standard"}},"requestId":"req_011CTtnKb81PM1yx95DXzHnY","type":"assistant","uuid":"81680616-54b4-47d7-a819-45d1def2d7eb","timestamp":"2025-10-08T00:28:46.306Z"}
{"parentUuid":"81680616-54b4-47d7-a819-45d1def2d7eb","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TBXMS37iDgkAgJiMvzN6ou","type":"tool_result","content":"File created successfully at: /Users/natedamstra/socialaize/FLOATING_V2.md"}]},"uuid":"1ddb9898-c67b-4962-bb40-e628e3cbc492","timestamp":"2025-10-08T00:28:46.413Z","toolUseResult":{"type":"create","filePath":"/Users/natedamstra/socialaize/FLOATING_V2.md","content":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// Extract what we need\nconst animateIn = animation.animateIn\nconst animateOut = animation.animateOut\nconst isAnimating = animation.isPlaying\nconst isAnimationSupported = animation.canAnimate\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    // Reverse the current animation\n    anim.reverse()\n    await anim.finished\n  } else {\n    // Fallback: play exit animation if no animation running\n    await animateOut?.()\n  }\n}\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n\n### Step 2.3: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.4: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.5: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.6: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.2: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.3: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.4: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**\n","structuredPatch":[]}}
{"parentUuid":"1ddb9898-c67b-4962-bb40-e628e3cbc492","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01LBotL3G5S5CXnNkBULFydF","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user asked me to create a comprehensive migration plan, and I've delivered a detailed 700+ line document that:\n\n1. **Resolves all blockers** from the original FLOATING_REFACTOR_BLOCKERS.md\n2. **Provides step-by-step implementation** across 5 phases\n3. **Ensures backward compatibility** with AiConductorGraphicV2.vue\n4. **Adds missing presets** to useAnimation.ts (not useAnimateElement.ts since we're deleting it)\n5. **Preserves exact lifecycle behavior** (the critical part)\n6. **Gains environment detection** (battery, FPS, reduced motion, idle, page leave)\n7. **Includes comprehensive testing** and validation steps\n8. **Has a clear rollback plan** if something breaks\n\nKey decisions in the plan:\n- Manual lifecycle control (NOT using enterExit pattern) to avoid Blocker #2\n- Preserve reverse() using Web Animations API to solve Blocker #3\n- Keep exact isVisible timing to avoid Blocker #4\n- Add fadeOut, scaleIn, scaleOut to solve Blocker #1\n- Move animationPresets into useAnimation.ts since we're deleting useAnimateElement.ts\n\nThe plan is ready to execute and should take about 4 hours total.","signature":"EvoJCkYICBgCKkB7vGqInKXhCT8O+XlwklVvTQC/aWAJ44JieFg0W2zCk0l/GAzv/sSsHDIpKeKnVbLUZ+Dk3+DDh6R2iDYAfaA6EgyBuHE7s6lMY/QVMVAaDDtbMLB7cKZVBjZhACIwO9wh4FqdZ2Jgzjv3pt4/v92vD4f8L6XRUHJOmnslBWkCwwnbYSC6/iNo8eK2QWYFKuEIORfmA/a1KKjBsga/sPAx9AT4fBh84pQfMWR4h9MMrJAw0m5b6TPcv4f6iD5MGFxuuxcr6Ue05n+6gbShfbZrX3kBVugADiIg9QCaDyFMNVKPJXmoxK/+FGWhKdobiGNX0vODw8niT9joNSz5r5/K/T3JHqV/IpLbVGQ7XgJBR3pjqsiS7dch1NOQzG3ubWjIrtZsNt/5E7oU4q7QGxM+Pml8cUzqu4raPRMZEmWbQCrBMwvV1C2M5urnVlg+M2Eae0/6iVYN6xfbtuuwuQBCAimVnThbl7u0yoGHY4yTynPaRdgHjH+9bq1gq+WjG/+UnENVua0MBJvWBKm/naXh4uOdvpkQz2EgZrZ6ANsNPoQkSTg+QVisykRSZ90Y1oxPH/YRRZB1qSXvvhKDHHuPmPs/fkQ7XB3iwBSL/idWMibuvX5a33+BRLMPR4BRsuGlZsCPOF/S0d9whUBg0NubbhNYaOgPGpXzP4Py9q2hNXzzKurfInpVnz2omQjZ1jRigog4tIpxH8kPZBNU7tIeEjhQXtALbDXf0ZL/tG1IZ3SVxcgdBnRZmby8GR2v9jK1/n3ARgunexyx8GTqLNHx1RAMTbVluwL+ujloKj2yUXGZHZFFYn9mxuTblje1qXZbwELRKZb4PLHjxX0T39Z1cRRvCnOH409d3I5Klt1Sn4qS8FmPUFDk9QvgjTH5R/jP1jomNQhJ4Qzaw1HXcp2CzxnUqmKVm4yDSbUb6VhDx6E2dRM/nAyIi5J5r5T7qa7oesL220PG8sFAPVvw+3K1aE+sIaCB7W6YebsXCyEcu4RoRui//H1Jf43FSuMTPX6Q3pNjYUuXIEmhkO/kg0pXp+NZm+ISzL4Am31RIGhwbkviKhzyvnF2qPt5kPiL+IxoWbIdB/1wuu7EwDzrBxNVn+HU8j6Qeb59XRufINm/P/4kvB7yB5Pwg65sdo+b2f2H9ghM8vK2DF93cCL6HeRC+LK9C1b2bQ1YqiWCfJLqBSjcQv55zXE/uOAcUPS+6/zDynV4841K/prO1cLzwzf2NxQ0GHtWGWaMDahEccLNkepMHk+ecollyiolK3J3QjDI8Evs+SRhrcXEjyHtq90w9Gia2xeGhBKzJMkYPQhdaOAuXQV+UCsnrGL6KnVMPsGa+SfLiopQF8KsW/u5W5YWYpSz3kEHT5IMzF5SV90SDUp1dzvdGFliMsQXMY4w/3nF0CmTU0DhreSxjryaTHwpr6NiYKb8jde1daflRPdqDGntM6K+d2aLaZmLUaHAkMGEOcnlj2XClWSYZQkmjiwTfTzg5Kmb/lpSEcyH/dez0n/T7wNpsHJtKGLk86+K9GXTlRk6CnMPXsik7XysQWPRQFOH/fT2YPQdQ0oypRG744ykjHgLu58bjKewVB4GHyieFzvsoFNUITPIQfUshnHq9kknFLMeemH2L7+aJtGMMyBJKAPqAGZtAV/rid7DdWtbK3X+p5zs+MIBh9pZGQRFABUYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":7840,"cache_read_input_tokens":126574,"cache_creation":{"ephemeral_5m_input_tokens":7840,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CTtnVdaNFPTU7961uSN8d","type":"assistant","uuid":"f4fd7301-6b02-42da-a2f2-f75d34c1ce39","timestamp":"2025-10-08T00:28:57.423Z"}
{"parentUuid":"f4fd7301-6b02-42da-a2f2-f75d34c1ce39","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01LBotL3G5S5CXnNkBULFydF","type":"message","role":"assistant","content":[{"type":"text","text":"I've created **FLOATING_V2.md** - a comprehensive migration plan that resolves all blockers and provides a clear path to delete `useAnimateElement.ts` entirely.\n\n## Key Strategic Decisions\n\n### 1. **Add Missing Presets to `useAnimation.ts` (Not `useAnimateElement.ts`)**\nSince we're deleting `useAnimateElement.ts`, I'm moving the entire `animationPresets` object into `useAnimation.ts` and adding the three missing presets (`fadeOut`, `scaleIn`, `scaleOut`) there.\n\n### 2. **Manual Lifecycle Control (Not `enterExit` Pattern)**\nThe plan uses the exact existing `watch(() => props.modelValue)` logic because:\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- The `enterExit` pattern doesn't create `animateIn`/`animateOut` (Blocker #2)\n- Proven, stable timing that works with `AiConductorGraphicV2.vue`\n\n### 3. **Preserve `reverse()` Using Web Animations API**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse() // Native Web Animations API\n    await anim.finished\n  } else {\n    await animateOut?.() // Fallback\n  }\n}\n```\nThis solves Blocker #3 while maintaining smooth click-outside behavior.\n\n### 4. **Zero Changes to Lifecycle Timing**\nThe `isVisible` ref lifecycle remains **exactly the same** to avoid Blocker #4 and ensure `AiConductorGraphicV2.vue` continues working perfectly.\n\n## What You Gain\n\nAfter migration, `AnimatedFloatingElement` automatically gets:\n- âœ… Battery-aware auto-pause (duration scales 0.3x on low battery)\n- âœ… FPS-based adaptation (duration scales 0.6x when FPS <30)\n- âœ… Reduced motion support (respects system preference)\n- âœ… Idle detection (pauses after 5min inactivity)\n- âœ… Page leave detection (pauses when tab hidden)\n\n## Timeline\n- **Phase 1** (Prepare useAnimation.ts): 30 min\n- **Phase 2** (Migrate AnimatedFloatingElement.vue): 2 hours\n- **Phase 3** (Validation & Testing): 1 hour\n- **Phase 4** (Delete useAnimateElement.ts): 15 min\n\n**Total: ~4 hours** (conservative estimate)\n\nThe plan includes comprehensive testing steps, rollback procedures, and a final validation checklist to ensure zero visual regressions with `AiConductorGraphicV2.vue`.\n\nReady to start implementation?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":7840,"cache_read_input_tokens":126574,"cache_creation":{"ephemeral_5m_input_tokens":7840,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CTtnVdaNFPTU7961uSN8d","type":"assistant","uuid":"3a5b5982-89ed-4f72-b4cf-3aa7a0a0b394","timestamp":"2025-10-08T00:29:08.791Z"}
{"type":"file-history-snapshot","messageId":"3e083920-7322-4d7a-a749-38170324ac7b","snapshot":{"messageId":"3e083920-7322-4d7a-a749-38170324ac7b","trackedFileBackups":{"FLOATING_V2.md":{"backupFileName":"31dfbdaea3fdd10b@v2","version":2,"backupTime":"2025-10-08T00:36:03.061Z"}},"timestamp":"2025-10-08T00:36:03.037Z"},"isSnapshotUpdate":false}
{"parentUuid":"3a5b5982-89ed-4f72-b4cf-3aa7a0a0b394","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":" Key Issues\n\n  - Blocker FLOATING_V2.md:186-189 â†’ src/components/composables/\n    useAnimation.ts:1205-1355,1374: The plan maps isAnimating to\n    animation.isPlaying, but isPlaying is only flipped by play() (src/\n    components/composables/useAnimation.ts:1374,1435) and never updated\n    when you call animateIn/animateOut. Result: slot consumers (e.g.\n    AiConductorGraphicV2.vue:18-55) will always see isFloatingAnimating=false, so\n    they show chat bubbles/provider responses during the enter/exit animationsâ€”a\n    visible regression.\n  - Blocker FLOATING_V2.md:188-233 â†’ src/components/composables/\n    useAnimation.ts:1306-1335: Treating isAnimationSupported as\n    animation.canAnimate shortâ€‘circuits the existing watcher whenever the\n    environment heuristics kick in. canAnimate goes false for low battery/\n    FPS and reduced motion, and animateIn immediately applies the final\n    frame when that happens (src/components/composables/useAnimation.ts:1308-\n    1319). Because the watcher then skips calling animateIn, you never get the\n    â€œscaled durationâ€ behavior the plan promises; the element just snaps in/\n    out. Youâ€™ll need a distinct â€œWeb Animations supportedâ€ flag (e.g. inspect\n    animation.animate?.value or expose webAnimAPI.isSupported) so environment\n    throttling can still run through the animation path."},"uuid":"3e083920-7322-4d7a-a749-38170324ac7b","timestamp":"2025-10-08T00:36:03.021Z","thinkingMetadata":{"level":"none","disabled":true,"triggers":[]}}
{"parentUuid":"3e083920-7322-4d7a-a749-38170324ac7b","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012FwWy7ExE1sSXGtsQn4ff4","type":"message","role":"assistant","content":[{"type":"text","text":"Excellent catch! These are critical blockers that would break the migration. Let me fix both issues:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":134064,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":134064,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CTto3pVbLtVJNoaFNoLic","type":"assistant","uuid":"2fc42cf3-0bdd-4b9e-b92e-3a241b15edc2","timestamp":"2025-10-08T00:36:08.986Z"}
{"parentUuid":"2fc42cf3-0bdd-4b9e-b92e-3a241b15edc2","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012FwWy7ExE1sSXGtsQn4ff4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Fvfsy4KBvAx12aJ98WgTt8","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/FLOATING_V2.md","old_string":"// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// Extract what we need\nconst animateIn = animation.animateIn\nconst animateOut = animation.animateOut\nconst isAnimating = animation.isPlaying\nconst isAnimationSupported = animation.canAnimate\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    // Reverse the current animation\n    anim.reverse()\n    await anim.finished\n  } else {\n    // Fallback: play exit animation if no animation running\n    await animateOut?.()\n  }\n}","new_string":"// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// CRITICAL: Track animation state separately from useAnimation's isPlaying\n// because isPlaying only updates when play() is called, not animateIn/animateOut\nconst isAnimating = ref(false)\n\n// CRITICAL: Separate Web Animations support check from environment throttling\n// canAnimate goes false for low battery/FPS, but we still want to run animations\n// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\nconst isAnimationSupported = computed(() => {\n  // Check if Web Animations API is available (browser support)\n  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n\n// Wrap animateIn to track isAnimating state\nconst wrappedAnimateIn = async () => {\n  if (!animation.animateIn) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Wrap animateOut to track isAnimating state\nconst wrappedAnimateOut = async () => {\n  if (!animation.animateOut) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateOut()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    try {\n      isAnimating.value = true\n      // Reverse the current animation\n      anim.reverse()\n      await anim.finished\n    } finally {\n      isAnimating.value = false\n    }\n  } else {\n    // Fallback: play exit animation if no animation running\n    await wrappedAnimateOut()\n  }\n}\n\n// Export wrapped versions for use in template\nconst animateIn = wrappedAnimateIn\nconst animateOut = wrappedAnimateOut"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":134064,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":134064,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CTto3pVbLtVJNoaFNoLic","type":"assistant","uuid":"82e0f896-f22a-4b1d-83ea-cb3b26865d61","timestamp":"2025-10-08T00:36:21.658Z"}
{"parentUuid":"82e0f896-f22a-4b1d-83ea-cb3b26865d61","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Fvfsy4KBvAx12aJ98WgTt8","type":"tool_result","content":"The file /Users/natedamstra/socialaize/FLOATING_V2.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   169â†’```\n   170â†’\n   171â†’**New Implementation:**\n   172â†’```typescript\n   173â†’// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\n   174â†’const animation = useAnimation(elementRef, {\n   175â†’  animation: {\n   176â†’    preset: props.preset,\n   177â†’    duration: props.duration,\n   178â†’    easing: props.easing\n   179â†’  },\n   180â†’  autoplay: false, // Manual control via watch\n   181â†’  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n   182â†’  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n   183â†’})\n   184â†’\n   185â†’// CRITICAL: Track animation state separately from useAnimation's isPlaying\n   186â†’// because isPlaying only updates when play() is called, not animateIn/animateOut\n   187â†’const isAnimating = ref(false)\n   188â†’\n   189â†’// CRITICAL: Separate Web Animations support check from environment throttling\n   190â†’// canAnimate goes false for low battery/FPS, but we still want to run animations\n   191â†’// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\n   192â†’const isAnimationSupported = computed(() => {\n   193â†’  // Check if Web Animations API is available (browser support)\n   194â†’  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n   195â†’})\n   196â†’\n   197â†’// Wrap animateIn to track isAnimating state\n   198â†’const wrappedAnimateIn = async () => {\n   199â†’  if (!animation.animateIn) return\n   200â†’\n   201â†’  try {\n   202â†’    isAnimating.value = true\n   203â†’    await animation.animateIn()\n   204â†’  } finally {\n   205â†’    isAnimating.value = false\n   206â†’  }\n   207â†’}\n   208â†’\n   209â†’// Wrap animateOut to track isAnimating state\n   210â†’const wrappedAnimateOut = async () => {\n   211â†’  if (!animation.animateOut) return\n   212â†’\n   213â†’  try {\n   214â†’    isAnimating.value = true\n   215â†’    await animation.animateOut()\n   216â†’  } finally {\n   217â†’    isAnimating.value = false\n   218â†’  }\n   219â†’}\n   220â†’\n   221â†’// Create reverse() function using Web Animations API\n   222â†’const reverse = async () => {\n   223â†’  const anim = animation.animate?.value\n   224â†’  if (anim && anim.playState === 'running') {\n   225â†’    try {\n   226â†’      isAnimating.value = true\n   227â†’      // Reverse the current animation\n   228â†’      anim.reverse()\n   229â†’      await anim.finished\n   230â†’    } finally {\n   231â†’      isAnimating.value = false\n   232â†’    }\n   233â†’  } else {\n   234â†’    // Fallback: play exit animation if no animation running\n   235â†’    await wrappedAnimateOut()\n   236â†’  }\n   237â†’}\n   238â†’\n   239â†’// Export wrapped versions for use in template\n   240â†’const animateIn = wrappedAnimateIn\n   241â†’const animateOut = wrappedAnimateOut\n   242â†’```\n   243â†’\n   244â†’**Why this approach?**\n   245â†’- âœ… No `enterExit` pattern (avoids Blocker #2)"}]},"uuid":"afb46bb1-ad3c-409b-a1a3-a8d77f935746","timestamp":"2025-10-08T00:36:21.757Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/FLOATING_V2.md","oldString":"// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// Extract what we need\nconst animateIn = animation.animateIn\nconst animateOut = animation.animateOut\nconst isAnimating = animation.isPlaying\nconst isAnimationSupported = animation.canAnimate\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    // Reverse the current animation\n    anim.reverse()\n    await anim.finished\n  } else {\n    // Fallback: play exit animation if no animation running\n    await animateOut?.()\n  }\n}","newString":"// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// CRITICAL: Track animation state separately from useAnimation's isPlaying\n// because isPlaying only updates when play() is called, not animateIn/animateOut\nconst isAnimating = ref(false)\n\n// CRITICAL: Separate Web Animations support check from environment throttling\n// canAnimate goes false for low battery/FPS, but we still want to run animations\n// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\nconst isAnimationSupported = computed(() => {\n  // Check if Web Animations API is available (browser support)\n  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n\n// Wrap animateIn to track isAnimating state\nconst wrappedAnimateIn = async () => {\n  if (!animation.animateIn) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Wrap animateOut to track isAnimating state\nconst wrappedAnimateOut = async () => {\n  if (!animation.animateOut) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateOut()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    try {\n      isAnimating.value = true\n      // Reverse the current animation\n      anim.reverse()\n      await anim.finished\n    } finally {\n      isAnimating.value = false\n    }\n  } else {\n    // Fallback: play exit animation if no animation running\n    await wrappedAnimateOut()\n  }\n}\n\n// Export wrapped versions for use in template\nconst animateIn = wrappedAnimateIn\nconst animateOut = wrappedAnimateOut","originalFile":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// Extract what we need\nconst animateIn = animation.animateIn\nconst animateOut = animation.animateOut\nconst isAnimating = animation.isPlaying\nconst isAnimationSupported = animation.canAnimate\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    // Reverse the current animation\n    anim.reverse()\n    await anim.finished\n  } else {\n    // Fallback: play exit animation if no animation running\n    await animateOut?.()\n  }\n}\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n\n### Step 2.3: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.4: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.5: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.6: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.2: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.3: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.4: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**\n","structuredPatch":[{"oldStart":182,"oldLines":24,"newStart":182,"newLines":63,"lines":["   critical: false // Allow auto-pause on low battery (unless element is critical UI)"," })"," ","-// Extract what we need","-const animateIn = animation.animateIn","-const animateOut = animation.animateOut","-const isAnimating = animation.isPlaying","-const isAnimationSupported = animation.canAnimate","+// CRITICAL: Track animation state separately from useAnimation's isPlaying","+// because isPlaying only updates when play() is called, not animateIn/animateOut","+const isAnimating = ref(false)"," ","+// CRITICAL: Separate Web Animations support check from environment throttling","+// canAnimate goes false for low battery/FPS, but we still want to run animations","+// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.","+const isAnimationSupported = computed(() => {","+  // Check if Web Animations API is available (browser support)","+  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype","+})","+","+// Wrap animateIn to track isAnimating state","+const wrappedAnimateIn = async () => {","+  if (!animation.animateIn) return","+","+  try {","+    isAnimating.value = true","+    await animation.animateIn()","+  } finally {","+    isAnimating.value = false","+  }","+}","+","+// Wrap animateOut to track isAnimating state","+const wrappedAnimateOut = async () => {","+  if (!animation.animateOut) return","+","+  try {","+    isAnimating.value = true","+    await animation.animateOut()","+  } finally {","+    isAnimating.value = false","+  }","+}","+"," // Create reverse() function using Web Animations API"," const reverse = async () => {","   const anim = animation.animate?.value","   if (anim && anim.playState === 'running') {","-    // Reverse the current animation","-    anim.reverse()","-    await anim.finished","+    try {","+      isAnimating.value = true","+      // Reverse the current animation","+      anim.reverse()","+      await anim.finished","+    } finally {","+      isAnimating.value = false","+    }","   } else {","     // Fallback: play exit animation if no animation running","-    await animateOut?.()","+    await wrappedAnimateOut()","   }"," }","+","+// Export wrapped versions for use in template","+const animateIn = wrappedAnimateIn","+const animateOut = wrappedAnimateOut"," ```"," "," **Why this approach?**"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"afb46bb1-ad3c-409b-a1a3-a8d77f935746","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01K5ButMWGDfMTK2u1CPL58h","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the explanation and add a critical section about these fixes:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":1927,"cache_read_input_tokens":134064,"cache_creation":{"ephemeral_5m_input_tokens":1927,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTto5CCqYPjvmUAQB6wLS","type":"assistant","uuid":"0dd65469-c85c-412d-a259-c43bf9e0f582","timestamp":"2025-10-08T00:36:26.199Z"}
{"parentUuid":"0dd65469-c85c-412d-a259-c43bf9e0f582","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01K5ButMWGDfMTK2u1CPL58h","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015j1un2cApJ5FJAPKJGsEfs","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/FLOATING_V2.md","old_string":"**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically","new_string":"**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue\n- âœ… **Separate browser support check** - Allows environment throttling to work correctly\n\n**Critical Implementation Details:**\n\n1. **`isAnimating` State Tracking**\n   - `useAnimation.isPlaying` only updates when `play()` is called\n   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`\n   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations\n   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`\n\n2. **Browser Support vs Environment Throttling**\n   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS\n   - But we WANT scaled animations to run (30% duration on low battery, etc.)\n   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":1927,"cache_read_input_tokens":134064,"cache_creation":{"ephemeral_5m_input_tokens":1927,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTto5CCqYPjvmUAQB6wLS","type":"assistant","uuid":"a400f278-3ffc-4cd4-895b-4013e46b8a5c","timestamp":"2025-10-08T00:36:35.384Z"}
{"parentUuid":"a400f278-3ffc-4cd4-895b-4013e46b8a5c","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015j1un2cApJ5FJAPKJGsEfs","type":"tool_result","content":"The file /Users/natedamstra/socialaize/FLOATING_V2.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   240â†’const animateIn = wrappedAnimateIn\n   241â†’const animateOut = wrappedAnimateOut\n   242â†’```\n   243â†’\n   244â†’**Why this approach?**\n   245â†’- âœ… No `enterExit` pattern (avoids Blocker #2)\n   246â†’- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n   247â†’- âœ… Maintains exact same lifecycle hooks\n   248â†’- âœ… Gains environment detection automatically\n   249â†’- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue\n   250â†’- âœ… **Separate browser support check** - Allows environment throttling to work correctly\n   251â†’\n   252â†’**Critical Implementation Details:**\n   253â†’\n   254â†’1. **`isAnimating` State Tracking**\n   255â†’   - `useAnimation.isPlaying` only updates when `play()` is called\n   256â†’   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`\n   257â†’   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations\n   258â†’   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`\n   259â†’\n   260â†’2. **Browser Support vs Environment Throttling**\n   261â†’   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS\n   262â†’   - But we WANT scaled animations to run (30% duration on low battery, etc.)\n   263â†’   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   264â†’   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   265â†’   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly\n   266â†’\n   267â†’### Step 2.3: Keep Exact Same Lifecycle Logic\n   268â†’\n   269â†’**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):"}]},"uuid":"ceadfc37-5a37-4752-b489-51fc679138b3","timestamp":"2025-10-08T00:36:35.502Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/FLOATING_V2.md","oldString":"**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically","newString":"**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue\n- âœ… **Separate browser support check** - Allows environment throttling to work correctly\n\n**Critical Implementation Details:**\n\n1. **`isAnimating` State Tracking**\n   - `useAnimation.isPlaying` only updates when `play()` is called\n   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`\n   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations\n   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`\n\n2. **Browser Support vs Environment Throttling**\n   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS\n   - But we WANT scaled animations to run (30% duration on low battery, etc.)\n   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly","originalFile":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// CRITICAL: Track animation state separately from useAnimation's isPlaying\n// because isPlaying only updates when play() is called, not animateIn/animateOut\nconst isAnimating = ref(false)\n\n// CRITICAL: Separate Web Animations support check from environment throttling\n// canAnimate goes false for low battery/FPS, but we still want to run animations\n// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\nconst isAnimationSupported = computed(() => {\n  // Check if Web Animations API is available (browser support)\n  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n\n// Wrap animateIn to track isAnimating state\nconst wrappedAnimateIn = async () => {\n  if (!animation.animateIn) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Wrap animateOut to track isAnimating state\nconst wrappedAnimateOut = async () => {\n  if (!animation.animateOut) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateOut()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    try {\n      isAnimating.value = true\n      // Reverse the current animation\n      anim.reverse()\n      await anim.finished\n    } finally {\n      isAnimating.value = false\n    }\n  } else {\n    // Fallback: play exit animation if no animation running\n    await wrappedAnimateOut()\n  }\n}\n\n// Export wrapped versions for use in template\nconst animateIn = wrappedAnimateIn\nconst animateOut = wrappedAnimateOut\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n\n### Step 2.3: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.4: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.5: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.6: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.2: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.3: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.4: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**\n","structuredPatch":[{"oldStart":246,"oldLines":7,"newStart":246,"newLines":24,"lines":[" - âœ… Preserves `reverse()` for click-outside (solves Blocker #3)"," - âœ… Maintains exact same lifecycle hooks"," - âœ… Gains environment detection automatically","+- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue","+- âœ… **Separate browser support check** - Allows environment throttling to work correctly"," ","+**Critical Implementation Details:**","+","+1. **`isAnimating` State Tracking**","+   - `useAnimation.isPlaying` only updates when `play()` is called","+   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`","+   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations","+   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`","+","+2. **Browser Support vs Environment Throttling**","+   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS","+   - But we WANT scaled animations to run (30% duration on low battery, etc.)","+   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)","+   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`","+   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly","+"," ### Step 2.3: Keep Exact Same Lifecycle Logic"," "," **Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"ceadfc37-5a37-4752-b489-51fc679138b3","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BgCk3y8otnXYdnSHHaP8WE","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add a new section explaining how environment throttling will actually work with this fix:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1281,"cache_read_input_tokens":135991,"cache_creation":{"ephemeral_5m_input_tokens":1281,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTto6CoaSpemcDTNxc5sp","type":"assistant","uuid":"3e1fa0f8-e63b-40e7-9cc9-d0159cded6f8","timestamp":"2025-10-08T00:36:39.783Z"}
{"parentUuid":"3e1fa0f8-e63b-40e7-9cc9-d0159cded6f8","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BgCk3y8otnXYdnSHHaP8WE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013rPvrMo8xGcxR3fHsziH5Y","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/FLOATING_V2.md","old_string":"### Step 2.3: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):","new_string":"### Step 2.3: How Environment Throttling Works (Post-Fix)\n\n**With the fixes above, here's how environment detection actually works:**\n\n**Scenario 1: Low Battery (<20%)**\n```typescript\n// User opens floating element\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    // isAnimationSupported checks browser capability (always true in modern browsers)\n    if (isAnimationSupported.value) {\n      await animateIn() // Calls animation.animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'low' (due to battery)\n      // - effectiveDuration = baseDuration * 0.3\n      // - Animation runs with 30% of normal duration (FAST but smooth)\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n\n**Scenario 2: Reduced Motion Preference**\n```typescript\n// User has prefers-reduced-motion enabled\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'none' (due to reduced motion)\n      // - Skips animation, applies final state instantly\n      // - Returns immediately\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** No animation, final state applied instantly (accessible)\n\n**Scenario 3: Low FPS (<30fps)**\n```typescript\n// Device is struggling with performance\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'medium' (due to low FPS)\n      // - effectiveDuration = baseDuration * 0.6\n      // - Animation runs with 60% of normal duration\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n\n**Key Insight:**\n- `isAnimationSupported` checks **browser capability** (Web Animations API support)\n- `animation.canAnimate` checks **environment conditions** (battery, FPS, motion preference)\n- `animation.animateIn()` internally handles environment throttling by scaling duration\n- We check `isAnimationSupported` to decide **whether to animate at all**\n- `useAnimation` handles **how to animate** based on environment\n\n### Step 2.4: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1281,"cache_read_input_tokens":135991,"cache_creation":{"ephemeral_5m_input_tokens":1281,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTto6CoaSpemcDTNxc5sp","type":"assistant","uuid":"ce998297-ea00-47f5-9b34-69d515ad6941","timestamp":"2025-10-08T00:36:53.978Z"}
{"parentUuid":"ce998297-ea00-47f5-9b34-69d515ad6941","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013rPvrMo8xGcxR3fHsziH5Y","type":"tool_result","content":"The file /Users/natedamstra/socialaize/FLOATING_V2.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   263â†’   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   264â†’   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   265â†’   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly\n   266â†’\n   267â†’### Step 2.3: How Environment Throttling Works (Post-Fix)\n   268â†’\n   269â†’**With the fixes above, here's how environment detection actually works:**\n   270â†’\n   271â†’**Scenario 1: Low Battery (<20%)**\n   272â†’```typescript\n   273â†’// User opens floating element\n   274â†’watch(() => props.modelValue, async (newValue) => {\n   275â†’  if (newValue) {\n   276â†’    emit('animationStart', 'enter')\n   277â†’    isVisible.value = true\n   278â†’    await nextTick()\n   279â†’\n   280â†’    // isAnimationSupported checks browser capability (always true in modern browsers)\n   281â†’    if (isAnimationSupported.value) {\n   282â†’      await animateIn() // Calls animation.animateIn()\n   283â†’      // Inside useAnimation.ts:1279-1287:\n   284â†’      // - animationQuality.value === 'low' (due to battery)\n   285â†’      // - effectiveDuration = baseDuration * 0.3\n   286â†’      // - Animation runs with 30% of normal duration (FAST but smooth)\n   287â†’    }\n   288â†’\n   289â†’    emit('animationComplete', 'enter')\n   290â†’  }\n   291â†’})\n   292â†’```\n   293â†’âœ… **Result:** Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n   294â†’\n   295â†’**Scenario 2: Reduced Motion Preference**\n   296â†’```typescript\n   297â†’// User has prefers-reduced-motion enabled\n   298â†’watch(() => props.modelValue, async (newValue) => {\n   299â†’  if (newValue) {\n   300â†’    emit('animationStart', 'enter')\n   301â†’    isVisible.value = true\n   302â†’    await nextTick()\n   303â†’\n   304â†’    if (isAnimationSupported.value) {\n   305â†’      await animateIn()\n   306â†’      // Inside useAnimation.ts:1279-1287:\n   307â†’      // - animationQuality.value === 'none' (due to reduced motion)\n   308â†’      // - Skips animation, applies final state instantly\n   309â†’      // - Returns immediately\n   310â†’    }\n   311â†’\n   312â†’    emit('animationComplete', 'enter')\n   313â†’  }\n   314â†’})\n   315â†’```\n   316â†’âœ… **Result:** No animation, final state applied instantly (accessible)\n   317â†’\n   318â†’**Scenario 3: Low FPS (<30fps)**\n   319â†’```typescript\n   320â†’// Device is struggling with performance\n   321â†’watch(() => props.modelValue, async (newValue) => {\n   322â†’  if (newValue) {\n   323â†’    emit('animationStart', 'enter')\n   324â†’    isVisible.value = true\n   325â†’    await nextTick()\n   326â†’\n   327â†’    if (isAnimationSupported.value) {\n   328â†’      await animateIn()\n   329â†’      // Inside useAnimation.ts:1279-1287:\n   330â†’      // - animationQuality.value === 'medium' (due to low FPS)\n   331â†’      // - effectiveDuration = baseDuration * 0.6\n   332â†’      // - Animation runs with 60% of normal duration\n   333â†’    }\n   334â†’\n   335â†’    emit('animationComplete', 'enter')\n   336â†’  }\n   337â†’})\n   338â†’```\n   339â†’âœ… **Result:** Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n   340â†’\n   341â†’**Key Insight:**\n   342â†’- `isAnimationSupported` checks **browser capability** (Web Animations API support)\n   343â†’- `animation.canAnimate` checks **environment conditions** (battery, FPS, motion preference)\n   344â†’- `animation.animateIn()` internally handles environment throttling by scaling duration\n   345â†’- We check `isAnimationSupported` to decide **whether to animate at all**\n   346â†’- `useAnimation` handles **how to animate** based on environment\n   347â†’\n   348â†’### Step 2.4: Keep Exact Same Lifecycle Logic\n   349â†’\n   350â†’**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n   351â†’\n   352â†’```typescript\n   353â†’watch(() => props.modelValue, async (newValue, oldValue) => {\n   354â†’  if (!isMounted.value) return"}]},"uuid":"71185748-1c9e-4bb7-90b3-e4999bfc62c6","timestamp":"2025-10-08T00:36:54.126Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/FLOATING_V2.md","oldString":"### Step 2.3: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):","newString":"### Step 2.3: How Environment Throttling Works (Post-Fix)\n\n**With the fixes above, here's how environment detection actually works:**\n\n**Scenario 1: Low Battery (<20%)**\n```typescript\n// User opens floating element\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    // isAnimationSupported checks browser capability (always true in modern browsers)\n    if (isAnimationSupported.value) {\n      await animateIn() // Calls animation.animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'low' (due to battery)\n      // - effectiveDuration = baseDuration * 0.3\n      // - Animation runs with 30% of normal duration (FAST but smooth)\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n\n**Scenario 2: Reduced Motion Preference**\n```typescript\n// User has prefers-reduced-motion enabled\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'none' (due to reduced motion)\n      // - Skips animation, applies final state instantly\n      // - Returns immediately\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** No animation, final state applied instantly (accessible)\n\n**Scenario 3: Low FPS (<30fps)**\n```typescript\n// Device is struggling with performance\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'medium' (due to low FPS)\n      // - effectiveDuration = baseDuration * 0.6\n      // - Animation runs with 60% of normal duration\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n\n**Key Insight:**\n- `isAnimationSupported` checks **browser capability** (Web Animations API support)\n- `animation.canAnimate` checks **environment conditions** (battery, FPS, motion preference)\n- `animation.animateIn()` internally handles environment throttling by scaling duration\n- We check `isAnimationSupported` to decide **whether to animate at all**\n- `useAnimation` handles **how to animate** based on environment\n\n### Step 2.4: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):","originalFile":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// CRITICAL: Track animation state separately from useAnimation's isPlaying\n// because isPlaying only updates when play() is called, not animateIn/animateOut\nconst isAnimating = ref(false)\n\n// CRITICAL: Separate Web Animations support check from environment throttling\n// canAnimate goes false for low battery/FPS, but we still want to run animations\n// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\nconst isAnimationSupported = computed(() => {\n  // Check if Web Animations API is available (browser support)\n  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n\n// Wrap animateIn to track isAnimating state\nconst wrappedAnimateIn = async () => {\n  if (!animation.animateIn) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Wrap animateOut to track isAnimating state\nconst wrappedAnimateOut = async () => {\n  if (!animation.animateOut) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateOut()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    try {\n      isAnimating.value = true\n      // Reverse the current animation\n      anim.reverse()\n      await anim.finished\n    } finally {\n      isAnimating.value = false\n    }\n  } else {\n    // Fallback: play exit animation if no animation running\n    await wrappedAnimateOut()\n  }\n}\n\n// Export wrapped versions for use in template\nconst animateIn = wrappedAnimateIn\nconst animateOut = wrappedAnimateOut\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue\n- âœ… **Separate browser support check** - Allows environment throttling to work correctly\n\n**Critical Implementation Details:**\n\n1. **`isAnimating` State Tracking**\n   - `useAnimation.isPlaying` only updates when `play()` is called\n   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`\n   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations\n   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`\n\n2. **Browser Support vs Environment Throttling**\n   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS\n   - But we WANT scaled animations to run (30% duration on low battery, etc.)\n   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly\n\n### Step 2.3: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.4: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.5: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.6: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.2: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.3: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.4: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**\n","structuredPatch":[{"oldStart":264,"oldLines":8,"newStart":264,"newLines":89,"lines":["    - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`","    - This allows environment-throttled animations to run with scaled duration instead of snapping instantly"," ","-### Step 2.3: Keep Exact Same Lifecycle Logic","+### Step 2.3: How Environment Throttling Works (Post-Fix)"," ","+**With the fixes above, here's how environment detection actually works:**","+","+**Scenario 1: Low Battery (<20%)**","+```typescript","+// User opens floating element","+watch(() => props.modelValue, async (newValue) => {","+  if (newValue) {","+    emit('animationStart', 'enter')","+    isVisible.value = true","+    await nextTick()","+","+    // isAnimationSupported checks browser capability (always true in modern browsers)","+    if (isAnimationSupported.value) {","+      await animateIn() // Calls animation.animateIn()","+      // Inside useAnimation.ts:1279-1287:","+      // - animationQuality.value === 'low' (due to battery)","+      // - effectiveDuration = baseDuration * 0.3","+      // - Animation runs with 30% of normal duration (FAST but smooth)","+    }","+","+    emit('animationComplete', 'enter')","+  }","+})","+```","+âœ… **Result:** Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)","+","+**Scenario 2: Reduced Motion Preference**","+```typescript","+// User has prefers-reduced-motion enabled","+watch(() => props.modelValue, async (newValue) => {","+  if (newValue) {","+    emit('animationStart', 'enter')","+    isVisible.value = true","+    await nextTick()","+","+    if (isAnimationSupported.value) {","+      await animateIn()","+      // Inside useAnimation.ts:1279-1287:","+      // - animationQuality.value === 'none' (due to reduced motion)","+      // - Skips animation, applies final state instantly","+      // - Returns immediately","+    }","+","+    emit('animationComplete', 'enter')","+  }","+})","+```","+âœ… **Result:** No animation, final state applied instantly (accessible)","+","+**Scenario 3: Low FPS (<30fps)**","+```typescript","+// Device is struggling with performance","+watch(() => props.modelValue, async (newValue) => {","+  if (newValue) {","+    emit('animationStart', 'enter')","+    isVisible.value = true","+    await nextTick()","+","+    if (isAnimationSupported.value) {","+      await animateIn()","+      // Inside useAnimation.ts:1279-1287:","+      // - animationQuality.value === 'medium' (due to low FPS)","+      // - effectiveDuration = baseDuration * 0.6","+      // - Animation runs with 60% of normal duration","+    }","+","+    emit('animationComplete', 'enter')","+  }","+})","+```","+âœ… **Result:** Animation runs at 60% speed (e.g., 300ms instead of 500ms)","+","+**Key Insight:**","+- `isAnimationSupported` checks **browser capability** (Web Animations API support)","+- `animation.canAnimate` checks **environment conditions** (battery, FPS, motion preference)","+- `animation.animateIn()` internally handles environment throttling by scaling duration","+- We check `isAnimationSupported` to decide **whether to animate at all**","+- `useAnimation` handles **how to animate** based on environment","+","+### Step 2.4: Keep Exact Same Lifecycle Logic","+"," **Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):"," "," ```typescript"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"71185748-1c9e-4bb7-90b3-e4999bfc62c6","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01NfBRoTrmj6DaufKiHJyG6t","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now let me update the section numbers and add a critical testing section for these two fixes:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":2291,"cache_read_input_tokens":137272,"cache_creation":{"ephemeral_5m_input_tokens":2291,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTto7aV6DC8VSw5uvj6xB","type":"assistant","uuid":"af6e6de0-9238-4f47-b975-aecb60379a3d","timestamp":"2025-10-08T00:36:58.709Z"}
{"parentUuid":"af6e6de0-9238-4f47-b975-aecb60379a3d","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01NfBRoTrmj6DaufKiHJyG6t","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Qt8euqkD5uV5ATdvM1AGQa","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/FLOATING_V2.md","old_string":"### Step 2.4: Update `onComplete` Callback","new_string":"### Step 2.5: Update `onComplete` Callback"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":2291,"cache_read_input_tokens":137272,"cache_creation":{"ephemeral_5m_input_tokens":2291,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTto7aV6DC8VSw5uvj6xB","type":"assistant","uuid":"1480c91a-fb23-49bc-bcfb-da00e762c942","timestamp":"2025-10-08T00:37:00.391Z"}
{"parentUuid":"1480c91a-fb23-49bc-bcfb-da00e762c942","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Qt8euqkD5uV5ATdvM1AGQa","type":"tool_result","content":"The file /Users/natedamstra/socialaize/FLOATING_V2.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   378â†’- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n   379â†’- Timing of `isVisible` changes is critical for `shouldRender`\n   380â†’- Event emission order matters for parent components\n   381â†’\n   382â†’### Step 2.5: Update `onComplete` Callback\n   383â†’\n   384â†’Since we removed `onComplete` from animation options, we need to handle it differently:\n   385â†’\n   386â†’**Option A: Use lifecycle hooks (Recommended)**"}]},"uuid":"f12abac3-22b4-4428-bd05-ba8942337293","timestamp":"2025-10-08T00:37:00.660Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/FLOATING_V2.md","oldString":"### Step 2.4: Update `onComplete` Callback","newString":"### Step 2.5: Update `onComplete` Callback","originalFile":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// CRITICAL: Track animation state separately from useAnimation's isPlaying\n// because isPlaying only updates when play() is called, not animateIn/animateOut\nconst isAnimating = ref(false)\n\n// CRITICAL: Separate Web Animations support check from environment throttling\n// canAnimate goes false for low battery/FPS, but we still want to run animations\n// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\nconst isAnimationSupported = computed(() => {\n  // Check if Web Animations API is available (browser support)\n  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n\n// Wrap animateIn to track isAnimating state\nconst wrappedAnimateIn = async () => {\n  if (!animation.animateIn) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Wrap animateOut to track isAnimating state\nconst wrappedAnimateOut = async () => {\n  if (!animation.animateOut) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateOut()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    try {\n      isAnimating.value = true\n      // Reverse the current animation\n      anim.reverse()\n      await anim.finished\n    } finally {\n      isAnimating.value = false\n    }\n  } else {\n    // Fallback: play exit animation if no animation running\n    await wrappedAnimateOut()\n  }\n}\n\n// Export wrapped versions for use in template\nconst animateIn = wrappedAnimateIn\nconst animateOut = wrappedAnimateOut\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue\n- âœ… **Separate browser support check** - Allows environment throttling to work correctly\n\n**Critical Implementation Details:**\n\n1. **`isAnimating` State Tracking**\n   - `useAnimation.isPlaying` only updates when `play()` is called\n   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`\n   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations\n   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`\n\n2. **Browser Support vs Environment Throttling**\n   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS\n   - But we WANT scaled animations to run (30% duration on low battery, etc.)\n   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly\n\n### Step 2.3: How Environment Throttling Works (Post-Fix)\n\n**With the fixes above, here's how environment detection actually works:**\n\n**Scenario 1: Low Battery (<20%)**\n```typescript\n// User opens floating element\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    // isAnimationSupported checks browser capability (always true in modern browsers)\n    if (isAnimationSupported.value) {\n      await animateIn() // Calls animation.animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'low' (due to battery)\n      // - effectiveDuration = baseDuration * 0.3\n      // - Animation runs with 30% of normal duration (FAST but smooth)\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n\n**Scenario 2: Reduced Motion Preference**\n```typescript\n// User has prefers-reduced-motion enabled\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'none' (due to reduced motion)\n      // - Skips animation, applies final state instantly\n      // - Returns immediately\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** No animation, final state applied instantly (accessible)\n\n**Scenario 3: Low FPS (<30fps)**\n```typescript\n// Device is struggling with performance\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'medium' (due to low FPS)\n      // - effectiveDuration = baseDuration * 0.6\n      // - Animation runs with 60% of normal duration\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n\n**Key Insight:**\n- `isAnimationSupported` checks **browser capability** (Web Animations API support)\n- `animation.canAnimate` checks **environment conditions** (battery, FPS, motion preference)\n- `animation.animateIn()` internally handles environment throttling by scaling duration\n- We check `isAnimationSupported` to decide **whether to animate at all**\n- `useAnimation` handles **how to animate** based on environment\n\n### Step 2.4: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.4: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.5: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.6: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.2: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.3: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.4: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**\n","structuredPatch":[{"oldStart":379,"oldLines":7,"newStart":379,"newLines":7,"lines":[" - Timing of `isVisible` changes is critical for `shouldRender`"," - Event emission order matters for parent components"," ","-### Step 2.4: Update `onComplete` Callback","+### Step 2.5: Update `onComplete` Callback"," "," Since we removed `onComplete` from animation options, we need to handle it differently:"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"f12abac3-22b4-4428-bd05-ba8942337293","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TSaGDXRu4wywQKtz8tiAoY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017m9iBm58Wthid1gVTeNV6d","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/FLOATING_V2.md","old_string":"### Step 2.5: Update `handleClose` Function","new_string":"### Step 2.6: Update `handleClose` Function"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":431,"cache_read_input_tokens":139563,"cache_creation":{"ephemeral_5m_input_tokens":431,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard"}},"requestId":"req_011CTto84Y3jeanerAtoyvNJ","type":"assistant","uuid":"4fca23f6-d9c0-44bb-ad12-9bff6887a6b0","timestamp":"2025-10-08T00:37:06.036Z"}
{"parentUuid":"4fca23f6-d9c0-44bb-ad12-9bff6887a6b0","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017m9iBm58Wthid1gVTeNV6d","type":"tool_result","content":"The file /Users/natedamstra/socialaize/FLOATING_V2.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   430â†’```\n   431â†’\n   432â†’**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n   433â†’\n   434â†’### Step 2.6: Update `handleClose` Function\n   435â†’\n   436â†’**Current (line 129-134):**\n   437â†’```typescript\n   438â†’const handleClose = async () => {"}]},"uuid":"64379057-611e-41cd-a536-ff9d23a0c5ed","timestamp":"2025-10-08T00:37:06.116Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/FLOATING_V2.md","oldString":"### Step 2.5: Update `handleClose` Function","newString":"### Step 2.6: Update `handleClose` Function","originalFile":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// CRITICAL: Track animation state separately from useAnimation's isPlaying\n// because isPlaying only updates when play() is called, not animateIn/animateOut\nconst isAnimating = ref(false)\n\n// CRITICAL: Separate Web Animations support check from environment throttling\n// canAnimate goes false for low battery/FPS, but we still want to run animations\n// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\nconst isAnimationSupported = computed(() => {\n  // Check if Web Animations API is available (browser support)\n  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n\n// Wrap animateIn to track isAnimating state\nconst wrappedAnimateIn = async () => {\n  if (!animation.animateIn) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Wrap animateOut to track isAnimating state\nconst wrappedAnimateOut = async () => {\n  if (!animation.animateOut) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateOut()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    try {\n      isAnimating.value = true\n      // Reverse the current animation\n      anim.reverse()\n      await anim.finished\n    } finally {\n      isAnimating.value = false\n    }\n  } else {\n    // Fallback: play exit animation if no animation running\n    await wrappedAnimateOut()\n  }\n}\n\n// Export wrapped versions for use in template\nconst animateIn = wrappedAnimateIn\nconst animateOut = wrappedAnimateOut\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue\n- âœ… **Separate browser support check** - Allows environment throttling to work correctly\n\n**Critical Implementation Details:**\n\n1. **`isAnimating` State Tracking**\n   - `useAnimation.isPlaying` only updates when `play()` is called\n   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`\n   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations\n   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`\n\n2. **Browser Support vs Environment Throttling**\n   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS\n   - But we WANT scaled animations to run (30% duration on low battery, etc.)\n   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly\n\n### Step 2.3: How Environment Throttling Works (Post-Fix)\n\n**With the fixes above, here's how environment detection actually works:**\n\n**Scenario 1: Low Battery (<20%)**\n```typescript\n// User opens floating element\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    // isAnimationSupported checks browser capability (always true in modern browsers)\n    if (isAnimationSupported.value) {\n      await animateIn() // Calls animation.animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'low' (due to battery)\n      // - effectiveDuration = baseDuration * 0.3\n      // - Animation runs with 30% of normal duration (FAST but smooth)\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n\n**Scenario 2: Reduced Motion Preference**\n```typescript\n// User has prefers-reduced-motion enabled\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'none' (due to reduced motion)\n      // - Skips animation, applies final state instantly\n      // - Returns immediately\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** No animation, final state applied instantly (accessible)\n\n**Scenario 3: Low FPS (<30fps)**\n```typescript\n// Device is struggling with performance\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'medium' (due to low FPS)\n      // - effectiveDuration = baseDuration * 0.6\n      // - Animation runs with 60% of normal duration\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n\n**Key Insight:**\n- `isAnimationSupported` checks **browser capability** (Web Animations API support)\n- `animation.canAnimate` checks **environment conditions** (battery, FPS, motion preference)\n- `animation.animateIn()` internally handles environment throttling by scaling duration\n- We check `isAnimationSupported` to decide **whether to animate at all**\n- `useAnimation` handles **how to animate** based on environment\n\n### Step 2.4: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.5: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.5: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.6: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.2: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.3: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.4: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**\n","structuredPatch":[{"oldStart":431,"oldLines":7,"newStart":431,"newLines":7,"lines":[" "," **Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)"," ","-### Step 2.5: Update `handleClose` Function","+### Step 2.6: Update `handleClose` Function"," "," **Current (line 129-134):**"," ```typescript"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"64379057-611e-41cd-a536-ff9d23a0c5ed","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BMnRJPNBsBFNib7aA8ZyPN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BBic3c5s7N9A4fVptHT2XS","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/FLOATING_V2.md","old_string":"### Step 2.6: Update `defineExpose`","new_string":"### Step 2.7: Update `defineExpose`"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":280,"cache_read_input_tokens":139994,"cache_creation":{"ephemeral_5m_input_tokens":280,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard"}},"requestId":"req_011CTto8Tg62yMpQop1SXypa","type":"assistant","uuid":"99efd967-aef8-44c0-bba2-66d73604fd69","timestamp":"2025-10-08T00:37:10.315Z"}
{"parentUuid":"99efd967-aef8-44c0-bba2-66d73604fd69","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BBic3c5s7N9A4fVptHT2XS","type":"tool_result","content":"The file /Users/natedamstra/socialaize/FLOATING_V2.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   456â†’**Why unchanged?**\n   457â†’- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n   458â†’- Timing and behavior remain identical\n   459â†’\n   460â†’### Step 2.7: Update `defineExpose`\n   461â†’\n   462â†’**Current (lines 140-146):**\n   463â†’```typescript\n   464â†’defineExpose({"}]},"uuid":"e01718b2-7e9b-4813-b1d3-2caa6fd69bb9","timestamp":"2025-10-08T00:37:10.407Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/FLOATING_V2.md","oldString":"### Step 2.6: Update `defineExpose`","newString":"### Step 2.7: Update `defineExpose`","originalFile":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// CRITICAL: Track animation state separately from useAnimation's isPlaying\n// because isPlaying only updates when play() is called, not animateIn/animateOut\nconst isAnimating = ref(false)\n\n// CRITICAL: Separate Web Animations support check from environment throttling\n// canAnimate goes false for low battery/FPS, but we still want to run animations\n// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\nconst isAnimationSupported = computed(() => {\n  // Check if Web Animations API is available (browser support)\n  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n\n// Wrap animateIn to track isAnimating state\nconst wrappedAnimateIn = async () => {\n  if (!animation.animateIn) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Wrap animateOut to track isAnimating state\nconst wrappedAnimateOut = async () => {\n  if (!animation.animateOut) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateOut()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    try {\n      isAnimating.value = true\n      // Reverse the current animation\n      anim.reverse()\n      await anim.finished\n    } finally {\n      isAnimating.value = false\n    }\n  } else {\n    // Fallback: play exit animation if no animation running\n    await wrappedAnimateOut()\n  }\n}\n\n// Export wrapped versions for use in template\nconst animateIn = wrappedAnimateIn\nconst animateOut = wrappedAnimateOut\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue\n- âœ… **Separate browser support check** - Allows environment throttling to work correctly\n\n**Critical Implementation Details:**\n\n1. **`isAnimating` State Tracking**\n   - `useAnimation.isPlaying` only updates when `play()` is called\n   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`\n   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations\n   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`\n\n2. **Browser Support vs Environment Throttling**\n   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS\n   - But we WANT scaled animations to run (30% duration on low battery, etc.)\n   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly\n\n### Step 2.3: How Environment Throttling Works (Post-Fix)\n\n**With the fixes above, here's how environment detection actually works:**\n\n**Scenario 1: Low Battery (<20%)**\n```typescript\n// User opens floating element\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    // isAnimationSupported checks browser capability (always true in modern browsers)\n    if (isAnimationSupported.value) {\n      await animateIn() // Calls animation.animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'low' (due to battery)\n      // - effectiveDuration = baseDuration * 0.3\n      // - Animation runs with 30% of normal duration (FAST but smooth)\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n\n**Scenario 2: Reduced Motion Preference**\n```typescript\n// User has prefers-reduced-motion enabled\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'none' (due to reduced motion)\n      // - Skips animation, applies final state instantly\n      // - Returns immediately\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** No animation, final state applied instantly (accessible)\n\n**Scenario 3: Low FPS (<30fps)**\n```typescript\n// Device is struggling with performance\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'medium' (due to low FPS)\n      // - effectiveDuration = baseDuration * 0.6\n      // - Animation runs with 60% of normal duration\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n\n**Key Insight:**\n- `isAnimationSupported` checks **browser capability** (Web Animations API support)\n- `animation.canAnimate` checks **environment conditions** (battery, FPS, motion preference)\n- `animation.animateIn()` internally handles environment throttling by scaling duration\n- We check `isAnimationSupported` to decide **whether to animate at all**\n- `useAnimation` handles **how to animate** based on environment\n\n### Step 2.4: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.5: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.6: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.6: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.2: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.3: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.4: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**\n","structuredPatch":[{"oldStart":457,"oldLines":7,"newStart":457,"newLines":7,"lines":[" - The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly"," - Timing and behavior remain identical"," ","-### Step 2.6: Update `defineExpose`","+### Step 2.7: Update `defineExpose`"," "," **Current (lines 140-146):**"," ```typescript"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"e01718b2-7e9b-4813-b1d3-2caa6fd69bb9","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017EYiand42YKUDD4sYXLLWU","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add a critical testing section specifically for these two fixes:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":290,"cache_read_input_tokens":140274,"cache_creation":{"ephemeral_5m_input_tokens":290,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTto8knz1dZj6j7rBR2gN","type":"assistant","uuid":"16abdb67-5d4a-4dbc-bc0e-9045b2aa61bb","timestamp":"2025-10-08T00:37:13.956Z"}
{"parentUuid":"16abdb67-5d4a-4dbc-bc0e-9045b2aa61bb","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017EYiand42YKUDD4sYXLLWU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PykwJ21hRW39cnpYcBVsz6","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/FLOATING_V2.md","old_string":"### Step 3.1: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:","new_string":"### Step 3.1: Critical Fix Validation (MUST PASS BEFORE PROCEEDING)\n\n**Test Fix #1: `isAnimating` State Tracking**\n\nVerify that slot consumers receive correct `isAnimating` values:\n\n```vue\n<!-- Test in AiConductorGraphicV2.vue -->\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  @animation-start=\"handleFloatingElementStart\"\n  @animation-complete=\"handleFloatingElementComplete\"\n>\n  <template #default=\"{ isAnimating: isFloatingAnimating }\">\n    <!-- CRITICAL: This must be true during enter/exit animations -->\n    <div v-if=\"isFloatingAnimating\">\n      ANIMATING: {{ isFloatingAnimating }}\n    </div>\n\n    <!-- Chat bubble should be HIDDEN during animations -->\n    <ChatBubble\n      v-if=\"showConductorCommand && !isFloatingAnimating\"\n      :messages=\"chatMessages\"\n    />\n  </template>\n</AnimatedFloatingElement>\n```\n\n**Expected Behavior:**\n1. Open conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n2. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Chat bubble SHOWS\n3. Close conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n4. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Component unmounts\n\n**Failure Symptoms:**\n- âŒ Chat bubble shows during enter animation (flickering)\n- âŒ Provider responses visible during exit animation (visual regression)\n- âŒ `isFloatingAnimating` always `false` (broken slot prop)\n\n**Test Fix #2: Environment Throttling Still Works**\n\nVerify that low battery/FPS still runs scaled animations (not instant snaps):\n\n**Test 2.1: Low Battery**\n```typescript\n// DevTools â†’ Sensors â†’ Battery\n// Set: Level 15%, Charging: No\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n// - NOT instant snap to final state\n// - Still smooth visual transition, just faster\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Test 2.2: Reduced Motion**\n```typescript\n// System Settings â†’ Accessibility â†’ Reduce Motion: ON\n// OR DevTools â†’ Rendering â†’ Emulate CSS prefers-reduced-motion: reduce\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation skips entirely\n// - Final state applied instantly\n// - No visual motion\n\n// Failure: Animation still runs (accessibility violation)\n```\n\n**Test 2.3: Low FPS**\n```typescript\n// DevTools â†’ Performance â†’ CPU: 6x slowdown\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n// - Smooth transition, no jank\n// - Performance-adapted\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Critical:** If any of these tests fail, **DO NOT PROCEED** to Phase 4. The wrappers around `animateIn`/`animateOut` are not working correctly.\n\n### Step 3.2: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":290,"cache_read_input_tokens":140274,"cache_creation":{"ephemeral_5m_input_tokens":290,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTto8knz1dZj6j7rBR2gN","type":"assistant","uuid":"0061a90d-c14e-4e89-ab52-2c009f1f7a47","timestamp":"2025-10-08T00:37:31.737Z"}
{"parentUuid":"0061a90d-c14e-4e89-ab52-2c009f1f7a47","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PykwJ21hRW39cnpYcBVsz6","type":"tool_result","content":"The file /Users/natedamstra/socialaize/FLOATING_V2.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   486â†’---\n   487â†’\n   488â†’## Phase 3: Validation & Testing (1 hour)\n   489â†’\n   490â†’### Step 3.1: Critical Fix Validation (MUST PASS BEFORE PROCEEDING)\n   491â†’\n   492â†’**Test Fix #1: `isAnimating` State Tracking**\n   493â†’\n   494â†’Verify that slot consumers receive correct `isAnimating` values:\n   495â†’\n   496â†’```vue\n   497â†’<!-- Test in AiConductorGraphicV2.vue -->\n   498â†’<AnimatedFloatingElement\n   499â†’  v-model=\"isVisible\"\n   500â†’  @animation-start=\"handleFloatingElementStart\"\n   501â†’  @animation-complete=\"handleFloatingElementComplete\"\n   502â†’>\n   503â†’  <template #default=\"{ isAnimating: isFloatingAnimating }\">\n   504â†’    <!-- CRITICAL: This must be true during enter/exit animations -->\n   505â†’    <div v-if=\"isFloatingAnimating\">\n   506â†’      ANIMATING: {{ isFloatingAnimating }}\n   507â†’    </div>\n   508â†’\n   509â†’    <!-- Chat bubble should be HIDDEN during animations -->\n   510â†’    <ChatBubble\n   511â†’      v-if=\"showConductorCommand && !isFloatingAnimating\"\n   512â†’      :messages=\"chatMessages\"\n   513â†’    />\n   514â†’  </template>\n   515â†’</AnimatedFloatingElement>\n   516â†’```\n   517â†’\n   518â†’**Expected Behavior:**\n   519â†’1. Open conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n   520â†’2. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Chat bubble SHOWS\n   521â†’3. Close conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n   522â†’4. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Component unmounts\n   523â†’\n   524â†’**Failure Symptoms:**\n   525â†’- âŒ Chat bubble shows during enter animation (flickering)\n   526â†’- âŒ Provider responses visible during exit animation (visual regression)\n   527â†’- âŒ `isFloatingAnimating` always `false` (broken slot prop)\n   528â†’\n   529â†’**Test Fix #2: Environment Throttling Still Works**\n   530â†’\n   531â†’Verify that low battery/FPS still runs scaled animations (not instant snaps):\n   532â†’\n   533â†’**Test 2.1: Low Battery**\n   534â†’```typescript\n   535â†’// DevTools â†’ Sensors â†’ Battery\n   536â†’// Set: Level 15%, Charging: No\n   537â†’\n   538â†’// Open floating element\n   539â†’isVisible.value = true\n   540â†’\n   541â†’// Expected:\n   542â†’// - Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n   543â†’// - NOT instant snap to final state\n   544â†’// - Still smooth visual transition, just faster\n   545â†’\n   546â†’// Failure: Element snaps to final state instantly (broken throttling)\n   547â†’```\n   548â†’\n   549â†’**Test 2.2: Reduced Motion**\n   550â†’```typescript\n   551â†’// System Settings â†’ Accessibility â†’ Reduce Motion: ON\n   552â†’// OR DevTools â†’ Rendering â†’ Emulate CSS prefers-reduced-motion: reduce\n   553â†’\n   554â†’// Open floating element\n   555â†’isVisible.value = true\n   556â†’\n   557â†’// Expected:\n   558â†’// - Animation skips entirely\n   559â†’// - Final state applied instantly\n   560â†’// - No visual motion\n   561â†’\n   562â†’// Failure: Animation still runs (accessibility violation)\n   563â†’```\n   564â†’\n   565â†’**Test 2.3: Low FPS**\n   566â†’```typescript\n   567â†’// DevTools â†’ Performance â†’ CPU: 6x slowdown\n   568â†’\n   569â†’// Open floating element\n   570â†’isVisible.value = true\n   571â†’\n   572â†’// Expected:\n   573â†’// - Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n   574â†’// - Smooth transition, no jank\n   575â†’// - Performance-adapted\n   576â†’\n   577â†’// Failure: Element snaps to final state instantly (broken throttling)\n   578â†’```\n   579â†’\n   580â†’**Critical:** If any of these tests fail, **DO NOT PROCEED** to Phase 4. The wrappers around `animateIn`/`animateOut` are not working correctly.\n   581â†’\n   582â†’### Step 3.2: Visual Regression Testing\n   583â†’\n   584â†’Test `AiConductorGraphicV2.vue` thoroughly:\n   585â†’\n   586â†’1. **Enter Animation**\n   587â†’   - Component mounts â†’ floating element fades in\n   588â†’   - Conductor animation starts AFTER enter completes"}]},"uuid":"9b4fc770-736f-4736-9486-f9c14ec40032","timestamp":"2025-10-08T00:37:31.839Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/FLOATING_V2.md","oldString":"### Step 3.1: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:","newString":"### Step 3.1: Critical Fix Validation (MUST PASS BEFORE PROCEEDING)\n\n**Test Fix #1: `isAnimating` State Tracking**\n\nVerify that slot consumers receive correct `isAnimating` values:\n\n```vue\n<!-- Test in AiConductorGraphicV2.vue -->\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  @animation-start=\"handleFloatingElementStart\"\n  @animation-complete=\"handleFloatingElementComplete\"\n>\n  <template #default=\"{ isAnimating: isFloatingAnimating }\">\n    <!-- CRITICAL: This must be true during enter/exit animations -->\n    <div v-if=\"isFloatingAnimating\">\n      ANIMATING: {{ isFloatingAnimating }}\n    </div>\n\n    <!-- Chat bubble should be HIDDEN during animations -->\n    <ChatBubble\n      v-if=\"showConductorCommand && !isFloatingAnimating\"\n      :messages=\"chatMessages\"\n    />\n  </template>\n</AnimatedFloatingElement>\n```\n\n**Expected Behavior:**\n1. Open conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n2. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Chat bubble SHOWS\n3. Close conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n4. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Component unmounts\n\n**Failure Symptoms:**\n- âŒ Chat bubble shows during enter animation (flickering)\n- âŒ Provider responses visible during exit animation (visual regression)\n- âŒ `isFloatingAnimating` always `false` (broken slot prop)\n\n**Test Fix #2: Environment Throttling Still Works**\n\nVerify that low battery/FPS still runs scaled animations (not instant snaps):\n\n**Test 2.1: Low Battery**\n```typescript\n// DevTools â†’ Sensors â†’ Battery\n// Set: Level 15%, Charging: No\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n// - NOT instant snap to final state\n// - Still smooth visual transition, just faster\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Test 2.2: Reduced Motion**\n```typescript\n// System Settings â†’ Accessibility â†’ Reduce Motion: ON\n// OR DevTools â†’ Rendering â†’ Emulate CSS prefers-reduced-motion: reduce\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation skips entirely\n// - Final state applied instantly\n// - No visual motion\n\n// Failure: Animation still runs (accessibility violation)\n```\n\n**Test 2.3: Low FPS**\n```typescript\n// DevTools â†’ Performance â†’ CPU: 6x slowdown\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n// - Smooth transition, no jank\n// - Performance-adapted\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Critical:** If any of these tests fail, **DO NOT PROCEED** to Phase 4. The wrappers around `animateIn`/`animateOut` are not working correctly.\n\n### Step 3.2: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:","originalFile":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// CRITICAL: Track animation state separately from useAnimation's isPlaying\n// because isPlaying only updates when play() is called, not animateIn/animateOut\nconst isAnimating = ref(false)\n\n// CRITICAL: Separate Web Animations support check from environment throttling\n// canAnimate goes false for low battery/FPS, but we still want to run animations\n// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\nconst isAnimationSupported = computed(() => {\n  // Check if Web Animations API is available (browser support)\n  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n\n// Wrap animateIn to track isAnimating state\nconst wrappedAnimateIn = async () => {\n  if (!animation.animateIn) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Wrap animateOut to track isAnimating state\nconst wrappedAnimateOut = async () => {\n  if (!animation.animateOut) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateOut()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    try {\n      isAnimating.value = true\n      // Reverse the current animation\n      anim.reverse()\n      await anim.finished\n    } finally {\n      isAnimating.value = false\n    }\n  } else {\n    // Fallback: play exit animation if no animation running\n    await wrappedAnimateOut()\n  }\n}\n\n// Export wrapped versions for use in template\nconst animateIn = wrappedAnimateIn\nconst animateOut = wrappedAnimateOut\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue\n- âœ… **Separate browser support check** - Allows environment throttling to work correctly\n\n**Critical Implementation Details:**\n\n1. **`isAnimating` State Tracking**\n   - `useAnimation.isPlaying` only updates when `play()` is called\n   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`\n   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations\n   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`\n\n2. **Browser Support vs Environment Throttling**\n   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS\n   - But we WANT scaled animations to run (30% duration on low battery, etc.)\n   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly\n\n### Step 2.3: How Environment Throttling Works (Post-Fix)\n\n**With the fixes above, here's how environment detection actually works:**\n\n**Scenario 1: Low Battery (<20%)**\n```typescript\n// User opens floating element\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    // isAnimationSupported checks browser capability (always true in modern browsers)\n    if (isAnimationSupported.value) {\n      await animateIn() // Calls animation.animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'low' (due to battery)\n      // - effectiveDuration = baseDuration * 0.3\n      // - Animation runs with 30% of normal duration (FAST but smooth)\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n\n**Scenario 2: Reduced Motion Preference**\n```typescript\n// User has prefers-reduced-motion enabled\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'none' (due to reduced motion)\n      // - Skips animation, applies final state instantly\n      // - Returns immediately\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** No animation, final state applied instantly (accessible)\n\n**Scenario 3: Low FPS (<30fps)**\n```typescript\n// Device is struggling with performance\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'medium' (due to low FPS)\n      // - effectiveDuration = baseDuration * 0.6\n      // - Animation runs with 60% of normal duration\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n\n**Key Insight:**\n- `isAnimationSupported` checks **browser capability** (Web Animations API support)\n- `animation.canAnimate` checks **environment conditions** (battery, FPS, motion preference)\n- `animation.animateIn()` internally handles environment throttling by scaling duration\n- We check `isAnimationSupported` to decide **whether to animate at all**\n- `useAnimation` handles **how to animate** based on environment\n\n### Step 2.4: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.5: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.6: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.7: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.2: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.3: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.4: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**\n","structuredPatch":[{"oldStart":487,"oldLines":8,"newStart":487,"newLines":100,"lines":[" "," ## Phase 3: Validation & Testing (1 hour)"," ","-### Step 3.1: Visual Regression Testing","+### Step 3.1: Critical Fix Validation (MUST PASS BEFORE PROCEEDING)"," ","+**Test Fix #1: `isAnimating` State Tracking**","+","+Verify that slot consumers receive correct `isAnimating` values:","+","+```vue","+<!-- Test in AiConductorGraphicV2.vue -->","+<AnimatedFloatingElement","+  v-model=\"isVisible\"","+  @animation-start=\"handleFloatingElementStart\"","+  @animation-complete=\"handleFloatingElementComplete\"","+>","+  <template #default=\"{ isAnimating: isFloatingAnimating }\">","+    <!-- CRITICAL: This must be true during enter/exit animations -->","+    <div v-if=\"isFloatingAnimating\">","+      ANIMATING: {{ isFloatingAnimating }}","+    </div>","+","+    <!-- Chat bubble should be HIDDEN during animations -->","+    <ChatBubble","+      v-if=\"showConductorCommand && !isFloatingAnimating\"","+      :messages=\"chatMessages\"","+    />","+  </template>","+</AnimatedFloatingElement>","+```","+","+**Expected Behavior:**","+1. Open conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN","+2. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Chat bubble SHOWS","+3. Close conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN","+4. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Component unmounts","+","+**Failure Symptoms:**","+- âŒ Chat bubble shows during enter animation (flickering)","+- âŒ Provider responses visible during exit animation (visual regression)","+- âŒ `isFloatingAnimating` always `false` (broken slot prop)","+","+**Test Fix #2: Environment Throttling Still Works**","+","+Verify that low battery/FPS still runs scaled animations (not instant snaps):","+","+**Test 2.1: Low Battery**","+```typescript","+// DevTools â†’ Sensors â†’ Battery","+// Set: Level 15%, Charging: No","+","+// Open floating element","+isVisible.value = true","+","+// Expected:","+// - Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)","+// - NOT instant snap to final state","+// - Still smooth visual transition, just faster","+","+// Failure: Element snaps to final state instantly (broken throttling)","+```","+","+**Test 2.2: Reduced Motion**","+```typescript","+// System Settings â†’ Accessibility â†’ Reduce Motion: ON","+// OR DevTools â†’ Rendering â†’ Emulate CSS prefers-reduced-motion: reduce","+","+// Open floating element","+isVisible.value = true","+","+// Expected:","+// - Animation skips entirely","+// - Final state applied instantly","+// - No visual motion","+","+// Failure: Animation still runs (accessibility violation)","+```","+","+**Test 2.3: Low FPS**","+```typescript","+// DevTools â†’ Performance â†’ CPU: 6x slowdown","+","+// Open floating element","+isVisible.value = true","+","+// Expected:","+// - Animation runs at 60% speed (e.g., 300ms instead of 500ms)","+// - Smooth transition, no jank","+// - Performance-adapted","+","+// Failure: Element snaps to final state instantly (broken throttling)","+```","+","+**Critical:** If any of these tests fail, **DO NOT PROCEED** to Phase 4. The wrappers around `animateIn`/`animateOut` are not working correctly.","+","+### Step 3.2: Visual Regression Testing","+"," Test `AiConductorGraphicV2.vue` thoroughly:"," "," 1. **Enter Animation**"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"9b4fc770-736f-4736-9486-f9c14ec40032","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01UyogHint6mWUMx6mD3WGEf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01S8n5Ve5ML3HsuKFoPyBK6Q","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/FLOATING_V2.md","old_string":"### Step 3.2: Environment Detection Testing","new_string":"### Step 3.3: Environment Detection Testing"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":2332,"cache_read_input_tokens":140564,"cache_creation":{"ephemeral_5m_input_tokens":2332,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"}},"requestId":"req_011CTtoANNAFY5jKyEne3eGL","type":"assistant","uuid":"26bccabd-200b-4f06-a61b-dfcce868d898","timestamp":"2025-10-08T00:37:37.753Z"}
{"parentUuid":"26bccabd-200b-4f06-a61b-dfcce868d898","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01S8n5Ve5ML3HsuKFoPyBK6Q","type":"tool_result","content":"The file /Users/natedamstra/socialaize/FLOATING_V2.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   602â†’   - Set `skipInitialAnimation={true}`\n   603â†’   - Element appears instantly without animation\n   604â†’   - Events still fire correctly\n   605â†’\n   606â†’### Step 3.3: Environment Detection Testing\n   607â†’\n   608â†’**New capability to test:**\n   609â†’\n   610â†’1. **Battery Optimization**"}]},"uuid":"f7e87c30-2d6b-4622-8e6d-acdf5996b58b","timestamp":"2025-10-08T00:37:37.826Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/FLOATING_V2.md","oldString":"### Step 3.2: Environment Detection Testing","newString":"### Step 3.3: Environment Detection Testing","originalFile":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// CRITICAL: Track animation state separately from useAnimation's isPlaying\n// because isPlaying only updates when play() is called, not animateIn/animateOut\nconst isAnimating = ref(false)\n\n// CRITICAL: Separate Web Animations support check from environment throttling\n// canAnimate goes false for low battery/FPS, but we still want to run animations\n// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\nconst isAnimationSupported = computed(() => {\n  // Check if Web Animations API is available (browser support)\n  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n\n// Wrap animateIn to track isAnimating state\nconst wrappedAnimateIn = async () => {\n  if (!animation.animateIn) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Wrap animateOut to track isAnimating state\nconst wrappedAnimateOut = async () => {\n  if (!animation.animateOut) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateOut()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    try {\n      isAnimating.value = true\n      // Reverse the current animation\n      anim.reverse()\n      await anim.finished\n    } finally {\n      isAnimating.value = false\n    }\n  } else {\n    // Fallback: play exit animation if no animation running\n    await wrappedAnimateOut()\n  }\n}\n\n// Export wrapped versions for use in template\nconst animateIn = wrappedAnimateIn\nconst animateOut = wrappedAnimateOut\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue\n- âœ… **Separate browser support check** - Allows environment throttling to work correctly\n\n**Critical Implementation Details:**\n\n1. **`isAnimating` State Tracking**\n   - `useAnimation.isPlaying` only updates when `play()` is called\n   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`\n   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations\n   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`\n\n2. **Browser Support vs Environment Throttling**\n   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS\n   - But we WANT scaled animations to run (30% duration on low battery, etc.)\n   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly\n\n### Step 2.3: How Environment Throttling Works (Post-Fix)\n\n**With the fixes above, here's how environment detection actually works:**\n\n**Scenario 1: Low Battery (<20%)**\n```typescript\n// User opens floating element\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    // isAnimationSupported checks browser capability (always true in modern browsers)\n    if (isAnimationSupported.value) {\n      await animateIn() // Calls animation.animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'low' (due to battery)\n      // - effectiveDuration = baseDuration * 0.3\n      // - Animation runs with 30% of normal duration (FAST but smooth)\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n\n**Scenario 2: Reduced Motion Preference**\n```typescript\n// User has prefers-reduced-motion enabled\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'none' (due to reduced motion)\n      // - Skips animation, applies final state instantly\n      // - Returns immediately\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** No animation, final state applied instantly (accessible)\n\n**Scenario 3: Low FPS (<30fps)**\n```typescript\n// Device is struggling with performance\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'medium' (due to low FPS)\n      // - effectiveDuration = baseDuration * 0.6\n      // - Animation runs with 60% of normal duration\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n\n**Key Insight:**\n- `isAnimationSupported` checks **browser capability** (Web Animations API support)\n- `animation.canAnimate` checks **environment conditions** (battery, FPS, motion preference)\n- `animation.animateIn()` internally handles environment throttling by scaling duration\n- We check `isAnimationSupported` to decide **whether to animate at all**\n- `useAnimation` handles **how to animate** based on environment\n\n### Step 2.4: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.5: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.6: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.7: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Critical Fix Validation (MUST PASS BEFORE PROCEEDING)\n\n**Test Fix #1: `isAnimating` State Tracking**\n\nVerify that slot consumers receive correct `isAnimating` values:\n\n```vue\n<!-- Test in AiConductorGraphicV2.vue -->\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  @animation-start=\"handleFloatingElementStart\"\n  @animation-complete=\"handleFloatingElementComplete\"\n>\n  <template #default=\"{ isAnimating: isFloatingAnimating }\">\n    <!-- CRITICAL: This must be true during enter/exit animations -->\n    <div v-if=\"isFloatingAnimating\">\n      ANIMATING: {{ isFloatingAnimating }}\n    </div>\n\n    <!-- Chat bubble should be HIDDEN during animations -->\n    <ChatBubble\n      v-if=\"showConductorCommand && !isFloatingAnimating\"\n      :messages=\"chatMessages\"\n    />\n  </template>\n</AnimatedFloatingElement>\n```\n\n**Expected Behavior:**\n1. Open conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n2. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Chat bubble SHOWS\n3. Close conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n4. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Component unmounts\n\n**Failure Symptoms:**\n- âŒ Chat bubble shows during enter animation (flickering)\n- âŒ Provider responses visible during exit animation (visual regression)\n- âŒ `isFloatingAnimating` always `false` (broken slot prop)\n\n**Test Fix #2: Environment Throttling Still Works**\n\nVerify that low battery/FPS still runs scaled animations (not instant snaps):\n\n**Test 2.1: Low Battery**\n```typescript\n// DevTools â†’ Sensors â†’ Battery\n// Set: Level 15%, Charging: No\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n// - NOT instant snap to final state\n// - Still smooth visual transition, just faster\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Test 2.2: Reduced Motion**\n```typescript\n// System Settings â†’ Accessibility â†’ Reduce Motion: ON\n// OR DevTools â†’ Rendering â†’ Emulate CSS prefers-reduced-motion: reduce\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation skips entirely\n// - Final state applied instantly\n// - No visual motion\n\n// Failure: Animation still runs (accessibility violation)\n```\n\n**Test 2.3: Low FPS**\n```typescript\n// DevTools â†’ Performance â†’ CPU: 6x slowdown\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n// - Smooth transition, no jank\n// - Performance-adapted\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Critical:** If any of these tests fail, **DO NOT PROCEED** to Phase 4. The wrappers around `animateIn`/`animateOut` are not working correctly.\n\n### Step 3.2: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.2: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.3: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.4: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**\n","structuredPatch":[{"oldStart":603,"oldLines":7,"newStart":603,"newLines":7,"lines":["    - Element appears instantly without animation","    - Events still fire correctly"," ","-### Step 3.2: Environment Detection Testing","+### Step 3.3: Environment Detection Testing"," "," **New capability to test:**"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"f7e87c30-2d6b-4622-8e6d-acdf5996b58b","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0169nyhSjdL7sud882LpwXZ2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BXxSbZYsv7L3BNPpRqYCT6","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/FLOATING_V2.md","old_string":"### Step 3.3: Event Timing Validation","new_string":"### Step 3.4: Event Timing Validation"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":266,"cache_read_input_tokens":142896,"cache_creation":{"ephemeral_5m_input_tokens":266,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard"}},"requestId":"req_011CTtoAo8vbyhsFL94RKLvj","type":"assistant","uuid":"987fbf6d-0ab8-43d5-8793-a0c06ed25c74","timestamp":"2025-10-08T00:37:42.262Z"}
{"parentUuid":"987fbf6d-0ab8-43d5-8793-a0c06ed25c74","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BXxSbZYsv7L3BNPpRqYCT6","type":"tool_result","content":"The file /Users/natedamstra/socialaize/FLOATING_V2.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   626â†’   - Wait 5 minutes inactive\n   627â†’   - Non-critical animations should pause\n   628â†’   - Resume when user returns\n   629â†’\n   630â†’### Step 3.4: Event Timing Validation\n   631â†’\n   632â†’Create a test script to verify event order:\n   633â†’\n   634â†’```typescript"}]},"uuid":"af2dfd92-ae2e-4b8d-8159-4e98a09c20f5","timestamp":"2025-10-08T00:37:42.357Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/FLOATING_V2.md","oldString":"### Step 3.3: Event Timing Validation","newString":"### Step 3.4: Event Timing Validation","originalFile":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// CRITICAL: Track animation state separately from useAnimation's isPlaying\n// because isPlaying only updates when play() is called, not animateIn/animateOut\nconst isAnimating = ref(false)\n\n// CRITICAL: Separate Web Animations support check from environment throttling\n// canAnimate goes false for low battery/FPS, but we still want to run animations\n// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\nconst isAnimationSupported = computed(() => {\n  // Check if Web Animations API is available (browser support)\n  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n\n// Wrap animateIn to track isAnimating state\nconst wrappedAnimateIn = async () => {\n  if (!animation.animateIn) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Wrap animateOut to track isAnimating state\nconst wrappedAnimateOut = async () => {\n  if (!animation.animateOut) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateOut()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    try {\n      isAnimating.value = true\n      // Reverse the current animation\n      anim.reverse()\n      await anim.finished\n    } finally {\n      isAnimating.value = false\n    }\n  } else {\n    // Fallback: play exit animation if no animation running\n    await wrappedAnimateOut()\n  }\n}\n\n// Export wrapped versions for use in template\nconst animateIn = wrappedAnimateIn\nconst animateOut = wrappedAnimateOut\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue\n- âœ… **Separate browser support check** - Allows environment throttling to work correctly\n\n**Critical Implementation Details:**\n\n1. **`isAnimating` State Tracking**\n   - `useAnimation.isPlaying` only updates when `play()` is called\n   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`\n   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations\n   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`\n\n2. **Browser Support vs Environment Throttling**\n   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS\n   - But we WANT scaled animations to run (30% duration on low battery, etc.)\n   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly\n\n### Step 2.3: How Environment Throttling Works (Post-Fix)\n\n**With the fixes above, here's how environment detection actually works:**\n\n**Scenario 1: Low Battery (<20%)**\n```typescript\n// User opens floating element\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    // isAnimationSupported checks browser capability (always true in modern browsers)\n    if (isAnimationSupported.value) {\n      await animateIn() // Calls animation.animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'low' (due to battery)\n      // - effectiveDuration = baseDuration * 0.3\n      // - Animation runs with 30% of normal duration (FAST but smooth)\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n\n**Scenario 2: Reduced Motion Preference**\n```typescript\n// User has prefers-reduced-motion enabled\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'none' (due to reduced motion)\n      // - Skips animation, applies final state instantly\n      // - Returns immediately\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** No animation, final state applied instantly (accessible)\n\n**Scenario 3: Low FPS (<30fps)**\n```typescript\n// Device is struggling with performance\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'medium' (due to low FPS)\n      // - effectiveDuration = baseDuration * 0.6\n      // - Animation runs with 60% of normal duration\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n\n**Key Insight:**\n- `isAnimationSupported` checks **browser capability** (Web Animations API support)\n- `animation.canAnimate` checks **environment conditions** (battery, FPS, motion preference)\n- `animation.animateIn()` internally handles environment throttling by scaling duration\n- We check `isAnimationSupported` to decide **whether to animate at all**\n- `useAnimation` handles **how to animate** based on environment\n\n### Step 2.4: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.5: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.6: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.7: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Critical Fix Validation (MUST PASS BEFORE PROCEEDING)\n\n**Test Fix #1: `isAnimating` State Tracking**\n\nVerify that slot consumers receive correct `isAnimating` values:\n\n```vue\n<!-- Test in AiConductorGraphicV2.vue -->\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  @animation-start=\"handleFloatingElementStart\"\n  @animation-complete=\"handleFloatingElementComplete\"\n>\n  <template #default=\"{ isAnimating: isFloatingAnimating }\">\n    <!-- CRITICAL: This must be true during enter/exit animations -->\n    <div v-if=\"isFloatingAnimating\">\n      ANIMATING: {{ isFloatingAnimating }}\n    </div>\n\n    <!-- Chat bubble should be HIDDEN during animations -->\n    <ChatBubble\n      v-if=\"showConductorCommand && !isFloatingAnimating\"\n      :messages=\"chatMessages\"\n    />\n  </template>\n</AnimatedFloatingElement>\n```\n\n**Expected Behavior:**\n1. Open conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n2. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Chat bubble SHOWS\n3. Close conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n4. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Component unmounts\n\n**Failure Symptoms:**\n- âŒ Chat bubble shows during enter animation (flickering)\n- âŒ Provider responses visible during exit animation (visual regression)\n- âŒ `isFloatingAnimating` always `false` (broken slot prop)\n\n**Test Fix #2: Environment Throttling Still Works**\n\nVerify that low battery/FPS still runs scaled animations (not instant snaps):\n\n**Test 2.1: Low Battery**\n```typescript\n// DevTools â†’ Sensors â†’ Battery\n// Set: Level 15%, Charging: No\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n// - NOT instant snap to final state\n// - Still smooth visual transition, just faster\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Test 2.2: Reduced Motion**\n```typescript\n// System Settings â†’ Accessibility â†’ Reduce Motion: ON\n// OR DevTools â†’ Rendering â†’ Emulate CSS prefers-reduced-motion: reduce\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation skips entirely\n// - Final state applied instantly\n// - No visual motion\n\n// Failure: Animation still runs (accessibility violation)\n```\n\n**Test 2.3: Low FPS**\n```typescript\n// DevTools â†’ Performance â†’ CPU: 6x slowdown\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n// - Smooth transition, no jank\n// - Performance-adapted\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Critical:** If any of these tests fail, **DO NOT PROCEED** to Phase 4. The wrappers around `animateIn`/`animateOut` are not working correctly.\n\n### Step 3.2: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.3: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.3: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.4: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**\n","structuredPatch":[{"oldStart":627,"oldLines":7,"newStart":627,"newLines":7,"lines":["    - Non-critical animations should pause","    - Resume when user returns"," ","-### Step 3.3: Event Timing Validation","+### Step 3.4: Event Timing Validation"," "," Create a test script to verify event order:"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"af2dfd92-ae2e-4b8d-8159-4e98a09c20f5","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01WgNp2giGZ2ZHkUbyNhrtxB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ah1U7tdzfh8oZSvGryCtGH","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/FLOATING_V2.md","old_string":"### Step 3.4: Props Compatibility Check","new_string":"### Step 3.5: Props Compatibility Check"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":268,"cache_read_input_tokens":143162,"cache_creation":{"ephemeral_5m_input_tokens":268,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard"}},"requestId":"req_011CTtoB7QGvYDuTE6pGaknY","type":"assistant","uuid":"da07d739-1401-48e1-962d-929046212456","timestamp":"2025-10-08T00:37:46.176Z"}
{"parentUuid":"da07d739-1401-48e1-962d-929046212456","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ah1U7tdzfh8oZSvGryCtGH","type":"tool_result","content":"The file /Users/natedamstra/socialaize/FLOATING_V2.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   663â†’// 2. animationComplete: exit\n   664â†’// 3. visibilityChange: false\n   665â†’```\n   666â†’\n   667â†’### Step 3.5: Props Compatibility Check\n   668â†’\n   669â†’Verify all props still work:\n   670â†’\n   671â†’```vue"}]},"uuid":"ef0f28f9-eb0d-4faa-b4e7-dae593c18364","timestamp":"2025-10-08T00:37:46.269Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/FLOATING_V2.md","oldString":"### Step 3.4: Props Compatibility Check","newString":"### Step 3.5: Props Compatibility Check","originalFile":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// CRITICAL: Track animation state separately from useAnimation's isPlaying\n// because isPlaying only updates when play() is called, not animateIn/animateOut\nconst isAnimating = ref(false)\n\n// CRITICAL: Separate Web Animations support check from environment throttling\n// canAnimate goes false for low battery/FPS, but we still want to run animations\n// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\nconst isAnimationSupported = computed(() => {\n  // Check if Web Animations API is available (browser support)\n  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n\n// Wrap animateIn to track isAnimating state\nconst wrappedAnimateIn = async () => {\n  if (!animation.animateIn) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Wrap animateOut to track isAnimating state\nconst wrappedAnimateOut = async () => {\n  if (!animation.animateOut) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateOut()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    try {\n      isAnimating.value = true\n      // Reverse the current animation\n      anim.reverse()\n      await anim.finished\n    } finally {\n      isAnimating.value = false\n    }\n  } else {\n    // Fallback: play exit animation if no animation running\n    await wrappedAnimateOut()\n  }\n}\n\n// Export wrapped versions for use in template\nconst animateIn = wrappedAnimateIn\nconst animateOut = wrappedAnimateOut\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue\n- âœ… **Separate browser support check** - Allows environment throttling to work correctly\n\n**Critical Implementation Details:**\n\n1. **`isAnimating` State Tracking**\n   - `useAnimation.isPlaying` only updates when `play()` is called\n   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`\n   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations\n   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`\n\n2. **Browser Support vs Environment Throttling**\n   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS\n   - But we WANT scaled animations to run (30% duration on low battery, etc.)\n   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly\n\n### Step 2.3: How Environment Throttling Works (Post-Fix)\n\n**With the fixes above, here's how environment detection actually works:**\n\n**Scenario 1: Low Battery (<20%)**\n```typescript\n// User opens floating element\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    // isAnimationSupported checks browser capability (always true in modern browsers)\n    if (isAnimationSupported.value) {\n      await animateIn() // Calls animation.animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'low' (due to battery)\n      // - effectiveDuration = baseDuration * 0.3\n      // - Animation runs with 30% of normal duration (FAST but smooth)\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n\n**Scenario 2: Reduced Motion Preference**\n```typescript\n// User has prefers-reduced-motion enabled\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'none' (due to reduced motion)\n      // - Skips animation, applies final state instantly\n      // - Returns immediately\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** No animation, final state applied instantly (accessible)\n\n**Scenario 3: Low FPS (<30fps)**\n```typescript\n// Device is struggling with performance\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'medium' (due to low FPS)\n      // - effectiveDuration = baseDuration * 0.6\n      // - Animation runs with 60% of normal duration\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n\n**Key Insight:**\n- `isAnimationSupported` checks **browser capability** (Web Animations API support)\n- `animation.canAnimate` checks **environment conditions** (battery, FPS, motion preference)\n- `animation.animateIn()` internally handles environment throttling by scaling duration\n- We check `isAnimationSupported` to decide **whether to animate at all**\n- `useAnimation` handles **how to animate** based on environment\n\n### Step 2.4: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.5: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.6: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.7: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Critical Fix Validation (MUST PASS BEFORE PROCEEDING)\n\n**Test Fix #1: `isAnimating` State Tracking**\n\nVerify that slot consumers receive correct `isAnimating` values:\n\n```vue\n<!-- Test in AiConductorGraphicV2.vue -->\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  @animation-start=\"handleFloatingElementStart\"\n  @animation-complete=\"handleFloatingElementComplete\"\n>\n  <template #default=\"{ isAnimating: isFloatingAnimating }\">\n    <!-- CRITICAL: This must be true during enter/exit animations -->\n    <div v-if=\"isFloatingAnimating\">\n      ANIMATING: {{ isFloatingAnimating }}\n    </div>\n\n    <!-- Chat bubble should be HIDDEN during animations -->\n    <ChatBubble\n      v-if=\"showConductorCommand && !isFloatingAnimating\"\n      :messages=\"chatMessages\"\n    />\n  </template>\n</AnimatedFloatingElement>\n```\n\n**Expected Behavior:**\n1. Open conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n2. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Chat bubble SHOWS\n3. Close conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n4. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Component unmounts\n\n**Failure Symptoms:**\n- âŒ Chat bubble shows during enter animation (flickering)\n- âŒ Provider responses visible during exit animation (visual regression)\n- âŒ `isFloatingAnimating` always `false` (broken slot prop)\n\n**Test Fix #2: Environment Throttling Still Works**\n\nVerify that low battery/FPS still runs scaled animations (not instant snaps):\n\n**Test 2.1: Low Battery**\n```typescript\n// DevTools â†’ Sensors â†’ Battery\n// Set: Level 15%, Charging: No\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n// - NOT instant snap to final state\n// - Still smooth visual transition, just faster\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Test 2.2: Reduced Motion**\n```typescript\n// System Settings â†’ Accessibility â†’ Reduce Motion: ON\n// OR DevTools â†’ Rendering â†’ Emulate CSS prefers-reduced-motion: reduce\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation skips entirely\n// - Final state applied instantly\n// - No visual motion\n\n// Failure: Animation still runs (accessibility violation)\n```\n\n**Test 2.3: Low FPS**\n```typescript\n// DevTools â†’ Performance â†’ CPU: 6x slowdown\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n// - Smooth transition, no jank\n// - Performance-adapted\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Critical:** If any of these tests fail, **DO NOT PROCEED** to Phase 4. The wrappers around `animateIn`/`animateOut` are not working correctly.\n\n### Step 3.2: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.3: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.4: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.4: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**\n","structuredPatch":[{"oldStart":664,"oldLines":7,"newStart":664,"newLines":7,"lines":[" // 3. visibilityChange: false"," ```"," ","-### Step 3.4: Props Compatibility Check","+### Step 3.5: Props Compatibility Check"," "," Verify all props still work:"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"ef0f28f9-eb0d-4faa-b4e7-dae593c18364","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_016sHHYbMijadguy9cepMd5j","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now let me add a summary section at the top of the document explaining the critical fixes:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":353,"cache_read_input_tokens":143430,"cache_creation":{"ephemeral_5m_input_tokens":353,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTtoBPpVmWMkiJBX8vzUA","type":"assistant","uuid":"131dbd21-39f8-44fc-9c6c-4433e2dae0dd","timestamp":"2025-10-08T00:37:50.549Z"}
{"parentUuid":"131dbd21-39f8-44fc-9c6c-4433e2dae0dd","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_016sHHYbMijadguy9cepMd5j","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Mz1Ba8U3iagXvorcMuXiNt","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/FLOATING_V2.md","old_string":"---\n\n## Migration Strategy Overview","new_string":"---\n\n## Critical Fixes Applied (vs. FLOATING_REFACTOR_BLOCKERS.md)\n\n### Fix #1: `isAnimating` State Tracking\n**Problem:** `useAnimation.isPlaying` only updates when `play()` is called, not when `animateIn()`/`animateOut()` are called directly. This breaks slot consumers like `AiConductorGraphicV2.vue` that rely on `isAnimating` to hide chat bubbles during animations.\n\n**Solution:** Manually track `isAnimating` state by wrapping `animateIn`/`animateOut`:\n```typescript\nconst isAnimating = ref(false)\n\nconst wrappedAnimateIn = async () => {\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n```\n\n**Impact:** Slot consumers receive accurate `isAnimating` values, preventing chat bubbles from flickering during enter/exit animations.\n\n### Fix #2: Browser Support vs Environment Throttling\n**Problem:** Treating `animation.canAnimate` as browser support check short-circuits environment throttling. `canAnimate` goes `false` for low battery/FPS/reduced motion, which would make animations snap instantly instead of running with scaled duration.\n\n**Solution:** Separate browser capability check from environment state:\n```typescript\nconst isAnimationSupported = computed(() => {\n  // Check Web Animations API browser support, NOT environment conditions\n  return animation.animate?.value !== undefined ||\n         typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n```\n\n**Impact:** Low battery/FPS still runs smooth animations (just faster), instead of instant snaps. Reduced motion still skips animations correctly.\n\n---\n\n## Migration Strategy Overview"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":353,"cache_read_input_tokens":143430,"cache_creation":{"ephemeral_5m_input_tokens":353,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTtoBPpVmWMkiJBX8vzUA","type":"assistant","uuid":"b55c265d-91e4-4cfa-afdc-71a916803539","timestamp":"2025-10-08T00:38:01.373Z"}
{"parentUuid":"b55c265d-91e4-4cfa-afdc-71a916803539","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Mz1Ba8U3iagXvorcMuXiNt","type":"tool_result","content":"The file /Users/natedamstra/socialaize/FLOATING_V2.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     5â†’**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n     6â†’\n     7â†’**Date:** 2025-01-07\n     8â†’\n     9â†’---\n    10â†’\n    11â†’## Critical Fixes Applied (vs. FLOATING_REFACTOR_BLOCKERS.md)\n    12â†’\n    13â†’### Fix #1: `isAnimating` State Tracking\n    14â†’**Problem:** `useAnimation.isPlaying` only updates when `play()` is called, not when `animateIn()`/`animateOut()` are called directly. This breaks slot consumers like `AiConductorGraphicV2.vue` that rely on `isAnimating` to hide chat bubbles during animations.\n    15â†’\n    16â†’**Solution:** Manually track `isAnimating` state by wrapping `animateIn`/`animateOut`:\n    17â†’```typescript\n    18â†’const isAnimating = ref(false)\n    19â†’\n    20â†’const wrappedAnimateIn = async () => {\n    21â†’  try {\n    22â†’    isAnimating.value = true\n    23â†’    await animation.animateIn()\n    24â†’  } finally {\n    25â†’    isAnimating.value = false\n    26â†’  }\n    27â†’}\n    28â†’```\n    29â†’\n    30â†’**Impact:** Slot consumers receive accurate `isAnimating` values, preventing chat bubbles from flickering during enter/exit animations.\n    31â†’\n    32â†’### Fix #2: Browser Support vs Environment Throttling\n    33â†’**Problem:** Treating `animation.canAnimate` as browser support check short-circuits environment throttling. `canAnimate` goes `false` for low battery/FPS/reduced motion, which would make animations snap instantly instead of running with scaled duration.\n    34â†’\n    35â†’**Solution:** Separate browser capability check from environment state:\n    36â†’```typescript\n    37â†’const isAnimationSupported = computed(() => {\n    38â†’  // Check Web Animations API browser support, NOT environment conditions\n    39â†’  return animation.animate?.value !== undefined ||\n    40â†’         typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n    41â†’})\n    42â†’```\n    43â†’\n    44â†’**Impact:** Low battery/FPS still runs smooth animations (just faster), instead of instant snaps. Reduced motion still skips animations correctly.\n    45â†’\n    46â†’---\n    47â†’\n    48â†’## Migration Strategy Overview\n    49â†’\n    50â†’### Core Principle\n    51â†’**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n    52â†’"}]},"uuid":"137acdab-600f-4201-9412-5d75c2145643","timestamp":"2025-10-08T00:38:01.459Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/FLOATING_V2.md","oldString":"---\n\n## Migration Strategy Overview","newString":"---\n\n## Critical Fixes Applied (vs. FLOATING_REFACTOR_BLOCKERS.md)\n\n### Fix #1: `isAnimating` State Tracking\n**Problem:** `useAnimation.isPlaying` only updates when `play()` is called, not when `animateIn()`/`animateOut()` are called directly. This breaks slot consumers like `AiConductorGraphicV2.vue` that rely on `isAnimating` to hide chat bubbles during animations.\n\n**Solution:** Manually track `isAnimating` state by wrapping `animateIn`/`animateOut`:\n```typescript\nconst isAnimating = ref(false)\n\nconst wrappedAnimateIn = async () => {\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n```\n\n**Impact:** Slot consumers receive accurate `isAnimating` values, preventing chat bubbles from flickering during enter/exit animations.\n\n### Fix #2: Browser Support vs Environment Throttling\n**Problem:** Treating `animation.canAnimate` as browser support check short-circuits environment throttling. `canAnimate` goes `false` for low battery/FPS/reduced motion, which would make animations snap instantly instead of running with scaled duration.\n\n**Solution:** Separate browser capability check from environment state:\n```typescript\nconst isAnimationSupported = computed(() => {\n  // Check Web Animations API browser support, NOT environment conditions\n  return animation.animate?.value !== undefined ||\n         typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n```\n\n**Impact:** Low battery/FPS still runs smooth animations (just faster), instead of instant snaps. Reduced motion still skips animations correctly.\n\n---\n\n## Migration Strategy Overview","originalFile":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// CRITICAL: Track animation state separately from useAnimation's isPlaying\n// because isPlaying only updates when play() is called, not animateIn/animateOut\nconst isAnimating = ref(false)\n\n// CRITICAL: Separate Web Animations support check from environment throttling\n// canAnimate goes false for low battery/FPS, but we still want to run animations\n// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\nconst isAnimationSupported = computed(() => {\n  // Check if Web Animations API is available (browser support)\n  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n\n// Wrap animateIn to track isAnimating state\nconst wrappedAnimateIn = async () => {\n  if (!animation.animateIn) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Wrap animateOut to track isAnimating state\nconst wrappedAnimateOut = async () => {\n  if (!animation.animateOut) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateOut()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    try {\n      isAnimating.value = true\n      // Reverse the current animation\n      anim.reverse()\n      await anim.finished\n    } finally {\n      isAnimating.value = false\n    }\n  } else {\n    // Fallback: play exit animation if no animation running\n    await wrappedAnimateOut()\n  }\n}\n\n// Export wrapped versions for use in template\nconst animateIn = wrappedAnimateIn\nconst animateOut = wrappedAnimateOut\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue\n- âœ… **Separate browser support check** - Allows environment throttling to work correctly\n\n**Critical Implementation Details:**\n\n1. **`isAnimating` State Tracking**\n   - `useAnimation.isPlaying` only updates when `play()` is called\n   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`\n   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations\n   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`\n\n2. **Browser Support vs Environment Throttling**\n   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS\n   - But we WANT scaled animations to run (30% duration on low battery, etc.)\n   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly\n\n### Step 2.3: How Environment Throttling Works (Post-Fix)\n\n**With the fixes above, here's how environment detection actually works:**\n\n**Scenario 1: Low Battery (<20%)**\n```typescript\n// User opens floating element\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    // isAnimationSupported checks browser capability (always true in modern browsers)\n    if (isAnimationSupported.value) {\n      await animateIn() // Calls animation.animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'low' (due to battery)\n      // - effectiveDuration = baseDuration * 0.3\n      // - Animation runs with 30% of normal duration (FAST but smooth)\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n\n**Scenario 2: Reduced Motion Preference**\n```typescript\n// User has prefers-reduced-motion enabled\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'none' (due to reduced motion)\n      // - Skips animation, applies final state instantly\n      // - Returns immediately\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** No animation, final state applied instantly (accessible)\n\n**Scenario 3: Low FPS (<30fps)**\n```typescript\n// Device is struggling with performance\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'medium' (due to low FPS)\n      // - effectiveDuration = baseDuration * 0.6\n      // - Animation runs with 60% of normal duration\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n\n**Key Insight:**\n- `isAnimationSupported` checks **browser capability** (Web Animations API support)\n- `animation.canAnimate` checks **environment conditions** (battery, FPS, motion preference)\n- `animation.animateIn()` internally handles environment throttling by scaling duration\n- We check `isAnimationSupported` to decide **whether to animate at all**\n- `useAnimation` handles **how to animate** based on environment\n\n### Step 2.4: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.5: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.6: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.7: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Critical Fix Validation (MUST PASS BEFORE PROCEEDING)\n\n**Test Fix #1: `isAnimating` State Tracking**\n\nVerify that slot consumers receive correct `isAnimating` values:\n\n```vue\n<!-- Test in AiConductorGraphicV2.vue -->\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  @animation-start=\"handleFloatingElementStart\"\n  @animation-complete=\"handleFloatingElementComplete\"\n>\n  <template #default=\"{ isAnimating: isFloatingAnimating }\">\n    <!-- CRITICAL: This must be true during enter/exit animations -->\n    <div v-if=\"isFloatingAnimating\">\n      ANIMATING: {{ isFloatingAnimating }}\n    </div>\n\n    <!-- Chat bubble should be HIDDEN during animations -->\n    <ChatBubble\n      v-if=\"showConductorCommand && !isFloatingAnimating\"\n      :messages=\"chatMessages\"\n    />\n  </template>\n</AnimatedFloatingElement>\n```\n\n**Expected Behavior:**\n1. Open conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n2. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Chat bubble SHOWS\n3. Close conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n4. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Component unmounts\n\n**Failure Symptoms:**\n- âŒ Chat bubble shows during enter animation (flickering)\n- âŒ Provider responses visible during exit animation (visual regression)\n- âŒ `isFloatingAnimating` always `false` (broken slot prop)\n\n**Test Fix #2: Environment Throttling Still Works**\n\nVerify that low battery/FPS still runs scaled animations (not instant snaps):\n\n**Test 2.1: Low Battery**\n```typescript\n// DevTools â†’ Sensors â†’ Battery\n// Set: Level 15%, Charging: No\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n// - NOT instant snap to final state\n// - Still smooth visual transition, just faster\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Test 2.2: Reduced Motion**\n```typescript\n// System Settings â†’ Accessibility â†’ Reduce Motion: ON\n// OR DevTools â†’ Rendering â†’ Emulate CSS prefers-reduced-motion: reduce\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation skips entirely\n// - Final state applied instantly\n// - No visual motion\n\n// Failure: Animation still runs (accessibility violation)\n```\n\n**Test 2.3: Low FPS**\n```typescript\n// DevTools â†’ Performance â†’ CPU: 6x slowdown\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n// - Smooth transition, no jank\n// - Performance-adapted\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Critical:** If any of these tests fail, **DO NOT PROCEED** to Phase 4. The wrappers around `animateIn`/`animateOut` are not working correctly.\n\n### Step 3.2: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.3: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.4: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.5: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**\n","structuredPatch":[{"oldStart":8,"oldLines":6,"newStart":8,"newLines":43,"lines":[" "," ---"," ","+## Critical Fixes Applied (vs. FLOATING_REFACTOR_BLOCKERS.md)","+","+### Fix #1: `isAnimating` State Tracking","+**Problem:** `useAnimation.isPlaying` only updates when `play()` is called, not when `animateIn()`/`animateOut()` are called directly. This breaks slot consumers like `AiConductorGraphicV2.vue` that rely on `isAnimating` to hide chat bubbles during animations.","+","+**Solution:** Manually track `isAnimating` state by wrapping `animateIn`/`animateOut`:","+```typescript","+const isAnimating = ref(false)","+","+const wrappedAnimateIn = async () => {","+  try {","+    isAnimating.value = true","+    await animation.animateIn()","+  } finally {","+    isAnimating.value = false","+  }","+}","+```","+","+**Impact:** Slot consumers receive accurate `isAnimating` values, preventing chat bubbles from flickering during enter/exit animations.","+","+### Fix #2: Browser Support vs Environment Throttling","+**Problem:** Treating `animation.canAnimate` as browser support check short-circuits environment throttling. `canAnimate` goes `false` for low battery/FPS/reduced motion, which would make animations snap instantly instead of running with scaled duration.","+","+**Solution:** Separate browser capability check from environment state:","+```typescript","+const isAnimationSupported = computed(() => {","+  // Check Web Animations API browser support, NOT environment conditions","+  return animation.animate?.value !== undefined ||","+         typeof window !== 'undefined' && 'animate' in HTMLElement.prototype","+})","+```","+","+**Impact:** Low battery/FPS still runs smooth animations (just faster), instead of instant snaps. Reduced motion still skips animations correctly.","+","+---","+"," ## Migration Strategy Overview"," "," ### Core Principle"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"137acdab-600f-4201-9412-5d75c2145643","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01LJaNNZdjyRP3iypsZuha9F","type":"message","role":"assistant","content":[{"type":"text","text":"Excellent! Now let me update the success criteria checklist to include these critical fixes:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":1281,"cache_read_input_tokens":143783,"cache_creation":{"ephemeral_5m_input_tokens":1281,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard"}},"requestId":"req_011CTtoCYbsDNJ391ARLd57U","type":"assistant","uuid":"f9d7bf21-932f-445d-a90e-dc62b81c1f55","timestamp":"2025-10-08T00:38:05.543Z"}
{"parentUuid":"f9d7bf21-932f-445d-a90e-dc62b81c1f55","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01LJaNNZdjyRP3iypsZuha9F","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Gda73KHJ5LBTDGPqhp4Lsa","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/FLOATING_V2.md","old_string":"## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions","new_string":"## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n### Phase 1: Preparation\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] Presets export correctly from `useAnimation.ts`\n\n### Phase 2: Migration\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `isAnimating` wrapper functions implemented correctly\n- [ ] `isAnimationSupported` checks browser capability (not environment)\n- [ ] `reverse()` function uses Web Animations API\n\n### Phase 3: Critical Fix Validation\n- [ ] **Fix #1:** `isAnimating` slot prop updates correctly during animations\n- [ ] **Fix #1:** Chat bubbles HIDDEN during enter/exit in `AiConductorGraphicV2.vue`\n- [ ] **Fix #2:** Low battery runs scaled animations (NOT instant snap)\n- [ ] **Fix #2:** Reduced motion skips animations correctly\n- [ ] **Fix #2:** Low FPS runs scaled animations (NOT instant snap)\n\n### Phase 3: Visual Regression Testing\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Skip initial animation works instantly\n- [ ] All props still work correctly\n\n### Phase 3: Environment Detection Testing\n- [ ] Battery optimization works (duration scales to 30% on low battery)\n- [ ] Reduced motion is respected (animations skip entirely)\n- [ ] FPS throttling works (duration scales to 60% on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] Page leave detection works (pauses when tab hidden)\n\n### Phase 4: Cleanup\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors anywhere\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions confirmed"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":1281,"cache_read_input_tokens":143783,"cache_creation":{"ephemeral_5m_input_tokens":1281,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard"}},"requestId":"req_011CTtoCYbsDNJ391ARLd57U","type":"assistant","uuid":"04a1983c-be33-4926-820f-6fd57ae2c047","timestamp":"2025-10-08T00:38:18.865Z"}
{"parentUuid":"04a1983c-be33-4926-820f-6fd57ae2c047","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Gda73KHJ5LBTDGPqhp4Lsa","type":"tool_result","content":"The file /Users/natedamstra/socialaize/FLOATING_V2.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   821â†’   - Other theater components\n   822â†’\n   823â†’---\n   824â†’\n   825â†’## Success Criteria Checklist\n   826â†’\n   827â†’Before marking this migration complete:\n   828â†’\n   829â†’### Phase 1: Preparation\n   830â†’- [ ] `animationPresets` moved to `useAnimation.ts`\n   831â†’- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n   832â†’- [ ] Presets export correctly from `useAnimation.ts`\n   833â†’\n   834â†’### Phase 2: Migration\n   835â†’- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n   836â†’- [ ] `isAnimating` wrapper functions implemented correctly\n   837â†’- [ ] `isAnimationSupported` checks browser capability (not environment)\n   838â†’- [ ] `reverse()` function uses Web Animations API\n   839â†’\n   840â†’### Phase 3: Critical Fix Validation\n   841â†’- [ ] **Fix #1:** `isAnimating` slot prop updates correctly during animations\n   842â†’- [ ] **Fix #1:** Chat bubbles HIDDEN during enter/exit in `AiConductorGraphicV2.vue`\n   843â†’- [ ] **Fix #2:** Low battery runs scaled animations (NOT instant snap)\n   844â†’- [ ] **Fix #2:** Reduced motion skips animations correctly\n   845â†’- [ ] **Fix #2:** Low FPS runs scaled animations (NOT instant snap)\n   846â†’\n   847â†’### Phase 3: Visual Regression Testing\n   848â†’- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n   849â†’- [ ] Click-outside close uses `reverse()` correctly\n   850â†’- [ ] All events fire in correct order\n   851â†’- [ ] Skip initial animation works instantly\n   852â†’- [ ] All props still work correctly\n   853â†’\n   854â†’### Phase 3: Environment Detection Testing\n   855â†’- [ ] Battery optimization works (duration scales to 30% on low battery)\n   856â†’- [ ] Reduced motion is respected (animations skip entirely)\n   857â†’- [ ] FPS throttling works (duration scales to 60% on low FPS)\n   858â†’- [ ] Idle detection works (pauses after 5min inactivity)\n   859â†’- [ ] Page leave detection works (pauses when tab hidden)\n   860â†’\n   861â†’### Phase 4: Cleanup\n   862â†’- [ ] `useAnimateElement.ts` deleted\n   863â†’- [ ] No import errors anywhere\n   864â†’- [ ] Type checking passes (`npm run typecheck`)\n   865â†’- [ ] Build succeeds (`npm run build`)\n   866â†’- [ ] Zero visual regressions confirmed\n   867â†’\n   868â†’---\n   869â†’\n   870â†’## Rollback Plan"}]},"uuid":"f677e4f8-7b38-476f-84ca-df655574b33f","timestamp":"2025-10-08T00:38:18.953Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/FLOATING_V2.md","oldString":"## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions","newString":"## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n### Phase 1: Preparation\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] Presets export correctly from `useAnimation.ts`\n\n### Phase 2: Migration\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `isAnimating` wrapper functions implemented correctly\n- [ ] `isAnimationSupported` checks browser capability (not environment)\n- [ ] `reverse()` function uses Web Animations API\n\n### Phase 3: Critical Fix Validation\n- [ ] **Fix #1:** `isAnimating` slot prop updates correctly during animations\n- [ ] **Fix #1:** Chat bubbles HIDDEN during enter/exit in `AiConductorGraphicV2.vue`\n- [ ] **Fix #2:** Low battery runs scaled animations (NOT instant snap)\n- [ ] **Fix #2:** Reduced motion skips animations correctly\n- [ ] **Fix #2:** Low FPS runs scaled animations (NOT instant snap)\n\n### Phase 3: Visual Regression Testing\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Skip initial animation works instantly\n- [ ] All props still work correctly\n\n### Phase 3: Environment Detection Testing\n- [ ] Battery optimization works (duration scales to 30% on low battery)\n- [ ] Reduced motion is respected (animations skip entirely)\n- [ ] FPS throttling works (duration scales to 60% on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] Page leave detection works (pauses when tab hidden)\n\n### Phase 4: Cleanup\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors anywhere\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions confirmed","originalFile":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Critical Fixes Applied (vs. FLOATING_REFACTOR_BLOCKERS.md)\n\n### Fix #1: `isAnimating` State Tracking\n**Problem:** `useAnimation.isPlaying` only updates when `play()` is called, not when `animateIn()`/`animateOut()` are called directly. This breaks slot consumers like `AiConductorGraphicV2.vue` that rely on `isAnimating` to hide chat bubbles during animations.\n\n**Solution:** Manually track `isAnimating` state by wrapping `animateIn`/`animateOut`:\n```typescript\nconst isAnimating = ref(false)\n\nconst wrappedAnimateIn = async () => {\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n```\n\n**Impact:** Slot consumers receive accurate `isAnimating` values, preventing chat bubbles from flickering during enter/exit animations.\n\n### Fix #2: Browser Support vs Environment Throttling\n**Problem:** Treating `animation.canAnimate` as browser support check short-circuits environment throttling. `canAnimate` goes `false` for low battery/FPS/reduced motion, which would make animations snap instantly instead of running with scaled duration.\n\n**Solution:** Separate browser capability check from environment state:\n```typescript\nconst isAnimationSupported = computed(() => {\n  // Check Web Animations API browser support, NOT environment conditions\n  return animation.animate?.value !== undefined ||\n         typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n```\n\n**Impact:** Low battery/FPS still runs smooth animations (just faster), instead of instant snaps. Reduced motion still skips animations correctly.\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// CRITICAL: Track animation state separately from useAnimation's isPlaying\n// because isPlaying only updates when play() is called, not animateIn/animateOut\nconst isAnimating = ref(false)\n\n// CRITICAL: Separate Web Animations support check from environment throttling\n// canAnimate goes false for low battery/FPS, but we still want to run animations\n// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\nconst isAnimationSupported = computed(() => {\n  // Check if Web Animations API is available (browser support)\n  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n\n// Wrap animateIn to track isAnimating state\nconst wrappedAnimateIn = async () => {\n  if (!animation.animateIn) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Wrap animateOut to track isAnimating state\nconst wrappedAnimateOut = async () => {\n  if (!animation.animateOut) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateOut()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    try {\n      isAnimating.value = true\n      // Reverse the current animation\n      anim.reverse()\n      await anim.finished\n    } finally {\n      isAnimating.value = false\n    }\n  } else {\n    // Fallback: play exit animation if no animation running\n    await wrappedAnimateOut()\n  }\n}\n\n// Export wrapped versions for use in template\nconst animateIn = wrappedAnimateIn\nconst animateOut = wrappedAnimateOut\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue\n- âœ… **Separate browser support check** - Allows environment throttling to work correctly\n\n**Critical Implementation Details:**\n\n1. **`isAnimating` State Tracking**\n   - `useAnimation.isPlaying` only updates when `play()` is called\n   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`\n   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations\n   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`\n\n2. **Browser Support vs Environment Throttling**\n   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS\n   - But we WANT scaled animations to run (30% duration on low battery, etc.)\n   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly\n\n### Step 2.3: How Environment Throttling Works (Post-Fix)\n\n**With the fixes above, here's how environment detection actually works:**\n\n**Scenario 1: Low Battery (<20%)**\n```typescript\n// User opens floating element\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    // isAnimationSupported checks browser capability (always true in modern browsers)\n    if (isAnimationSupported.value) {\n      await animateIn() // Calls animation.animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'low' (due to battery)\n      // - effectiveDuration = baseDuration * 0.3\n      // - Animation runs with 30% of normal duration (FAST but smooth)\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n\n**Scenario 2: Reduced Motion Preference**\n```typescript\n// User has prefers-reduced-motion enabled\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'none' (due to reduced motion)\n      // - Skips animation, applies final state instantly\n      // - Returns immediately\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** No animation, final state applied instantly (accessible)\n\n**Scenario 3: Low FPS (<30fps)**\n```typescript\n// Device is struggling with performance\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'medium' (due to low FPS)\n      // - effectiveDuration = baseDuration * 0.6\n      // - Animation runs with 60% of normal duration\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n\n**Key Insight:**\n- `isAnimationSupported` checks **browser capability** (Web Animations API support)\n- `animation.canAnimate` checks **environment conditions** (battery, FPS, motion preference)\n- `animation.animateIn()` internally handles environment throttling by scaling duration\n- We check `isAnimationSupported` to decide **whether to animate at all**\n- `useAnimation` handles **how to animate** based on environment\n\n### Step 2.4: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.5: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.6: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.7: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Critical Fix Validation (MUST PASS BEFORE PROCEEDING)\n\n**Test Fix #1: `isAnimating` State Tracking**\n\nVerify that slot consumers receive correct `isAnimating` values:\n\n```vue\n<!-- Test in AiConductorGraphicV2.vue -->\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  @animation-start=\"handleFloatingElementStart\"\n  @animation-complete=\"handleFloatingElementComplete\"\n>\n  <template #default=\"{ isAnimating: isFloatingAnimating }\">\n    <!-- CRITICAL: This must be true during enter/exit animations -->\n    <div v-if=\"isFloatingAnimating\">\n      ANIMATING: {{ isFloatingAnimating }}\n    </div>\n\n    <!-- Chat bubble should be HIDDEN during animations -->\n    <ChatBubble\n      v-if=\"showConductorCommand && !isFloatingAnimating\"\n      :messages=\"chatMessages\"\n    />\n  </template>\n</AnimatedFloatingElement>\n```\n\n**Expected Behavior:**\n1. Open conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n2. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Chat bubble SHOWS\n3. Close conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n4. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Component unmounts\n\n**Failure Symptoms:**\n- âŒ Chat bubble shows during enter animation (flickering)\n- âŒ Provider responses visible during exit animation (visual regression)\n- âŒ `isFloatingAnimating` always `false` (broken slot prop)\n\n**Test Fix #2: Environment Throttling Still Works**\n\nVerify that low battery/FPS still runs scaled animations (not instant snaps):\n\n**Test 2.1: Low Battery**\n```typescript\n// DevTools â†’ Sensors â†’ Battery\n// Set: Level 15%, Charging: No\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n// - NOT instant snap to final state\n// - Still smooth visual transition, just faster\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Test 2.2: Reduced Motion**\n```typescript\n// System Settings â†’ Accessibility â†’ Reduce Motion: ON\n// OR DevTools â†’ Rendering â†’ Emulate CSS prefers-reduced-motion: reduce\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation skips entirely\n// - Final state applied instantly\n// - No visual motion\n\n// Failure: Animation still runs (accessibility violation)\n```\n\n**Test 2.3: Low FPS**\n```typescript\n// DevTools â†’ Performance â†’ CPU: 6x slowdown\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n// - Smooth transition, no jank\n// - Performance-adapted\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Critical:** If any of these tests fail, **DO NOT PROCEED** to Phase 4. The wrappers around `animateIn`/`animateOut` are not working correctly.\n\n### Step 3.2: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.3: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.4: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.5: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Battery optimization works (duration scales on low battery)\n- [ ] Reduced motion is respected (animations skip)\n- [ ] FPS throttling works (duration scales on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**\n","structuredPatch":[{"oldStart":826,"oldLines":21,"newStart":826,"newLines":44,"lines":[" "," Before marking this migration complete:"," ","+### Phase 1: Preparation"," - [ ] `animationPresets` moved to `useAnimation.ts`"," - [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)","+- [ ] Presets export correctly from `useAnimation.ts`","+","+### Phase 2: Migration"," - [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively","+- [ ] `isAnimating` wrapper functions implemented correctly","+- [ ] `isAnimationSupported` checks browser capability (not environment)","+- [ ] `reverse()` function uses Web Animations API","+","+### Phase 3: Critical Fix Validation","+- [ ] **Fix #1:** `isAnimating` slot prop updates correctly during animations","+- [ ] **Fix #1:** Chat bubbles HIDDEN during enter/exit in `AiConductorGraphicV2.vue`","+- [ ] **Fix #2:** Low battery runs scaled animations (NOT instant snap)","+- [ ] **Fix #2:** Reduced motion skips animations correctly","+- [ ] **Fix #2:** Low FPS runs scaled animations (NOT instant snap)","+","+### Phase 3: Visual Regression Testing"," - [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)"," - [ ] Click-outside close uses `reverse()` correctly"," - [ ] All events fire in correct order","-- [ ] Battery optimization works (duration scales on low battery)","-- [ ] Reduced motion is respected (animations skip)","-- [ ] FPS throttling works (duration scales on low FPS)","+- [ ] Skip initial animation works instantly","+- [ ] All props still work correctly","+","+### Phase 3: Environment Detection Testing","+- [ ] Battery optimization works (duration scales to 30% on low battery)","+- [ ] Reduced motion is respected (animations skip entirely)","+- [ ] FPS throttling works (duration scales to 60% on low FPS)"," - [ ] Idle detection works (pauses after 5min inactivity)","+- [ ] Page leave detection works (pauses when tab hidden)","+","+### Phase 4: Cleanup"," - [ ] `useAnimateElement.ts` deleted","-- [ ] No import errors","+- [ ] No import errors anywhere"," - [ ] Type checking passes (`npm run typecheck`)"," - [ ] Build succeeds (`npm run build`)","-- [ ] Zero visual regressions","+- [ ] Zero visual regressions confirmed"," "," ---"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"f677e4f8-7b38-476f-84ca-df655574b33f","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01DvFXBo87Pn6cVQNuE5zLEt","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Let me create a quick summary at the very end to highlight what's been fixed:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1706,"cache_read_input_tokens":145064,"cache_creation":{"ephemeral_5m_input_tokens":1706,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTtoDqSfd4EvYjoqDkA7X","type":"assistant","uuid":"6a67c8d9-7559-41fd-8638-76f6a410c967","timestamp":"2025-10-08T00:38:24.637Z"}
{"parentUuid":"6a67c8d9-7559-41fd-8638-76f6a410c967","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01DvFXBo87Pn6cVQNuE5zLEt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Vxb15BmvwTtWDLND11gMFT","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/FLOATING_V2.md","old_string":"---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**","new_string":"---\n\n## Summary of Changes vs. Original Blocker Report\n\n### Original Blockers (FLOATING_REFACTOR_BLOCKERS.md)\n1. âŒ Missing exit presets (`fadeOut`, `scaleIn`, `scaleOut`)\n2. âŒ `enterExit` pattern doesn't create `animateIn`/`animateOut`\n3. âŒ `reverse()` mapped to `animateOut()` (not equivalent)\n4. âŒ `isVisible` lifecycle conflicts\n\n### This Plan's Solutions\n1. âœ… Add missing presets to `useAnimation.ts` (not `useAnimateElement.ts` - we're deleting it)\n2. âœ… Use manual lifecycle control (NOT `enterExit` pattern)\n3. âœ… Preserve `reverse()` using Web Animations API native `reverse()`\n4. âœ… Keep exact legacy `isVisible` lifecycle unchanged\n\n### New Critical Fixes (Post-Review)\n5. âœ… **Wrap `animateIn`/`animateOut` to track `isAnimating` state** (fixes slot consumer visibility)\n6. âœ… **Separate browser support check from environment throttling** (fixes low battery/FPS scaling)\n\n### Final Architecture\n```typescript\n// AnimatedFloatingElement.vue (after migration)\nconst animation = useAnimation(elementRef, {\n  animation: { preset, duration, easing },\n  autoplay: false,\n  respectEnvironment: true\n})\n\n// Manual isAnimating tracking (Fix #1)\nconst isAnimating = ref(false)\nconst wrappedAnimateIn = async () => {\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Browser capability check (Fix #2)\nconst isAnimationSupported = computed(() =>\n  animation.animate?.value !== undefined ||\n  typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n)\n\n// Preserve reverse() for click-outside\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim?.playState === 'running') {\n    isAnimating.value = true\n    anim.reverse()\n    await anim.finished\n    isAnimating.value = false\n  } else {\n    await wrappedAnimateOut()\n  }\n}\n\n// Exact same lifecycle logic (lines 92-113 unchanged)\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  // Same as before - DO NOT CHANGE\n})\n```\n\n### Key Takeaways\n- âœ… Zero changes to `AnimatedFloatingElement.vue` public API\n- âœ… Zero changes to `AiConductorGraphicV2.vue` usage\n- âœ… Gains automatic environment detection (battery, FPS, reduced motion, idle, page leave)\n- âœ… Slot consumers get accurate `isAnimating` values\n- âœ… Environment throttling works correctly (scaled animations, not instant snaps)\n- âœ… Single animation composable to maintain (`useAnimateElement.ts` deleted)\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions and passing all critical fix validations.**"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1706,"cache_read_input_tokens":145064,"cache_creation":{"ephemeral_5m_input_tokens":1706,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTtoDqSfd4EvYjoqDkA7X","type":"assistant","uuid":"2f55e129-e876-4929-9b35-f557041e2ebc","timestamp":"2025-10-08T00:38:42.345Z"}
{"parentUuid":"2f55e129-e876-4929-9b35-f557041e2ebc","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Vxb15BmvwTtWDLND11gMFT","type":"tool_result","content":"The file /Users/natedamstra/socialaize/FLOATING_V2.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1064â†’   - One file to maintain instead of two\n  1065â†’   - Shared presets reduce duplication\n  1066â†’   - Centralized bug fixes\n  1067â†’\n  1068â†’---\n  1069â†’\n  1070â†’## Summary of Changes vs. Original Blocker Report\n  1071â†’\n  1072â†’### Original Blockers (FLOATING_REFACTOR_BLOCKERS.md)\n  1073â†’1. âŒ Missing exit presets (`fadeOut`, `scaleIn`, `scaleOut`)\n  1074â†’2. âŒ `enterExit` pattern doesn't create `animateIn`/`animateOut`\n  1075â†’3. âŒ `reverse()` mapped to `animateOut()` (not equivalent)\n  1076â†’4. âŒ `isVisible` lifecycle conflicts\n  1077â†’\n  1078â†’### This Plan's Solutions\n  1079â†’1. âœ… Add missing presets to `useAnimation.ts` (not `useAnimateElement.ts` - we're deleting it)\n  1080â†’2. âœ… Use manual lifecycle control (NOT `enterExit` pattern)\n  1081â†’3. âœ… Preserve `reverse()` using Web Animations API native `reverse()`\n  1082â†’4. âœ… Keep exact legacy `isVisible` lifecycle unchanged\n  1083â†’\n  1084â†’### New Critical Fixes (Post-Review)\n  1085â†’5. âœ… **Wrap `animateIn`/`animateOut` to track `isAnimating` state** (fixes slot consumer visibility)\n  1086â†’6. âœ… **Separate browser support check from environment throttling** (fixes low battery/FPS scaling)\n  1087â†’\n  1088â†’### Final Architecture\n  1089â†’```typescript\n  1090â†’// AnimatedFloatingElement.vue (after migration)\n  1091â†’const animation = useAnimation(elementRef, {\n  1092â†’  animation: { preset, duration, easing },\n  1093â†’  autoplay: false,\n  1094â†’  respectEnvironment: true\n  1095â†’})\n  1096â†’\n  1097â†’// Manual isAnimating tracking (Fix #1)\n  1098â†’const isAnimating = ref(false)\n  1099â†’const wrappedAnimateIn = async () => {\n  1100â†’  try {\n  1101â†’    isAnimating.value = true\n  1102â†’    await animation.animateIn()\n  1103â†’  } finally {\n  1104â†’    isAnimating.value = false\n  1105â†’  }\n  1106â†’}\n  1107â†’\n  1108â†’// Browser capability check (Fix #2)\n  1109â†’const isAnimationSupported = computed(() =>\n  1110â†’  animation.animate?.value !== undefined ||\n  1111â†’  typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n  1112â†’)\n  1113â†’\n  1114â†’// Preserve reverse() for click-outside\n  1115â†’const reverse = async () => {\n  1116â†’  const anim = animation.animate?.value\n  1117â†’  if (anim?.playState === 'running') {\n  1118â†’    isAnimating.value = true\n  1119â†’    anim.reverse()\n  1120â†’    await anim.finished\n  1121â†’    isAnimating.value = false\n  1122â†’  } else {\n  1123â†’    await wrappedAnimateOut()\n  1124â†’  }\n  1125â†’}\n  1126â†’\n  1127â†’// Exact same lifecycle logic (lines 92-113 unchanged)\n  1128â†’watch(() => props.modelValue, async (newValue, oldValue) => {\n  1129â†’  // Same as before - DO NOT CHANGE\n  1130â†’})\n  1131â†’```\n  1132â†’\n  1133â†’### Key Takeaways\n  1134â†’- âœ… Zero changes to `AnimatedFloatingElement.vue` public API\n  1135â†’- âœ… Zero changes to `AiConductorGraphicV2.vue` usage\n  1136â†’- âœ… Gains automatic environment detection (battery, FPS, reduced motion, idle, page leave)\n  1137â†’- âœ… Slot consumers get accurate `isAnimating` values\n  1138â†’- âœ… Environment throttling works correctly (scaled animations, not instant snaps)\n  1139â†’- âœ… Single animation composable to maintain (`useAnimateElement.ts` deleted)\n  1140â†’\n  1141â†’---\n  1142â†’\n  1143â†’**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions and passing all critical fix validations.**\n  1144â†’"}]},"uuid":"3a2eb131-c286-4b9e-ad84-1980150c8a7e","timestamp":"2025-10-08T00:38:42.633Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/FLOATING_V2.md","oldString":"---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**","newString":"---\n\n## Summary of Changes vs. Original Blocker Report\n\n### Original Blockers (FLOATING_REFACTOR_BLOCKERS.md)\n1. âŒ Missing exit presets (`fadeOut`, `scaleIn`, `scaleOut`)\n2. âŒ `enterExit` pattern doesn't create `animateIn`/`animateOut`\n3. âŒ `reverse()` mapped to `animateOut()` (not equivalent)\n4. âŒ `isVisible` lifecycle conflicts\n\n### This Plan's Solutions\n1. âœ… Add missing presets to `useAnimation.ts` (not `useAnimateElement.ts` - we're deleting it)\n2. âœ… Use manual lifecycle control (NOT `enterExit` pattern)\n3. âœ… Preserve `reverse()` using Web Animations API native `reverse()`\n4. âœ… Keep exact legacy `isVisible` lifecycle unchanged\n\n### New Critical Fixes (Post-Review)\n5. âœ… **Wrap `animateIn`/`animateOut` to track `isAnimating` state** (fixes slot consumer visibility)\n6. âœ… **Separate browser support check from environment throttling** (fixes low battery/FPS scaling)\n\n### Final Architecture\n```typescript\n// AnimatedFloatingElement.vue (after migration)\nconst animation = useAnimation(elementRef, {\n  animation: { preset, duration, easing },\n  autoplay: false,\n  respectEnvironment: true\n})\n\n// Manual isAnimating tracking (Fix #1)\nconst isAnimating = ref(false)\nconst wrappedAnimateIn = async () => {\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Browser capability check (Fix #2)\nconst isAnimationSupported = computed(() =>\n  animation.animate?.value !== undefined ||\n  typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n)\n\n// Preserve reverse() for click-outside\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim?.playState === 'running') {\n    isAnimating.value = true\n    anim.reverse()\n    await anim.finished\n    isAnimating.value = false\n  } else {\n    await wrappedAnimateOut()\n  }\n}\n\n// Exact same lifecycle logic (lines 92-113 unchanged)\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  // Same as before - DO NOT CHANGE\n})\n```\n\n### Key Takeaways\n- âœ… Zero changes to `AnimatedFloatingElement.vue` public API\n- âœ… Zero changes to `AiConductorGraphicV2.vue` usage\n- âœ… Gains automatic environment detection (battery, FPS, reduced motion, idle, page leave)\n- âœ… Slot consumers get accurate `isAnimating` values\n- âœ… Environment throttling works correctly (scaled animations, not instant snaps)\n- âœ… Single animation composable to maintain (`useAnimateElement.ts` deleted)\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions and passing all critical fix validations.**","originalFile":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Critical Fixes Applied (vs. FLOATING_REFACTOR_BLOCKERS.md)\n\n### Fix #1: `isAnimating` State Tracking\n**Problem:** `useAnimation.isPlaying` only updates when `play()` is called, not when `animateIn()`/`animateOut()` are called directly. This breaks slot consumers like `AiConductorGraphicV2.vue` that rely on `isAnimating` to hide chat bubbles during animations.\n\n**Solution:** Manually track `isAnimating` state by wrapping `animateIn`/`animateOut`:\n```typescript\nconst isAnimating = ref(false)\n\nconst wrappedAnimateIn = async () => {\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n```\n\n**Impact:** Slot consumers receive accurate `isAnimating` values, preventing chat bubbles from flickering during enter/exit animations.\n\n### Fix #2: Browser Support vs Environment Throttling\n**Problem:** Treating `animation.canAnimate` as browser support check short-circuits environment throttling. `canAnimate` goes `false` for low battery/FPS/reduced motion, which would make animations snap instantly instead of running with scaled duration.\n\n**Solution:** Separate browser capability check from environment state:\n```typescript\nconst isAnimationSupported = computed(() => {\n  // Check Web Animations API browser support, NOT environment conditions\n  return animation.animate?.value !== undefined ||\n         typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n```\n\n**Impact:** Low battery/FPS still runs smooth animations (just faster), instead of instant snaps. Reduced motion still skips animations correctly.\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// CRITICAL: Track animation state separately from useAnimation's isPlaying\n// because isPlaying only updates when play() is called, not animateIn/animateOut\nconst isAnimating = ref(false)\n\n// CRITICAL: Separate Web Animations support check from environment throttling\n// canAnimate goes false for low battery/FPS, but we still want to run animations\n// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\nconst isAnimationSupported = computed(() => {\n  // Check if Web Animations API is available (browser support)\n  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n\n// Wrap animateIn to track isAnimating state\nconst wrappedAnimateIn = async () => {\n  if (!animation.animateIn) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Wrap animateOut to track isAnimating state\nconst wrappedAnimateOut = async () => {\n  if (!animation.animateOut) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateOut()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    try {\n      isAnimating.value = true\n      // Reverse the current animation\n      anim.reverse()\n      await anim.finished\n    } finally {\n      isAnimating.value = false\n    }\n  } else {\n    // Fallback: play exit animation if no animation running\n    await wrappedAnimateOut()\n  }\n}\n\n// Export wrapped versions for use in template\nconst animateIn = wrappedAnimateIn\nconst animateOut = wrappedAnimateOut\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue\n- âœ… **Separate browser support check** - Allows environment throttling to work correctly\n\n**Critical Implementation Details:**\n\n1. **`isAnimating` State Tracking**\n   - `useAnimation.isPlaying` only updates when `play()` is called\n   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`\n   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations\n   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`\n\n2. **Browser Support vs Environment Throttling**\n   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS\n   - But we WANT scaled animations to run (30% duration on low battery, etc.)\n   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly\n\n### Step 2.3: How Environment Throttling Works (Post-Fix)\n\n**With the fixes above, here's how environment detection actually works:**\n\n**Scenario 1: Low Battery (<20%)**\n```typescript\n// User opens floating element\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    // isAnimationSupported checks browser capability (always true in modern browsers)\n    if (isAnimationSupported.value) {\n      await animateIn() // Calls animation.animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'low' (due to battery)\n      // - effectiveDuration = baseDuration * 0.3\n      // - Animation runs with 30% of normal duration (FAST but smooth)\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n\n**Scenario 2: Reduced Motion Preference**\n```typescript\n// User has prefers-reduced-motion enabled\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'none' (due to reduced motion)\n      // - Skips animation, applies final state instantly\n      // - Returns immediately\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** No animation, final state applied instantly (accessible)\n\n**Scenario 3: Low FPS (<30fps)**\n```typescript\n// Device is struggling with performance\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'medium' (due to low FPS)\n      // - effectiveDuration = baseDuration * 0.6\n      // - Animation runs with 60% of normal duration\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n\n**Key Insight:**\n- `isAnimationSupported` checks **browser capability** (Web Animations API support)\n- `animation.canAnimate` checks **environment conditions** (battery, FPS, motion preference)\n- `animation.animateIn()` internally handles environment throttling by scaling duration\n- We check `isAnimationSupported` to decide **whether to animate at all**\n- `useAnimation` handles **how to animate** based on environment\n\n### Step 2.4: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.5: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.6: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.7: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Critical Fix Validation (MUST PASS BEFORE PROCEEDING)\n\n**Test Fix #1: `isAnimating` State Tracking**\n\nVerify that slot consumers receive correct `isAnimating` values:\n\n```vue\n<!-- Test in AiConductorGraphicV2.vue -->\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  @animation-start=\"handleFloatingElementStart\"\n  @animation-complete=\"handleFloatingElementComplete\"\n>\n  <template #default=\"{ isAnimating: isFloatingAnimating }\">\n    <!-- CRITICAL: This must be true during enter/exit animations -->\n    <div v-if=\"isFloatingAnimating\">\n      ANIMATING: {{ isFloatingAnimating }}\n    </div>\n\n    <!-- Chat bubble should be HIDDEN during animations -->\n    <ChatBubble\n      v-if=\"showConductorCommand && !isFloatingAnimating\"\n      :messages=\"chatMessages\"\n    />\n  </template>\n</AnimatedFloatingElement>\n```\n\n**Expected Behavior:**\n1. Open conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n2. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Chat bubble SHOWS\n3. Close conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n4. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Component unmounts\n\n**Failure Symptoms:**\n- âŒ Chat bubble shows during enter animation (flickering)\n- âŒ Provider responses visible during exit animation (visual regression)\n- âŒ `isFloatingAnimating` always `false` (broken slot prop)\n\n**Test Fix #2: Environment Throttling Still Works**\n\nVerify that low battery/FPS still runs scaled animations (not instant snaps):\n\n**Test 2.1: Low Battery**\n```typescript\n// DevTools â†’ Sensors â†’ Battery\n// Set: Level 15%, Charging: No\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n// - NOT instant snap to final state\n// - Still smooth visual transition, just faster\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Test 2.2: Reduced Motion**\n```typescript\n// System Settings â†’ Accessibility â†’ Reduce Motion: ON\n// OR DevTools â†’ Rendering â†’ Emulate CSS prefers-reduced-motion: reduce\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation skips entirely\n// - Final state applied instantly\n// - No visual motion\n\n// Failure: Animation still runs (accessibility violation)\n```\n\n**Test 2.3: Low FPS**\n```typescript\n// DevTools â†’ Performance â†’ CPU: 6x slowdown\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n// - Smooth transition, no jank\n// - Performance-adapted\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Critical:** If any of these tests fail, **DO NOT PROCEED** to Phase 4. The wrappers around `animateIn`/`animateOut` are not working correctly.\n\n### Step 3.2: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.3: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.4: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.5: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n### Phase 1: Preparation\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] Presets export correctly from `useAnimation.ts`\n\n### Phase 2: Migration\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `isAnimating` wrapper functions implemented correctly\n- [ ] `isAnimationSupported` checks browser capability (not environment)\n- [ ] `reverse()` function uses Web Animations API\n\n### Phase 3: Critical Fix Validation\n- [ ] **Fix #1:** `isAnimating` slot prop updates correctly during animations\n- [ ] **Fix #1:** Chat bubbles HIDDEN during enter/exit in `AiConductorGraphicV2.vue`\n- [ ] **Fix #2:** Low battery runs scaled animations (NOT instant snap)\n- [ ] **Fix #2:** Reduced motion skips animations correctly\n- [ ] **Fix #2:** Low FPS runs scaled animations (NOT instant snap)\n\n### Phase 3: Visual Regression Testing\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Skip initial animation works instantly\n- [ ] All props still work correctly\n\n### Phase 3: Environment Detection Testing\n- [ ] Battery optimization works (duration scales to 30% on low battery)\n- [ ] Reduced motion is respected (animations skip entirely)\n- [ ] FPS throttling works (duration scales to 60% on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] Page leave detection works (pauses when tab hidden)\n\n### Phase 4: Cleanup\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors anywhere\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions confirmed\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**\n","structuredPatch":[{"oldStart":1067,"oldLines":4,"newStart":1067,"newLines":77,"lines":[" "," ---"," ","-**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions.**","+## Summary of Changes vs. Original Blocker Report","+","+### Original Blockers (FLOATING_REFACTOR_BLOCKERS.md)","+1. âŒ Missing exit presets (`fadeOut`, `scaleIn`, `scaleOut`)","+2. âŒ `enterExit` pattern doesn't create `animateIn`/`animateOut`","+3. âŒ `reverse()` mapped to `animateOut()` (not equivalent)","+4. âŒ `isVisible` lifecycle conflicts","+","+### This Plan's Solutions","+1. âœ… Add missing presets to `useAnimation.ts` (not `useAnimateElement.ts` - we're deleting it)","+2. âœ… Use manual lifecycle control (NOT `enterExit` pattern)","+3. âœ… Preserve `reverse()` using Web Animations API native `reverse()`","+4. âœ… Keep exact legacy `isVisible` lifecycle unchanged","+","+### New Critical Fixes (Post-Review)","+5. âœ… **Wrap `animateIn`/`animateOut` to track `isAnimating` state** (fixes slot consumer visibility)","+6. âœ… **Separate browser support check from environment throttling** (fixes low battery/FPS scaling)","+","+### Final Architecture","+```typescript","+// AnimatedFloatingElement.vue (after migration)","+const animation = useAnimation(elementRef, {","+  animation: { preset, duration, easing },","+  autoplay: false,","+  respectEnvironment: true","+})","+","+// Manual isAnimating tracking (Fix #1)","+const isAnimating = ref(false)","+const wrappedAnimateIn = async () => {","+  try {","+    isAnimating.value = true","+    await animation.animateIn()","+  } finally {","+    isAnimating.value = false","+  }","+}","+","+// Browser capability check (Fix #2)","+const isAnimationSupported = computed(() =>","+  animation.animate?.value !== undefined ||","+  typeof window !== 'undefined' && 'animate' in HTMLElement.prototype","+)","+","+// Preserve reverse() for click-outside","+const reverse = async () => {","+  const anim = animation.animate?.value","+  if (anim?.playState === 'running') {","+    isAnimating.value = true","+    anim.reverse()","+    await anim.finished","+    isAnimating.value = false","+  } else {","+    await wrappedAnimateOut()","+  }","+}","+","+// Exact same lifecycle logic (lines 92-113 unchanged)","+watch(() => props.modelValue, async (newValue, oldValue) => {","+  // Same as before - DO NOT CHANGE","+})","+```","+","+### Key Takeaways","+- âœ… Zero changes to `AnimatedFloatingElement.vue` public API","+- âœ… Zero changes to `AiConductorGraphicV2.vue` usage","+- âœ… Gains automatic environment detection (battery, FPS, reduced motion, idle, page leave)","+- âœ… Slot consumers get accurate `isAnimating` values","+- âœ… Environment throttling works correctly (scaled animations, not instant snaps)","+- âœ… Single animation composable to maintain (`useAnimateElement.ts` deleted)","+","+---","+","+**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions and passing all critical fix validations.**"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"3a2eb131-c286-4b9e-ad84-1980150c8a7e","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TYovRzYhn6fXW4FVJJXn18","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now let me create a final \"Quick Reference\" section at the top for implementers:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2204,"cache_read_input_tokens":146770,"cache_creation":{"ephemeral_5m_input_tokens":2204,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTtoFaQqsztUGqURg1Lmh","type":"assistant","uuid":"3125e144-93a7-4d72-989f-7b76852a1d68","timestamp":"2025-10-08T00:38:48.453Z"}
{"parentUuid":"3125e144-93a7-4d72-989f-7b76852a1d68","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TYovRzYhn6fXW4FVJJXn18","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WYjH1Y2TkWJUWZSWaWmxEw","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/FLOATING_V2.md","old_string":"**Date:** 2025-01-07\n\n---\n\n## Critical Fixes Applied (vs. FLOATING_REFACTOR_BLOCKERS.md)","new_string":"**Date:** 2025-01-07\n\n---\n\n## Quick Reference for Implementers\n\n**TL;DR:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation`, then delete `useAnimateElement.ts`.\n\n### Two Critical Fixes Required\n1. **Wrap `animateIn`/`animateOut` to track `isAnimating`** - Fixes slot consumer visibility issues\n2. **Check browser support, not environment conditions** - Fixes low battery/FPS scaling\n\n### Implementation Checklist\n- [ ] Phase 1: Move `animationPresets` to `useAnimation.ts`, add missing presets (30min)\n- [ ] Phase 2: Migrate `AnimatedFloatingElement.vue` with wrapper functions (2hr)\n- [ ] Phase 3: Test critical fixes - `isAnimating` tracking & environment throttling (1hr)\n- [ ] Phase 4: Delete `useAnimateElement.ts` after zero regressions confirmed (15min)\n\n### Testing Priority\n1. **MUST PASS:** `AiConductorGraphicV2.vue` chat bubbles HIDDEN during enter/exit animations\n2. **MUST PASS:** Low battery/FPS runs scaled animations (NOT instant snaps)\n3. **MUST PASS:** Reduced motion skips animations correctly\n\n**Total Time:** ~4 hours | **Risk Level:** Medium (with proper testing) | **Rollback:** `git checkout HEAD -- [files]`\n\n---\n\n## Critical Fixes Applied (vs. FLOATING_REFACTOR_BLOCKERS.md)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2204,"cache_read_input_tokens":146770,"cache_creation":{"ephemeral_5m_input_tokens":2204,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTtoFaQqsztUGqURg1Lmh","type":"assistant","uuid":"a2759bcd-1b63-47a0-a24b-ba0af695922e","timestamp":"2025-10-08T00:38:57.725Z"}
{"parentUuid":"a2759bcd-1b63-47a0-a24b-ba0af695922e","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WYjH1Y2TkWJUWZSWaWmxEw","type":"tool_result","content":"The file /Users/natedamstra/socialaize/FLOATING_V2.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     3â†’**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n     4â†’\n     5â†’**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n     6â†’\n     7â†’**Date:** 2025-01-07\n     8â†’\n     9â†’---\n    10â†’\n    11â†’## Quick Reference for Implementers\n    12â†’\n    13â†’**TL;DR:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation`, then delete `useAnimateElement.ts`.\n    14â†’\n    15â†’### Two Critical Fixes Required\n    16â†’1. **Wrap `animateIn`/`animateOut` to track `isAnimating`** - Fixes slot consumer visibility issues\n    17â†’2. **Check browser support, not environment conditions** - Fixes low battery/FPS scaling\n    18â†’\n    19â†’### Implementation Checklist\n    20â†’- [ ] Phase 1: Move `animationPresets` to `useAnimation.ts`, add missing presets (30min)\n    21â†’- [ ] Phase 2: Migrate `AnimatedFloatingElement.vue` with wrapper functions (2hr)\n    22â†’- [ ] Phase 3: Test critical fixes - `isAnimating` tracking & environment throttling (1hr)\n    23â†’- [ ] Phase 4: Delete `useAnimateElement.ts` after zero regressions confirmed (15min)\n    24â†’\n    25â†’### Testing Priority\n    26â†’1. **MUST PASS:** `AiConductorGraphicV2.vue` chat bubbles HIDDEN during enter/exit animations\n    27â†’2. **MUST PASS:** Low battery/FPS runs scaled animations (NOT instant snaps)\n    28â†’3. **MUST PASS:** Reduced motion skips animations correctly\n    29â†’\n    30â†’**Total Time:** ~4 hours | **Risk Level:** Medium (with proper testing) | **Rollback:** `git checkout HEAD -- [files]`\n    31â†’\n    32â†’---\n    33â†’\n    34â†’## Critical Fixes Applied (vs. FLOATING_REFACTOR_BLOCKERS.md)\n    35â†’\n    36â†’### Fix #1: `isAnimating` State Tracking\n    37â†’**Problem:** `useAnimation.isPlaying` only updates when `play()` is called, not when `animateIn()`/`animateOut()` are called directly. This breaks slot consumers like `AiConductorGraphicV2.vue` that rely on `isAnimating` to hide chat bubbles during animations.\n    38â†’"}]},"uuid":"5cd47c11-5f63-4c91-b347-14c86bb8de70","timestamp":"2025-10-08T00:38:57.830Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/FLOATING_V2.md","oldString":"**Date:** 2025-01-07\n\n---\n\n## Critical Fixes Applied (vs. FLOATING_REFACTOR_BLOCKERS.md)","newString":"**Date:** 2025-01-07\n\n---\n\n## Quick Reference for Implementers\n\n**TL;DR:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation`, then delete `useAnimateElement.ts`.\n\n### Two Critical Fixes Required\n1. **Wrap `animateIn`/`animateOut` to track `isAnimating`** - Fixes slot consumer visibility issues\n2. **Check browser support, not environment conditions** - Fixes low battery/FPS scaling\n\n### Implementation Checklist\n- [ ] Phase 1: Move `animationPresets` to `useAnimation.ts`, add missing presets (30min)\n- [ ] Phase 2: Migrate `AnimatedFloatingElement.vue` with wrapper functions (2hr)\n- [ ] Phase 3: Test critical fixes - `isAnimating` tracking & environment throttling (1hr)\n- [ ] Phase 4: Delete `useAnimateElement.ts` after zero regressions confirmed (15min)\n\n### Testing Priority\n1. **MUST PASS:** `AiConductorGraphicV2.vue` chat bubbles HIDDEN during enter/exit animations\n2. **MUST PASS:** Low battery/FPS runs scaled animations (NOT instant snaps)\n3. **MUST PASS:** Reduced motion skips animations correctly\n\n**Total Time:** ~4 hours | **Risk Level:** Medium (with proper testing) | **Rollback:** `git checkout HEAD -- [files]`\n\n---\n\n## Critical Fixes Applied (vs. FLOATING_REFACTOR_BLOCKERS.md)","originalFile":"# AnimatedFloatingElement Migration Plan v2\n\n**Status:** ðŸŸ¢ **READY FOR IMPLEMENTATION** (Blockers Resolved)\n\n**Goal:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation` composable, then delete `useAnimateElement.ts` entirely.\n\n**Date:** 2025-01-07\n\n---\n\n## Critical Fixes Applied (vs. FLOATING_REFACTOR_BLOCKERS.md)\n\n### Fix #1: `isAnimating` State Tracking\n**Problem:** `useAnimation.isPlaying` only updates when `play()` is called, not when `animateIn()`/`animateOut()` are called directly. This breaks slot consumers like `AiConductorGraphicV2.vue` that rely on `isAnimating` to hide chat bubbles during animations.\n\n**Solution:** Manually track `isAnimating` state by wrapping `animateIn`/`animateOut`:\n```typescript\nconst isAnimating = ref(false)\n\nconst wrappedAnimateIn = async () => {\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n```\n\n**Impact:** Slot consumers receive accurate `isAnimating` values, preventing chat bubbles from flickering during enter/exit animations.\n\n### Fix #2: Browser Support vs Environment Throttling\n**Problem:** Treating `animation.canAnimate` as browser support check short-circuits environment throttling. `canAnimate` goes `false` for low battery/FPS/reduced motion, which would make animations snap instantly instead of running with scaled duration.\n\n**Solution:** Separate browser capability check from environment state:\n```typescript\nconst isAnimationSupported = computed(() => {\n  // Check Web Animations API browser support, NOT environment conditions\n  return animation.animate?.value !== undefined ||\n         typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n```\n\n**Impact:** Low battery/FPS still runs smooth animations (just faster), instead of instant snaps. Reduced motion still skips animations correctly.\n\n---\n\n## Migration Strategy Overview\n\n### Core Principle\n**Preserve exact legacy behavior** while gaining `useAnimation`'s environment detection (battery, FPS, reduced motion, idle, page leave).\n\n### Why This Migration?\n1. **Consolidate animation APIs** - One composable to maintain instead of two\n2. **Better environment detection** - Automatic battery/FPS/reduced motion handling\n3. **Future-proof** - All new animations use `useAnimation` (e.g., `AIEnhancementTheater.vue`)\n4. **Consistent API** - Same patterns across entire codebase\n\n### What We're NOT Changing\n- âœ… `AnimatedFloatingElement.vue` public API (props, events, slots)\n- âœ… `AiConductorGraphicV2.vue` behavior and timing\n- âœ… Visual appearance and animation feel\n- âœ… Mount/unmount lifecycle timing\n\n### What We ARE Adding\n- âœ… Battery-aware auto-pause (respects `critical` prop)\n- âœ… FPS-based duration scaling\n- âœ… Idle detection (5min inactivity)\n- âœ… Page leave detection\n- âœ… Animation quality levels (none/low/medium/high)\n\n---\n\n## Phase 1: Prepare `useAnimation.ts` (30 min)\n\n### Step 1.1: Move `animationPresets` into `useAnimation.ts`\n\n**Current State:**\n```typescript\n// useAnimateElement.ts exports animationPresets\nexport const animationPresets = { ... }\n\n// useAnimation.ts imports them\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n```\n\n**Target State:**\n```typescript\n// useAnimation.ts defines and exports animationPresets\nexport const animationPresets = {\n  // All existing presets\n  fadeIn: { ... },\n  slideUp: { ... },\n  // ... etc\n\n  // NEW: Add missing presets\n  fadeOut: { ... },\n  scaleIn: { ... },\n  scaleOut: { ... }\n}\n```\n\n**Action:**\n1. Copy the entire `animationPresets` object from `useAnimateElement.ts` (lines 30-188)\n2. Paste it at the top of `useAnimation.ts` (after imports, before line 29)\n3. Add three new presets (see Step 1.2)\n4. Update import in `useAnimation.ts` to remove `animationPresets` from the import list\n5. Keep `type AnimationPreset` import (it's still defined in useAnimateElement.ts)\n\n### Step 1.2: Add Missing Exit Presets\n\nAdd these three presets to the `animationPresets` object in `useAnimation.ts`:\n\n```typescript\nfadeOut: {\n  keyframes: [\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.SMOOTH,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleIn: {\n  keyframes: [\n    { opacity: 0, transform: 'scale(0.8)' },\n    { opacity: 1, transform: 'scale(1)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.NORMAL,\n    easing: EASING.BOUNCE,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n\nscaleOut: {\n  keyframes: [\n    { opacity: 1, transform: 'scale(1)' },\n    { opacity: 0, transform: 'scale(0.8)' }\n  ],\n  options: {\n    duration: ANIMATION_DURATION.FAST,\n    easing: EASING.EASE_OUT,\n    fill: FILL_MODE.FORWARDS\n  }\n} as AnimationPreset,\n```\n\n**Why these keyframes?**\n- `fadeOut`: Simple opacity fade (pairs with `fadeIn`)\n- `scaleIn`: Zoom in from 80% (pairs with `scaleOut`)\n- `scaleOut`: Zoom out to 80% (pairs with `scaleIn`)\n\n### Step 1.3: Verify `animationPresets` Export\n\nEnsure `useAnimation.ts` exports the presets:\n\n```typescript\n// Near top of file (after definition)\nexport { animationPresets } from './useAnimateElement' // REMOVE THIS\nexport const animationPresets = { ... } // Already defined above\n\n// Or at bottom with other exports\nexport { preset, presets } from './useAnimationPresets'\nexport { animationPresets } // Add if not already exported\n```\n\n---\n\n## Phase 2: Migrate `AnimatedFloatingElement.vue` (2 hours)\n\n### Step 2.1: Replace Composable Import\n\n**Current:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimateElement, animationPresets, type UseAnimateElementOptions } from '@composables/useAnimateElement'\n```\n\n**New:**\n```vue\n<script setup lang=\"ts\">\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\nimport type { UseAnimationOptions } from '@composables/useAnimation'\n```\n\n### Step 2.2: Replace Animation Setup (The Core Change)\n\n**Current Implementation (lines 61-72):**\n```typescript\nconst animationOptions: UseAnimateElementOptions = {\n  preset: props.preset,\n  duration: props.duration,\n  easing: props.easing,\n  immediate: props.immediate,\n  onComplete: () => {\n    const animationType = props.modelValue ? 'enter' : 'exit'\n    emit('animationComplete', animationType)\n  }\n}\n\nconst { animateIn, animateOut, isAnimating, reverse, isSupported: isAnimationSupported } = useAnimateElement(elementRef, animationOptions)\n```\n\n**New Implementation:**\n```typescript\n// Setup useAnimation with manual lifecycle control (NOT using enterExit pattern)\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false, // Manual control via watch\n  respectEnvironment: true, // Gain battery/FPS/reduced motion detection\n  critical: false // Allow auto-pause on low battery (unless element is critical UI)\n})\n\n// CRITICAL: Track animation state separately from useAnimation's isPlaying\n// because isPlaying only updates when play() is called, not animateIn/animateOut\nconst isAnimating = ref(false)\n\n// CRITICAL: Separate Web Animations support check from environment throttling\n// canAnimate goes false for low battery/FPS, but we still want to run animations\n// with scaled duration. We need a distinct \"is Web Animations API supported\" flag.\nconst isAnimationSupported = computed(() => {\n  // Check if Web Animations API is available (browser support)\n  return animation.animate?.value !== undefined || typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n})\n\n// Wrap animateIn to track isAnimating state\nconst wrappedAnimateIn = async () => {\n  if (!animation.animateIn) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Wrap animateOut to track isAnimating state\nconst wrappedAnimateOut = async () => {\n  if (!animation.animateOut) return\n\n  try {\n    isAnimating.value = true\n    await animation.animateOut()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Create reverse() function using Web Animations API\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    try {\n      isAnimating.value = true\n      // Reverse the current animation\n      anim.reverse()\n      await anim.finished\n    } finally {\n      isAnimating.value = false\n    }\n  } else {\n    // Fallback: play exit animation if no animation running\n    await wrappedAnimateOut()\n  }\n}\n\n// Export wrapped versions for use in template\nconst animateIn = wrappedAnimateIn\nconst animateOut = wrappedAnimateOut\n```\n\n**Why this approach?**\n- âœ… No `enterExit` pattern (avoids Blocker #2)\n- âœ… Preserves `reverse()` for click-outside (solves Blocker #3)\n- âœ… Maintains exact same lifecycle hooks\n- âœ… Gains environment detection automatically\n- âœ… **Manual `isAnimating` tracking** - Fixes slot consumer visibility issue\n- âœ… **Separate browser support check** - Allows environment throttling to work correctly\n\n**Critical Implementation Details:**\n\n1. **`isAnimating` State Tracking**\n   - `useAnimation.isPlaying` only updates when `play()` is called\n   - Calling `animateIn()`/`animateOut()` directly doesn't update `isPlaying`\n   - Slot consumers (like `AiConductorGraphicV2.vue`) rely on `isAnimating` to hide chat bubbles during animations\n   - **Solution:** Wrap `animateIn`/`animateOut` to manually track `isAnimating.value = true/false`\n\n2. **Browser Support vs Environment Throttling**\n   - `animation.canAnimate` goes `false` for low battery, reduced motion, low FPS\n   - But we WANT scaled animations to run (30% duration on low battery, etc.)\n   - Old code checked `isSupported` (browser capability), not `canAnimate` (environment state)\n   - **Solution:** Check Web Animations API availability separately: `animation.animate?.value !== undefined`\n   - This allows environment-throttled animations to run with scaled duration instead of snapping instantly\n\n### Step 2.3: How Environment Throttling Works (Post-Fix)\n\n**With the fixes above, here's how environment detection actually works:**\n\n**Scenario 1: Low Battery (<20%)**\n```typescript\n// User opens floating element\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    // isAnimationSupported checks browser capability (always true in modern browsers)\n    if (isAnimationSupported.value) {\n      await animateIn() // Calls animation.animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'low' (due to battery)\n      // - effectiveDuration = baseDuration * 0.3\n      // - Animation runs with 30% of normal duration (FAST but smooth)\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n\n**Scenario 2: Reduced Motion Preference**\n```typescript\n// User has prefers-reduced-motion enabled\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'none' (due to reduced motion)\n      // - Skips animation, applies final state instantly\n      // - Returns immediately\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** No animation, final state applied instantly (accessible)\n\n**Scenario 3: Low FPS (<30fps)**\n```typescript\n// Device is struggling with performance\nwatch(() => props.modelValue, async (newValue) => {\n  if (newValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n\n    if (isAnimationSupported.value) {\n      await animateIn()\n      // Inside useAnimation.ts:1279-1287:\n      // - animationQuality.value === 'medium' (due to low FPS)\n      // - effectiveDuration = baseDuration * 0.6\n      // - Animation runs with 60% of normal duration\n    }\n\n    emit('animationComplete', 'enter')\n  }\n})\n```\nâœ… **Result:** Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n\n**Key Insight:**\n- `isAnimationSupported` checks **browser capability** (Web Animations API support)\n- `animation.canAnimate` checks **environment conditions** (battery, FPS, motion preference)\n- `animation.animateIn()` internally handles environment throttling by scaling duration\n- We check `isAnimationSupported` to decide **whether to animate at all**\n- `useAnimation` handles **how to animate** based on environment\n\n### Step 2.4: Keep Exact Same Lifecycle Logic\n\n**Critical:** DO NOT change the `watch(() => props.modelValue)` logic. It must remain EXACTLY as it is (lines 92-113):\n\n```typescript\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  if (!isMounted.value) return\n  if (!isAnimationSupported.value) {\n    isVisible.value = newValue\n    emit('visibilityChange', newValue)\n    return\n  }\n  if (newValue && !oldValue) {\n    emit('animationStart', 'enter')\n    isVisible.value = true\n    await nextTick()\n    if (!props.skipInitialAnimation) animateIn()\n    else emit('animationComplete', 'enter')\n    emit('visibilityChange', true)\n  } else if (!newValue && oldValue) {\n    emit('animationStart', 'exit')\n    if (!props.skipInitialAnimation) await animateOut()\n    isVisible.value = false\n    emit('visibilityChange', false)\n    if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n  }\n}, { immediate: false })\n```\n\n**Why unchanged?**\n- This is the PROVEN lifecycle that works with `AiConductorGraphicV2.vue`\n- Timing of `isVisible` changes is critical for `shouldRender`\n- Event emission order matters for parent components\n\n### Step 2.5: Update `onComplete` Callback\n\nSince we removed `onComplete` from animation options, we need to handle it differently:\n\n**Option A: Use lifecycle hooks (Recommended)**\n```typescript\nconst animation = useAnimation(elementRef, {\n  animation: {\n    preset: props.preset,\n    duration: props.duration,\n    easing: props.easing\n  },\n  autoplay: false,\n  respectEnvironment: true,\n  lifecycle: {\n    afterPlay: () => {\n      // Called after animateIn() completes\n      if (props.modelValue) {\n        emit('animationComplete', 'enter')\n      }\n    }\n  }\n})\n```\n\n**Option B: Keep it in watch (Simpler, matches existing pattern)**\n```typescript\n// In the watch block (already exists):\nif (newValue && !oldValue) {\n  emit('animationStart', 'enter')\n  isVisible.value = true\n  await nextTick()\n  if (!props.skipInitialAnimation) {\n    await animateIn()\n    emit('animationComplete', 'enter') // Add this line\n  }\n  else emit('animationComplete', 'enter')\n  emit('visibilityChange', true)\n} else if (!newValue && oldValue) {\n  emit('animationStart', 'exit')\n  if (!props.skipInitialAnimation) {\n    await animateOut()\n    emit('animationComplete', 'exit') // Add this line\n  }\n  isVisible.value = false\n  emit('visibilityChange', false)\n  if (props.skipInitialAnimation) emit('animationComplete', 'exit')\n}\n```\n\n**Recommendation:** Use Option B (simpler, less refactoring, matches existing mental model)\n\n### Step 2.6: Update `handleClose` Function\n\n**Current (line 129-134):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**New (unchanged, but `reverse()` is now defined above):**\n```typescript\nconst handleClose = async () => {\n  if (!props.modelValue || isAnimating.value) return\n  emit('animationStart', 'exit')\n  if (isAnimationSupported.value && !props.skipInitialAnimation) await reverse()\n  emit('update:modelValue', false)\n}\n```\n\n**Why unchanged?**\n- The new `reverse()` function we defined in Step 2.2 handles the Web Animations API properly\n- Timing and behavior remain identical\n\n### Step 2.7: Update `defineExpose`\n\n**Current (lines 140-146):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef)\n})\n```\n\n**New (add reverse for consistency):**\n```typescript\ndefineExpose({\n  animateIn,\n  animateOut,\n  reverse, // Add this\n  isAnimating: readonly(isAnimating),\n  isVisible: readonly(isVisible),\n  elementRef: readonly(elementRef),\n  canAnimate: readonly(isAnimationSupported) // Add for debugging\n})\n```\n\n---\n\n## Phase 3: Validation & Testing (1 hour)\n\n### Step 3.1: Critical Fix Validation (MUST PASS BEFORE PROCEEDING)\n\n**Test Fix #1: `isAnimating` State Tracking**\n\nVerify that slot consumers receive correct `isAnimating` values:\n\n```vue\n<!-- Test in AiConductorGraphicV2.vue -->\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  @animation-start=\"handleFloatingElementStart\"\n  @animation-complete=\"handleFloatingElementComplete\"\n>\n  <template #default=\"{ isAnimating: isFloatingAnimating }\">\n    <!-- CRITICAL: This must be true during enter/exit animations -->\n    <div v-if=\"isFloatingAnimating\">\n      ANIMATING: {{ isFloatingAnimating }}\n    </div>\n\n    <!-- Chat bubble should be HIDDEN during animations -->\n    <ChatBubble\n      v-if=\"showConductorCommand && !isFloatingAnimating\"\n      :messages=\"chatMessages\"\n    />\n  </template>\n</AnimatedFloatingElement>\n```\n\n**Expected Behavior:**\n1. Open conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n2. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Chat bubble SHOWS\n3. Close conductor â†’ `isFloatingAnimating` becomes `true` â†’ Chat bubble HIDDEN\n4. Animation completes â†’ `isFloatingAnimating` becomes `false` â†’ Component unmounts\n\n**Failure Symptoms:**\n- âŒ Chat bubble shows during enter animation (flickering)\n- âŒ Provider responses visible during exit animation (visual regression)\n- âŒ `isFloatingAnimating` always `false` (broken slot prop)\n\n**Test Fix #2: Environment Throttling Still Works**\n\nVerify that low battery/FPS still runs scaled animations (not instant snaps):\n\n**Test 2.1: Low Battery**\n```typescript\n// DevTools â†’ Sensors â†’ Battery\n// Set: Level 15%, Charging: No\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs smoothly at 30% speed (e.g., 150ms instead of 500ms)\n// - NOT instant snap to final state\n// - Still smooth visual transition, just faster\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Test 2.2: Reduced Motion**\n```typescript\n// System Settings â†’ Accessibility â†’ Reduce Motion: ON\n// OR DevTools â†’ Rendering â†’ Emulate CSS prefers-reduced-motion: reduce\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation skips entirely\n// - Final state applied instantly\n// - No visual motion\n\n// Failure: Animation still runs (accessibility violation)\n```\n\n**Test 2.3: Low FPS**\n```typescript\n// DevTools â†’ Performance â†’ CPU: 6x slowdown\n\n// Open floating element\nisVisible.value = true\n\n// Expected:\n// - Animation runs at 60% speed (e.g., 300ms instead of 500ms)\n// - Smooth transition, no jank\n// - Performance-adapted\n\n// Failure: Element snaps to final state instantly (broken throttling)\n```\n\n**Critical:** If any of these tests fail, **DO NOT PROCEED** to Phase 4. The wrappers around `animateIn`/`animateOut` are not working correctly.\n\n### Step 3.2: Visual Regression Testing\n\nTest `AiConductorGraphicV2.vue` thoroughly:\n\n1. **Enter Animation**\n   - Component mounts â†’ floating element fades in\n   - Conductor animation starts AFTER enter completes\n   - Timing feels identical to before\n\n2. **Exit Animation**\n   - `isVisible = false` â†’ floating element fades out\n   - Conductor animation stops BEFORE exit starts\n   - No visual stuttering or jumping\n\n3. **Click-Outside Close**\n   - Click outside conductor â†’ `reverse()` called\n   - Animation reverses smoothly\n   - `modelValue` updates AFTER reverse completes\n\n4. **Skip Initial Animation**\n   - Set `skipInitialAnimation={true}`\n   - Element appears instantly without animation\n   - Events still fire correctly\n\n### Step 3.3: Environment Detection Testing\n\n**New capability to test:**\n\n1. **Battery Optimization**\n   - Simulate low battery (DevTools â†’ Sensors)\n   - Animations should scale duration by 0.3x\n   - Critical animations continue (if we set `critical: true`)\n\n2. **Reduced Motion**\n   - Enable system reduced motion preference\n   - Animations should skip entirely\n   - Final state applied instantly\n\n3. **Low FPS**\n   - Throttle CPU (DevTools â†’ Performance â†’ CPU 6x slowdown)\n   - Animations should scale duration by 0.6x\n   - No jank or stuttering\n\n4. **Idle Detection**\n   - Wait 5 minutes inactive\n   - Non-critical animations should pause\n   - Resume when user returns\n\n### Step 3.4: Event Timing Validation\n\nCreate a test script to verify event order:\n\n```typescript\n// Test event sequence\nconst events: string[] = []\n\nconst floatingElement = ref()\n\n// Listen to all events\nonMounted(() => {\n  const el = floatingElement.value\n  if (!el) return\n\n  el.$el?.addEventListener('animationStart', (e) => {\n    events.push(`animationStart: ${e.detail}`)\n  })\n  el.$el?.addEventListener('animationComplete', (e) => {\n    events.push(`animationComplete: ${e.detail}`)\n  })\n  el.$el?.addEventListener('visibilityChange', (e) => {\n    events.push(`visibilityChange: ${e.detail}`)\n  })\n})\n\n// Expected sequence on open:\n// 1. animationStart: enter\n// 2. visibilityChange: true\n// 3. animationComplete: enter\n\n// Expected sequence on close:\n// 1. animationStart: exit\n// 2. animationComplete: exit\n// 3. visibilityChange: false\n```\n\n### Step 3.5: Props Compatibility Check\n\nVerify all props still work:\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"        // âœ“ Works (uses animationPresets)\n  teleport-to=\"#layer\"   // âœ“ Works (unchanged)\n  z-index=\"1100\"         // âœ“ Works (unchanged)\n  :positioning=\"{ ... }\" // âœ“ Works (unchanged)\n  :skip-initial-animation=\"true\" // âœ“ Works (watch logic unchanged)\n  :close-on-click-outside=\"false\" // âœ“ Works (handleClose unchanged)\n  :duration=\"500\"        // âœ“ Works (passed to animation config)\n  :easing=\"'ease-out'\"   // âœ“ Works (passed to animation config)\n/>\n```\n\n---\n\n## Phase 4: Delete `useAnimateElement.ts` (15 min)\n\n### Step 4.1: Verify No Remaining Imports\n\nSearch codebase for imports:\n\n```bash\n# Search for useAnimateElement imports\nrg \"useAnimateElement\" --type vue --type ts --type js\n\n# Should only find:\n# - AnimatedFloatingElement.vue (which we already migrated)\n# - useAnimation.ts (importing animationPresets - which we'll remove)\n```\n\n### Step 4.2: Update `useAnimation.ts` Final Cleanup\n\nRemove the import line:\n\n```typescript\n// DELETE THIS LINE:\nimport { animationPresets, type AnimationPreset } from './useAnimateElement'\n\n// KEEP THIS (we moved animationPresets into useAnimation.ts):\nexport const animationPresets = { ... }\nexport type AnimationPreset = { ... } // Move type definition too\n```\n\n### Step 4.3: Delete the File\n\n```bash\nrm src/components/composables/useAnimateElement.ts\n```\n\n### Step 4.4: Update Exports Index (if exists)\n\nIf there's an index file that exports composables:\n\n```typescript\n// src/components/composables/index.ts\nexport { useAnimation, animationPresets } from './useAnimation'\n// DELETE: export { useAnimateElement } from './useAnimateElement'\n```\n\n---\n\n## Phase 5: Future Migration Path (Optional)\n\n### Step 5.1: Add Critical Flag for Essential UI\n\nSome floating elements should NEVER auto-pause (e.g., loading spinners, error modals):\n\n```vue\n<AnimatedFloatingElement\n  v-model=\"isVisible\"\n  preset=\"fadeIn\"\n  critical  <!-- Add this prop -->\n/>\n```\n\nUpdate `AnimatedFloatingElement.vue` props:\n\n```typescript\ninterface Props {\n  // ... existing props\n  critical?: boolean // If true, never auto-pause on battery/idle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  // ... existing defaults\n  critical: false\n})\n\n// Update animation config:\nconst animation = useAnimation(elementRef, {\n  animation: { ... },\n  respectEnvironment: true,\n  critical: props.critical // Pass through\n})\n```\n\n### Step 5.2: Migrate Other Components\n\nOnce validated, migrate these components to use `AnimatedFloatingElement.vue`:\n\n1. **High Priority:**\n   - Modal dialogs\n   - Dropdown menus\n   - Toast notifications\n\n2. **Medium Priority:**\n   - Tooltips\n   - Popover panels\n   - Slide-out panels\n\n3. **Low Priority:**\n   - `AIEnhancementTheater.vue` (currently uses `useAnimation` directly)\n   - Other theater components\n\n---\n\n## Success Criteria Checklist\n\nBefore marking this migration complete:\n\n### Phase 1: Preparation\n- [ ] `animationPresets` moved to `useAnimation.ts`\n- [ ] Three new presets added (`fadeOut`, `scaleIn`, `scaleOut`)\n- [ ] Presets export correctly from `useAnimation.ts`\n\n### Phase 2: Migration\n- [ ] `AnimatedFloatingElement.vue` uses `useAnimation` exclusively\n- [ ] `isAnimating` wrapper functions implemented correctly\n- [ ] `isAnimationSupported` checks browser capability (not environment)\n- [ ] `reverse()` function uses Web Animations API\n\n### Phase 3: Critical Fix Validation\n- [ ] **Fix #1:** `isAnimating` slot prop updates correctly during animations\n- [ ] **Fix #1:** Chat bubbles HIDDEN during enter/exit in `AiConductorGraphicV2.vue`\n- [ ] **Fix #2:** Low battery runs scaled animations (NOT instant snap)\n- [ ] **Fix #2:** Reduced motion skips animations correctly\n- [ ] **Fix #2:** Low FPS runs scaled animations (NOT instant snap)\n\n### Phase 3: Visual Regression Testing\n- [ ] `AiConductorGraphicV2.vue` works identically (enter/exit timing perfect)\n- [ ] Click-outside close uses `reverse()` correctly\n- [ ] All events fire in correct order\n- [ ] Skip initial animation works instantly\n- [ ] All props still work correctly\n\n### Phase 3: Environment Detection Testing\n- [ ] Battery optimization works (duration scales to 30% on low battery)\n- [ ] Reduced motion is respected (animations skip entirely)\n- [ ] FPS throttling works (duration scales to 60% on low FPS)\n- [ ] Idle detection works (pauses after 5min inactivity)\n- [ ] Page leave detection works (pauses when tab hidden)\n\n### Phase 4: Cleanup\n- [ ] `useAnimateElement.ts` deleted\n- [ ] No import errors anywhere\n- [ ] Type checking passes (`npm run typecheck`)\n- [ ] Build succeeds (`npm run build`)\n- [ ] Zero visual regressions confirmed\n\n---\n\n## Rollback Plan\n\nIf something breaks:\n\n1. **Immediate Rollback:**\n   ```bash\n   git checkout HEAD -- src/components/composables/useAnimateElement.ts\n   git checkout HEAD -- src/components/vue/ui/AnimatedFloatingElement.vue\n   ```\n\n2. **Diagnose Issue:**\n   - Check browser console for errors\n   - Compare event timing logs\n   - Test in isolation (create minimal reproduction)\n\n3. **Fix Forward:**\n   - Most likely culprit: lifecycle timing in watch block\n   - Second likely: `reverse()` implementation\n   - Third likely: missing preset configuration\n\n---\n\n## Timeline Estimate\n\n- **Phase 1 (Prepare useAnimation.ts):** 30 minutes\n- **Phase 2 (Migrate AnimatedFloatingElement.vue):** 2 hours\n- **Phase 3 (Validation & Testing):** 1 hour\n- **Phase 4 (Delete useAnimateElement.ts):** 15 minutes\n- **Phase 5 (Future migrations):** Optional, ongoing\n\n**Total Time:** ~4 hours (conservative estimate)\n\n**Recommended Approach:** Do Phases 1-3 in one session, then validate overnight before Phase 4.\n\n---\n\n## Key Architectural Decisions\n\n### Decision 1: Manual Lifecycle Instead of `enterExit`\n\n**Why:**\n- `AnimatedFloatingElement` has complex mount/unmount coordination\n- `isVisible` ref is critical for `shouldRender` computed\n- Existing watch logic is proven and stable\n- `enterExit` pattern is designed for simple show/hide, not complex orchestration\n\n**Trade-off:**\n- More verbose code in the component\n- But: exact timing control, no surprises, easier debugging\n\n### Decision 2: Preserve `reverse()` Behavior\n\n**Why:**\n- Click-outside close needs seamless reverse animation\n- Native Web Animations API `reverse()` is perfect for this\n- Calling `animateOut()` would restart animation (visual stutter)\n\n**Implementation:**\n```typescript\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim && anim.playState === 'running') {\n    anim.reverse()\n    await anim.finished\n  } else {\n    await animateOut?.()\n  }\n}\n```\n\n### Decision 3: Add Missing Presets to `useAnimation.ts`, Not `useAnimateElement.ts`\n\n**Why:**\n- We're deleting `useAnimateElement.ts`, so adding presets there is wasted effort\n- Moving `animationPresets` into `useAnimation.ts` centralizes all animation config\n- Future presets will only need to be added in one place\n\n**Impact:**\n- Slightly larger `useAnimation.ts` file\n- But: single source of truth for all presets\n\n---\n\n## Additional Notes\n\n### Environment Detection Benefits\n\nAfter migration, all `AnimatedFloatingElement` instances automatically gain:\n\n1. **Battery Awareness**\n   - Animations scale duration by 0.3x on low battery (<20%)\n   - Critical UI (with `critical: true`) is unaffected\n   - Helps mobile users preserve battery life\n\n2. **Performance Adaptation**\n   - Animations scale duration by 0.6x when FPS <30\n   - Prevents jank on slow devices\n   - Maintains smooth feel on fast devices\n\n3. **Accessibility**\n   - Respects `prefers-reduced-motion` system setting\n   - Animations skip entirely, final state applied instantly\n   - Better experience for users with motion sensitivity\n\n4. **Idle Detection**\n   - Pauses non-critical animations after 5min inactivity\n   - Resumes when user returns\n   - Saves CPU/GPU on background tabs\n\n5. **Page Leave Detection**\n   - Pauses animations when tab is hidden\n   - Resumes when tab becomes visible\n   - Better battery usage in background tabs\n\n### Compatibility Matrix\n\n| Component | Before Migration | After Migration | Notes |\n|-----------|-----------------|-----------------|-------|\n| `AnimatedFloatingElement.vue` | Uses `useAnimateElement` | Uses `useAnimation` | Same API, better environment detection |\n| `AiConductorGraphicV2.vue` | Uses `AnimatedFloatingElement` | Uses `AnimatedFloatingElement` | Zero changes required |\n| `AIEnhancementTheater.vue` | Uses `useAnimation` directly | Uses `useAnimation` directly | Already uses new API |\n| `useAnimateElement.ts` | Exists | **DELETED** | Functionality merged into `useAnimation` |\n\n### Import Changes Summary\n\n**Before:**\n```typescript\nimport { useAnimateElement, animationPresets } from '@composables/useAnimateElement'\n```\n\n**After:**\n```typescript\nimport { useAnimation, animationPresets } from '@composables/useAnimation'\n```\n\n---\n\n## Final Validation Checklist\n\nBefore shipping to production:\n\n### Visual Checks\n- [ ] Conductor animation timing unchanged\n- [ ] Floating element fade-in smooth\n- [ ] Floating element fade-out smooth\n- [ ] Click-outside close reverses cleanly\n- [ ] Skip initial animation works instantly\n\n### Functional Checks\n- [ ] `v-model` updates correctly\n- [ ] All events fire in correct order\n- [ ] `isAnimating` reflects actual state\n- [ ] `isVisible` lifecycle matches legacy\n- [ ] `shouldRender` works correctly\n\n### Environment Checks\n- [ ] Low battery scales duration\n- [ ] Reduced motion skips animations\n- [ ] Low FPS scales duration\n- [ ] Idle pauses animations (non-critical)\n- [ ] Page leave pauses animations\n\n### Code Quality Checks\n- [ ] No TypeScript errors\n- [ ] No console warnings\n- [ ] Build succeeds\n- [ ] File size impact acceptable\n- [ ] No memory leaks (DevTools Memory profiler)\n\n---\n\n## Post-Migration Benefits\n\n1. **Unified Animation API**\n   - One composable for all animations\n   - Consistent patterns across codebase\n   - Easier onboarding for new developers\n\n2. **Better Performance**\n   - Automatic environment detection\n   - Adaptive duration scaling\n   - Lower CPU/GPU usage on slow devices\n\n3. **Improved Accessibility**\n   - Respects reduced motion preference\n   - Battery-aware on mobile devices\n   - Better idle/background behavior\n\n4. **Future-Proof**\n   - All new components use same API\n   - Easy to add new features (responsive, SVG, grid)\n   - Consistent upgrade path\n\n5. **Reduced Maintenance**\n   - One file to maintain instead of two\n   - Shared presets reduce duplication\n   - Centralized bug fixes\n\n---\n\n## Summary of Changes vs. Original Blocker Report\n\n### Original Blockers (FLOATING_REFACTOR_BLOCKERS.md)\n1. âŒ Missing exit presets (`fadeOut`, `scaleIn`, `scaleOut`)\n2. âŒ `enterExit` pattern doesn't create `animateIn`/`animateOut`\n3. âŒ `reverse()` mapped to `animateOut()` (not equivalent)\n4. âŒ `isVisible` lifecycle conflicts\n\n### This Plan's Solutions\n1. âœ… Add missing presets to `useAnimation.ts` (not `useAnimateElement.ts` - we're deleting it)\n2. âœ… Use manual lifecycle control (NOT `enterExit` pattern)\n3. âœ… Preserve `reverse()` using Web Animations API native `reverse()`\n4. âœ… Keep exact legacy `isVisible` lifecycle unchanged\n\n### New Critical Fixes (Post-Review)\n5. âœ… **Wrap `animateIn`/`animateOut` to track `isAnimating` state** (fixes slot consumer visibility)\n6. âœ… **Separate browser support check from environment throttling** (fixes low battery/FPS scaling)\n\n### Final Architecture\n```typescript\n// AnimatedFloatingElement.vue (after migration)\nconst animation = useAnimation(elementRef, {\n  animation: { preset, duration, easing },\n  autoplay: false,\n  respectEnvironment: true\n})\n\n// Manual isAnimating tracking (Fix #1)\nconst isAnimating = ref(false)\nconst wrappedAnimateIn = async () => {\n  try {\n    isAnimating.value = true\n    await animation.animateIn()\n  } finally {\n    isAnimating.value = false\n  }\n}\n\n// Browser capability check (Fix #2)\nconst isAnimationSupported = computed(() =>\n  animation.animate?.value !== undefined ||\n  typeof window !== 'undefined' && 'animate' in HTMLElement.prototype\n)\n\n// Preserve reverse() for click-outside\nconst reverse = async () => {\n  const anim = animation.animate?.value\n  if (anim?.playState === 'running') {\n    isAnimating.value = true\n    anim.reverse()\n    await anim.finished\n    isAnimating.value = false\n  } else {\n    await wrappedAnimateOut()\n  }\n}\n\n// Exact same lifecycle logic (lines 92-113 unchanged)\nwatch(() => props.modelValue, async (newValue, oldValue) => {\n  // Same as before - DO NOT CHANGE\n})\n```\n\n### Key Takeaways\n- âœ… Zero changes to `AnimatedFloatingElement.vue` public API\n- âœ… Zero changes to `AiConductorGraphicV2.vue` usage\n- âœ… Gains automatic environment detection (battery, FPS, reduced motion, idle, page leave)\n- âœ… Slot consumers get accurate `isAnimating` values\n- âœ… Environment throttling works correctly (scaled animations, not instant snaps)\n- âœ… Single animation composable to maintain (`useAnimateElement.ts` deleted)\n\n---\n\n**Ready to implement? Start with Phase 1, test thoroughly at each phase, and only proceed to Phase 4 (deletion) after confirming zero regressions and passing all critical fix validations.**\n","structuredPatch":[{"oldStart":8,"oldLines":6,"newStart":8,"newLines":29,"lines":[" "," ---"," ","+## Quick Reference for Implementers","+","+**TL;DR:** Migrate `AnimatedFloatingElement.vue` from `useAnimateElement` to `useAnimation`, then delete `useAnimateElement.ts`.","+","+### Two Critical Fixes Required","+1. **Wrap `animateIn`/`animateOut` to track `isAnimating`** - Fixes slot consumer visibility issues","+2. **Check browser support, not environment conditions** - Fixes low battery/FPS scaling","+","+### Implementation Checklist","+- [ ] Phase 1: Move `animationPresets` to `useAnimation.ts`, add missing presets (30min)","+- [ ] Phase 2: Migrate `AnimatedFloatingElement.vue` with wrapper functions (2hr)","+- [ ] Phase 3: Test critical fixes - `isAnimating` tracking & environment throttling (1hr)","+- [ ] Phase 4: Delete `useAnimateElement.ts` after zero regressions confirmed (15min)","+","+### Testing Priority","+1. **MUST PASS:** `AiConductorGraphicV2.vue` chat bubbles HIDDEN during enter/exit animations","+2. **MUST PASS:** Low battery/FPS runs scaled animations (NOT instant snaps)","+3. **MUST PASS:** Reduced motion skips animations correctly","+","+**Total Time:** ~4 hours | **Risk Level:** Medium (with proper testing) | **Rollback:** `git checkout HEAD -- [files]`","+","+---","+"," ## Critical Fixes Applied (vs. FLOATING_REFACTOR_BLOCKERS.md)"," "," ### Fix #1: `isAnimating` State Tracking"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"5cd47c11-5f63-4c91-b347-14c86bb8de70","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01KVLcGSwP1ZJNg7djtCQG1R","type":"message","role":"assistant","content":[{"type":"text","text":"Excellent! The plan is now complete with both critical fixes. Let me create a final summary:\n\n## Summary\n\nI've created **FLOATING_V2.md** - a comprehensive migration plan that resolves all blockers from the original report AND fixes two critical issues you identified:\n\n### Critical Fixes Applied\n\n**Fix #1: `isAnimating` State Tracking** âœ…\n- **Problem:** `useAnimation.isPlaying` only updates when `play()` is called, not `animateIn()`/`animateOut()`\n- **Impact:** `AiConductorGraphicV2.vue` slot consumers would always see `isFloatingAnimating=false`, showing chat bubbles during animations (visual regression)\n- **Solution:** Manually wrap `animateIn`/`animateOut` to track `isAnimating.value = true/false` in try/finally blocks\n\n**Fix #2: Browser Support vs Environment Throttling** âœ…\n- **Problem:** Using `animation.canAnimate` as browser support check short-circuits environment throttling (goes false for low battery/FPS)\n- **Impact:** Animations would snap instantly instead of running with scaled duration (breaks promised 30% battery scaling)\n- **Solution:** Separate check for Web Animations API availability: `animation.animate?.value !== undefined`\n\n### Migration Strategy\n\n1. **Phase 1 (30min):** Move `animationPresets` to `useAnimation.ts`, add missing presets (`fadeOut`, `scaleIn`, `scaleOut`)\n2. **Phase 2 (2hr):** Migrate `AnimatedFloatingElement.vue` with wrapper functions and proper support check\n3. **Phase 3 (1hr):** Test critical fixes - validate `isAnimating` tracking and environment throttling\n4. **Phase 4 (15min):** Delete `useAnimateElement.ts` after zero regressions confirmed\n\n### Key Architecture Decisions\n\n- âœ… Manual lifecycle control (NOT `enterExit` pattern)\n- âœ… Preserve exact `watch(() => props.modelValue)` logic unchanged\n- âœ… Native Web Animations API `reverse()` for click-outside\n- âœ… Wrapped `animateIn`/`animateOut` for accurate `isAnimating` state\n- âœ… Browser capability check separate from environment throttling\n\nThe plan includes comprehensive testing steps, rollback procedures, and a detailed validation checklist focused on the two critical fixes. Ready for implementation!"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1322,"cache_read_input_tokens":148974,"cache_creation":{"ephemeral_5m_input_tokens":1322,"ephemeral_1h_input_tokens":0},"output_tokens":571,"service_tier":"standard"}},"requestId":"req_011CTtoGhsbF5797sbporWdd","type":"assistant","uuid":"3a3cdf39-56b1-4dff-9bb9-fef7cf567b37","timestamp":"2025-10-08T00:39:13.570Z"}
{"type":"file-history-snapshot","messageId":"b805c81a-68cd-4b3c-9002-533649dc87d6","snapshot":{"messageId":"b805c81a-68cd-4b3c-9002-533649dc87d6","trackedFileBackups":{"FLOATING_V2.md":{"backupFileName":"31dfbdaea3fdd10b@v3","version":3,"backupTime":"2025-10-08T00:42:21.650Z"}},"timestamp":"2025-10-08T00:42:21.626Z"},"isSnapshotUpdate":false}
{"parentUuid":"3a3cdf39-56b1-4dff-9bb9-fef7cf567b37","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":"The new draft still has one blocker:\n\n  - FLOATING_V2.md:410-432 insists the watch(() => props.modelValue) block must\n    stay exactly as it is today, which keeps the animateIn() call unâ€‘awaited\n    and omits any animationComplete emission for the â€œenterâ€ path. But in the\n    same document you remove the onComplete hook and only recommend (Optionâ€¯B)\n    emitting inside the watcher after await animateIn() (FLOATING_V2.md:445-\n    486). If an implementer follows the â€œdo not change the watcherâ€ guidance,\n    animationComplete will never fire when skipInitial is falseâ€”regression for\n    every consumer.\n\n  Once you pick a single approach (e.g., commit to Optionâ€¯B and update the\n  watcher to await the wrapped animateIn() / animateOut() and emit the events\n  there, or wire the lifecycle hooks instead) the plan looks solid. Without that\n  clarification itâ€™s contradictory, so I wouldnâ€™t call it ready yet."},"uuid":"b805c81a-68cd-4b3c-9002-533649dc87d6","timestamp":"2025-10-08T00:42:21.607Z","thinkingMetadata":{"level":"none","disabled":true,"triggers":[]}}
{"parentUuid":"b805c81a-68cd-4b3c-9002-533649dc87d6","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"assistant","uuid":"7ff0420f-4411-407b-88ec-b18ac369e9f9","timestamp":"2025-10-08T00:42:22.962Z","message":{"id":"11d28086-5849-4c74-81c7-7a2c340981a0","container":null,"model":"<synthetic>","role":"assistant","stop_reason":"stop_sequence","stop_sequence":"","type":"message","usage":{"input_tokens":0,"output_tokens":0,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"server_tool_use":{"web_search_requests":0},"service_tier":null,"cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":0}},"content":[{"type":"text","text":"Weekly limit reached âˆ™ resets 2pm"}]},"isApiErrorMessage":true}
{"parentUuid":"7ff0420f-4411-407b-88ec-b18ac369e9f9","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"system","subtype":"local_command","content":"<command-name>/status</command-name>\n            <command-message>status</command-message>\n            <command-args></command-args>","level":"info","timestamp":"2025-10-08T19:26:24.106Z","uuid":"d2b67e1f-7ecb-4881-8958-49d5433ec35b","isMeta":false}
{"parentUuid":"d2b67e1f-7ecb-4881-8958-49d5433ec35b","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"80aa6e6f-6db1-475d-8fdf-ee5385864fce","version":"2.0.9","gitBranch":"feat-landing-docs","type":"system","subtype":"local_command","content":"<local-command-stdout>Status dialog dismissed</local-command-stdout>","level":"info","timestamp":"2025-10-08T19:26:24.106Z","uuid":"487eb2f0-88df-44ff-b16e-c596573bfabc","isMeta":false}
{"type":"file-history-snapshot","messageId":"2db427f7-384b-4913-8b08-8e89bb8fbc09","snapshot":{"messageId":"2db427f7-384b-4913-8b08-8e89bb8fbc09","trackedFileBackups":{"FLOATING_V2.md":{"backupFileName":"31dfbdaea3fdd10b@v4","version":4,"backupTime":"2025-10-08T19:26:27.158Z"}},"timestamp":"2025-10-08T19:26:27.131Z"},"isSnapshotUpdate":false}
