{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"system","subtype":"local_command","content":"<command-name>/mcp</command-name>\n            <command-message>mcp</command-message>\n            <command-args></command-args>","level":"info","timestamp":"2025-10-09T00:04:18.888Z","uuid":"9de46d56-8908-4f24-8bcd-37e34bd483a9","isMeta":false}
{"parentUuid":"9de46d56-8908-4f24-8bcd-37e34bd483a9","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"system","subtype":"local_command","content":"<local-command-stdout>MCP dialog dismissed</local-command-stdout>","level":"info","timestamp":"2025-10-09T00:04:18.888Z","uuid":"dfc7b91a-b445-4d50-b52c-5e52659c48ce","isMeta":false}
{"type":"file-history-snapshot","messageId":"f1b98fa3-75d3-4625-9a6e-88f9c08b658f","snapshot":{"messageId":"f1b98fa3-75d3-4625-9a6e-88f9c08b658f","trackedFileBackups":{},"timestamp":"2025-10-09T00:04:24.741Z"},"isSnapshotUpdate":false}
{"parentUuid":"dfc7b91a-b445-4d50-b52c-5e52659c48ce","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":"Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."},"isMeta":true,"uuid":"f182b093-7cce-41b7-914f-52b939d6e1cc","timestamp":"2025-10-09T00:04:24.734Z"}
{"parentUuid":"f182b093-7cce-41b7-914f-52b939d6e1cc","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":"<command-name>/context</command-name>\n            <command-message>context</command-message>\n            <command-args></command-args>"},"uuid":"f1b98fa3-75d3-4625-9a6e-88f9c08b658f","timestamp":"2025-10-09T00:04:23.705Z"}
{"parentUuid":"f1b98fa3-75d3-4625-9a6e-88f9c08b658f","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":"<local-command-stdout>\u001b[?2026h\u001b[?2026l\u001b[?2026h\u001b[?2026l\n \u001b[1mContext Usage\u001b[22m\n\u001b[38;2;136;136;136m⛁ ⛁ ⛁ ⛁ ⛁ ⛁ \u001b[38;2;153;153;153m⛁ ⛁ ⛁ ⛁ \u001b[39m  \u001b[2mclaude-sonnet-4-5-20250929 · 46k/200k tokens (23%)\u001b[22m\n\u001b[38;2;153;153;153m⛁ ⛁ ⛁ ⛀ \u001b[38;2;8;145;178m⛁ ⛁ \u001b[38;2;177;185;249m⛁ \u001b[38;2;215;119;87m⛁ ⛁ ⛁ \u001b[39m\n\u001b[38;2;215;119;87m⛁ ⛁ ⛁ ⛁ \u001b[38;2;147;51;234m⛀ \u001b[39m\u001b[2m⛶ ⛶ ⛶ ⛶ ⛶ \u001b[22m  \u001b[38;2;136;136;136m⛁\u001b[39m System prompt: \u001b[2m11.6k tokens (5.8%)\u001b[22m\n\u001b[2m⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ \u001b[22m  \u001b[38;2;153;153;153m⛁\u001b[39m System tools: \u001b[2m15.3k tokens (7.6%)\u001b[22m\n\u001b[2m⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ \u001b[22m  \u001b[38;2;8;145;178m⛁\u001b[39m MCP tools: \u001b[2m4.1k tokens (2.1%)\u001b[22m\n\u001b[2m⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ \u001b[22m  \u001b[38;2;177;185;249m⛁\u001b[39m Custom agents: \u001b[2m2.0k tokens (1.0%)\u001b[22m\n\u001b[2m⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ \u001b[22m  \u001b[38;2;215;119;87m⛁\u001b[39m Memory files: \u001b[2m13.4k tokens (6.7%)\u001b[22m\n\u001b[2m⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ \u001b[22m  \u001b[38;2;147;51;234m⛁\u001b[39m Messages: \u001b[2m8 tokens (0.0%)\u001b[22m\n\u001b[2m⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ \u001b[22m  \u001b[2m⛶\u001b[22m Free space: \u001b[2m154k (76.8%)\u001b[22m\n\u001b[2m⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ ⛶ \u001b[22m\n\n\u001b[1mMCP tools\u001b[2m · /mcp\u001b[22m\n└ mcp__gemini-cli__ask-gemini (gemini-cli): \u001b[2m814 tokens\u001b[22m\n└ mcp__gemini-cli__ping (gemini-cli): \u001b[2m569 tokens\u001b[22m\n└ mcp__gemini-cli__Help (gemini-cli): \u001b[2m551 tokens\u001b[22m\n└ mcp__gemini-cli__brainstorm (gemini-cli): \u001b[2m983 tokens\u001b[22m\n└ mcp__gemini-cli__fetch-chunk (gemini-cli): \u001b[2m640 tokens\u001b[22m\n└ mcp__gemini-cli__timeout-test (gemini-cli): \u001b[2m589 tokens\u001b[22m\n\n\u001b[1mCustom agents\u001b[2m · /agents\u001b[22m\n└ service-documentation (Project): \u001b[2m74 tokens\u001b[22m\n└ web-researcher (Project): \u001b[2m21 tokens\u001b[22m\n└ astro-vue-ux (Project): \u001b[2m98 tokens\u001b[22m\n└ insight-extractor (User): \u001b[2m47 tokens\u001b[22m\n└ astro-vue-architect (Project): \u001b[2m411 tokens\u001b[22m\n└ problem-decomposer-orchestrator (Project): \u001b[2m461 tokens\u001b[22m\n└ code-review (Project): \u001b[2m87 tokens\u001b[22m\n└ web-scraper (User): \u001b[2m101 tokens\u001b[22m\n└ python-architect (Project): \u001b[2m105 tokens\u001b[22m\n└ logging (Project): \u001b[2m34 tokens\u001b[22m\n└ taskmaster (Project): \u001b[2m81 tokens\u001b[22m\n└ doc-searcher (User): \u001b[2m43 tokens\u001b[22m\n└ web-research-orchestrator (Project): \u001b[2m25 tokens\u001b[22m\n└ browser-automation (User): \u001b[2m82 tokens\u001b[22m\n└ github-docs-researcher (User): \u001b[2m77 tokens\u001b[22m\n└ minimal-change-analyzer (Project): \u001b[2m97 tokens\u001b[22m\n└ typescript-master (Project): \u001b[2m104 tokens\u001b[22m\n└ knowledge-organizer (User): \u001b[2m42 tokens\u001b[22m\n\n\u001b[1mMemory files\u001b[2m · /memory\u001b[22m\n└ User (/Users/natedamstra/.claude/CLAUDE.md): \u001b[2m581 tokens\u001b[22m\n└ Project (/Users/natedamstra/CLAUDE.md): \u001b[2m2.7k tokens\u001b[22m\n└ Project (/Users/natedamstra/socialaize/CLAUDE.md): \u001b[2m10.1k tokens\u001b[22m\n\n\u001b[1mSlashCommand Tool\u001b[2m · 20 commands\u001b[22m\n└ Total: \u001b[2m1.7k tokens\u001b[22m\n\n</local-command-stdout>"},"uuid":"18ceb80d-9384-4aa1-80ba-d312c98f8028","timestamp":"2025-10-09T00:04:24.734Z"}
{"type":"file-history-snapshot","messageId":"c106adea-dbec-425d-8e5d-ce26cfe13da4","snapshot":{"messageId":"c106adea-dbec-425d-8e5d-ce26cfe13da4","trackedFileBackups":{},"timestamp":"2025-10-09T00:05:13.791Z"},"isSnapshotUpdate":false}
{"parentUuid":"18ceb80d-9384-4aa1-80ba-d312c98f8028","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":"Review @src/components/composables/useAnimation.ts . there's a lot of type errors in this file. create a plan to fix everyone of them "},"uuid":"c106adea-dbec-425d-8e5d-ce26cfe13da4","timestamp":"2025-10-09T00:05:13.778Z","thinkingMetadata":{"level":"none","disabled":true,"triggers":[]}}
{"parentUuid":"c106adea-dbec-425d-8e5d-ce26cfe13da4","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01MmyAMwLpoSBAYGzCGjCToQ","type":"message","role":"assistant","content":[{"type":"text","text":"I'll analyze the useAnimation.ts file for type errors and create a comprehensive plan to fix them."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":80896,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":80896,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CTveWSxFxe1EWZeYZ1kzn","type":"assistant","uuid":"079e44e8-dfa8-486e-ad9e-8720d3d77157","timestamp":"2025-10-09T00:05:19.288Z"}
{"parentUuid":"079e44e8-dfa8-486e-ad9e-8720d3d77157","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01MmyAMwLpoSBAYGzCGjCToQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018pZ3vdRmi2JGPRk1xmUvUY","name":"Bash","input":{"command":"npm run typecheck 2>&1 | grep -A 5 \"useAnimation.ts\" | head -100","description":"Run typecheck to identify errors in useAnimation.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":80896,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":80896,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CTveWSxFxe1EWZeYZ1kzn","type":"assistant","uuid":"24a7369a-64f1-4396-b375-ef3992931a0b","timestamp":"2025-10-09T00:05:20.461Z"}
{"parentUuid":"24a7369a-64f1-4396-b375-ef3992931a0b","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018pZ3vdRmi2JGPRk1xmUvUY","type":"tool_result","content":"\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m2027\u001b[0m:\u001b[93m53\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelectorAll' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'querySelectorAll' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m2027\u001b[0m         staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n\u001b[7m    \u001b[0m \u001b[91m                                                    ~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1953\u001b[0m:\u001b[93m58\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'innerHeight' does not exist on type 'never'.\n\n\u001b[7m1953\u001b[0m         ? document.documentElement.scrollHeight - window.innerHeight\n\u001b[7m    \u001b[0m \u001b[91m                                                         ~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1952\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2367): \u001b[0mThis comparison appears to be unintentional because the types 'HTMLElement' and 'Window & typeof globalThis' have no overlap.\n\n\u001b[7m1952\u001b[0m       const scrollHeight = container === window\n\u001b[7m    \u001b[0m \u001b[91m                           ~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1949\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'Ref<HTMLElement | undefined, HTMLElement | undefined> | Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to parameter of type 'MaybeRef<HTMLElement | undefined> | ComputedRef<HTMLElement | undefined>'.\n  Type 'Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to type 'MaybeRef<HTMLElement | undefined> | ComputedRef<HTMLElement | undefined>'.\n\n\u001b[7m1949\u001b[0m       const container = unref(scrollContainer)\n\u001b[7m    \u001b[0m \u001b[91m                              ~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1924\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2739): \u001b[0mType 'Ref<TElement, TElement> & { [ShallowRefMarker]?: true | undefined; }' is missing the following properties from type 'ComputedRef<TElement | undefined>': effect, [ComputedRefSymbol]\n\n\u001b[7m1924\u001b[0m       currentElement,\n\u001b[7m    \u001b[0m \u001b[91m      ~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1721\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2322): \u001b[0mType 'Timeout' is not assignable to type 'number'.\n\n\u001b[7m1721\u001b[0m       activeProgressInterval.value = progressInterval\n\u001b[7m    \u001b[0m \u001b[91m      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1716\u001b[0m:\u001b[93m52\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2362): \u001b[0mThe left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n\n\u001b[7m1716\u001b[0m           const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n\u001b[7m    \u001b[0m \u001b[91m                                                   ~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1670\u001b[0m:\u001b[93m21\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\n\u001b[7m1670\u001b[0m       if (timeline) resumeTimeline()\n\u001b[7m    \u001b[0m \u001b[91m                    ~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1669\u001b[0m:\u001b[93m32\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\n\u001b[7m1669\u001b[0m       if (motionPathAnimation) resumeMotion()\n\u001b[7m    \u001b[0m \u001b[91m                               ~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1668\u001b[0m:\u001b[93m26\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\n\u001b[7m1668\u001b[0m       if (timedSequence) resumeSequence()\n\u001b[7m    \u001b[0m \u001b[91m                         ~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1625\u001b[0m:\u001b[93m19\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\n\u001b[7m1625\u001b[0m     if (timeline) pauseTimeline()\n\u001b[7m    \u001b[0m \u001b[91m                  ~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1624\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\n\u001b[7m1624\u001b[0m     if (motionPathAnimation) pauseMotion()\n\u001b[7m    \u001b[0m \u001b[91m                             ~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1623\u001b[0m:\u001b[93m24\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\n\u001b[7m1623\u001b[0m     if (timedSequence) pauseSequence()\n\u001b[7m    \u001b[0m \u001b[91m                       ~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1539\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'animate' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1539\u001b[0m         const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n\u001b[7m    \u001b[0m \u001b[91m                             ~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1516\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'style' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1516\u001b[0m           Object.assign(element.style, finalFrame)\n\u001b[7m    \u001b[0m \u001b[91m                                ~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1515\u001b[0m:\u001b[93m59\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'length' does not exist on type 'Keyframe[] | PropertyIndexedKeyframes | Ref<Keyframe[] | PropertyIndexedKeyframes | null, Keyframe[] | PropertyIndexedKeyframes | null> | ShallowRef<...> | WritableComputedRef<...>'.\n  Property 'length' does not exist on type 'Ref<Keyframe[] | PropertyIndexedKeyframes | null, Keyframe[] | PropertyIndexedKeyframes | null>'.\n\n\u001b[7m1515\u001b[0m           const finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>\n\u001b[7m    \u001b[0m \u001b[91m                                                          ~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1515\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(7053): \u001b[0mElement implicitly has an 'any' type because expression of type 'number' can't be used to index type 'Keyframe[] | PropertyIndexedKeyframes | Ref<Keyframe[] | PropertyIndexedKeyframes | null, Keyframe[] | PropertyIndexedKeyframes | null> | ShallowRef<...> | WritableComputedRef<...>'.\n  No index signature with a parameter of type 'number' was found on type 'Keyframe[] | PropertyIndexedKeyframes | Ref<Keyframe[] | PropertyIndexedKeyframes | null, Keyframe[] | PropertyIndexedKeyframes | null> | ShallowRef<...> | WritableComputedRef<...>'.\n\n\u001b[7m1515\u001b[0m           const finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>\n\u001b[7m    \u001b[0m \u001b[91m                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1493\u001b[0m:\u001b[93m40\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'animate' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1493\u001b[0m           const newAnimation = element.animate(customKeyframes as Keyframe[], {\n\u001b[7m    \u001b[0m \u001b[91m                                       ~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1483\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'style' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1483\u001b[0m           Object.assign(element.style, finalFrame)\n\u001b[7m    \u001b[0m \u001b[91m                                ~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1379\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'ComputedRef<HTMLElement | (() => HTMLElement | undefined) | undefined>' is not assignable to parameter of type 'MaybeComputedElementRef<MaybeElement>'.\n  Type 'ComputedRef<HTMLElement | (() => HTMLElement | undefined) | undefined>' is not assignable to type 'ComputedRef<MaybeElement>'.\n\n\u001b[7m1379\u001b[0m     ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n\u001b[7m    \u001b[0m \u001b[91m                           ~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1258\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelector' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'querySelector' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1258\u001b[0m       const zoneEl = targetEl.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n\u001b[7m    \u001b[0m \u001b[91m                              ~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1160\u001b[0m:\u001b[93m29\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'getBoundingClientRect' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'getBoundingClientRect' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1160\u001b[0m       const rect = targetEl.getBoundingClientRect()\n\u001b[7m    \u001b[0m \u001b[91m                            ~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1082\u001b[0m:\u001b[93m19\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2352): \u001b[0mConversion of type '{ contentRect: any; target: HTMLElement | (() => HTMLElement | undefined); }' to type 'ResizeObserverEntry' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.","is_error":false}]},"uuid":"620aa9e8-b2b3-46d4-8b38-3bfd820dad2d","timestamp":"2025-10-09T00:05:55.217Z","toolUseResult":{"stdout":"\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m2027\u001b[0m:\u001b[93m53\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelectorAll' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'querySelectorAll' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m2027\u001b[0m         staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n\u001b[7m    \u001b[0m \u001b[91m                                                    ~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1953\u001b[0m:\u001b[93m58\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'innerHeight' does not exist on type 'never'.\n\n\u001b[7m1953\u001b[0m         ? document.documentElement.scrollHeight - window.innerHeight\n\u001b[7m    \u001b[0m \u001b[91m                                                         ~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1952\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2367): \u001b[0mThis comparison appears to be unintentional because the types 'HTMLElement' and 'Window & typeof globalThis' have no overlap.\n\n\u001b[7m1952\u001b[0m       const scrollHeight = container === window\n\u001b[7m    \u001b[0m \u001b[91m                           ~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1949\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'Ref<HTMLElement | undefined, HTMLElement | undefined> | Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to parameter of type 'MaybeRef<HTMLElement | undefined> | ComputedRef<HTMLElement | undefined>'.\n  Type 'Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to type 'MaybeRef<HTMLElement | undefined> | ComputedRef<HTMLElement | undefined>'.\n\n\u001b[7m1949\u001b[0m       const container = unref(scrollContainer)\n\u001b[7m    \u001b[0m \u001b[91m                              ~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1924\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2739): \u001b[0mType 'Ref<TElement, TElement> & { [ShallowRefMarker]?: true | undefined; }' is missing the following properties from type 'ComputedRef<TElement | undefined>': effect, [ComputedRefSymbol]\n\n\u001b[7m1924\u001b[0m       currentElement,\n\u001b[7m    \u001b[0m \u001b[91m      ~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1721\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2322): \u001b[0mType 'Timeout' is not assignable to type 'number'.\n\n\u001b[7m1721\u001b[0m       activeProgressInterval.value = progressInterval\n\u001b[7m    \u001b[0m \u001b[91m      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1716\u001b[0m:\u001b[93m52\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2362): \u001b[0mThe left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n\n\u001b[7m1716\u001b[0m           const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n\u001b[7m    \u001b[0m \u001b[91m                                                   ~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1670\u001b[0m:\u001b[93m21\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\n\u001b[7m1670\u001b[0m       if (timeline) resumeTimeline()\n\u001b[7m    \u001b[0m \u001b[91m                    ~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1669\u001b[0m:\u001b[93m32\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\n\u001b[7m1669\u001b[0m       if (motionPathAnimation) resumeMotion()\n\u001b[7m    \u001b[0m \u001b[91m                               ~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1668\u001b[0m:\u001b[93m26\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\n\u001b[7m1668\u001b[0m       if (timedSequence) resumeSequence()\n\u001b[7m    \u001b[0m \u001b[91m                         ~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1625\u001b[0m:\u001b[93m19\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\n\u001b[7m1625\u001b[0m     if (timeline) pauseTimeline()\n\u001b[7m    \u001b[0m \u001b[91m                  ~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1624\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\n\u001b[7m1624\u001b[0m     if (motionPathAnimation) pauseMotion()\n\u001b[7m    \u001b[0m \u001b[91m                             ~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1623\u001b[0m:\u001b[93m24\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\n\u001b[7m1623\u001b[0m     if (timedSequence) pauseSequence()\n\u001b[7m    \u001b[0m \u001b[91m                       ~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1539\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'animate' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1539\u001b[0m         const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n\u001b[7m    \u001b[0m \u001b[91m                             ~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1516\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'style' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1516\u001b[0m           Object.assign(element.style, finalFrame)\n\u001b[7m    \u001b[0m \u001b[91m                                ~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1515\u001b[0m:\u001b[93m59\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'length' does not exist on type 'Keyframe[] | PropertyIndexedKeyframes | Ref<Keyframe[] | PropertyIndexedKeyframes | null, Keyframe[] | PropertyIndexedKeyframes | null> | ShallowRef<...> | WritableComputedRef<...>'.\n  Property 'length' does not exist on type 'Ref<Keyframe[] | PropertyIndexedKeyframes | null, Keyframe[] | PropertyIndexedKeyframes | null>'.\n\n\u001b[7m1515\u001b[0m           const finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>\n\u001b[7m    \u001b[0m \u001b[91m                                                          ~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1515\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(7053): \u001b[0mElement implicitly has an 'any' type because expression of type 'number' can't be used to index type 'Keyframe[] | PropertyIndexedKeyframes | Ref<Keyframe[] | PropertyIndexedKeyframes | null, Keyframe[] | PropertyIndexedKeyframes | null> | ShallowRef<...> | WritableComputedRef<...>'.\n  No index signature with a parameter of type 'number' was found on type 'Keyframe[] | PropertyIndexedKeyframes | Ref<Keyframe[] | PropertyIndexedKeyframes | null, Keyframe[] | PropertyIndexedKeyframes | null> | ShallowRef<...> | WritableComputedRef<...>'.\n\n\u001b[7m1515\u001b[0m           const finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>\n\u001b[7m    \u001b[0m \u001b[91m                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1493\u001b[0m:\u001b[93m40\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'animate' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1493\u001b[0m           const newAnimation = element.animate(customKeyframes as Keyframe[], {\n\u001b[7m    \u001b[0m \u001b[91m                                       ~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1483\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'style' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1483\u001b[0m           Object.assign(element.style, finalFrame)\n\u001b[7m    \u001b[0m \u001b[91m                                ~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1379\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'ComputedRef<HTMLElement | (() => HTMLElement | undefined) | undefined>' is not assignable to parameter of type 'MaybeComputedElementRef<MaybeElement>'.\n  Type 'ComputedRef<HTMLElement | (() => HTMLElement | undefined) | undefined>' is not assignable to type 'ComputedRef<MaybeElement>'.\n\n\u001b[7m1379\u001b[0m     ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n\u001b[7m    \u001b[0m \u001b[91m                           ~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1258\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelector' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'querySelector' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1258\u001b[0m       const zoneEl = targetEl.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n\u001b[7m    \u001b[0m \u001b[91m                              ~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1160\u001b[0m:\u001b[93m29\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'getBoundingClientRect' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'getBoundingClientRect' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1160\u001b[0m       const rect = targetEl.getBoundingClientRect()\n\u001b[7m    \u001b[0m \u001b[91m                            ~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1082\u001b[0m:\u001b[93m19\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2352): \u001b[0mConversion of type '{ contentRect: any; target: HTMLElement | (() => HTMLElement | undefined); }' to type 'ResizeObserverEntry' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"620aa9e8-b2b3-46d4-8b38-3bfd820dad2d","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012QEgH7ZUSCBEnqZorg5yaU","type":"message","role":"assistant","content":[{"type":"text","text":"Let me get more type errors:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":3663,"cache_read_input_tokens":80896,"cache_creation":{"ephemeral_5m_input_tokens":3663,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTveZYicTLzyYdeJETAAX","type":"assistant","uuid":"49e73898-10b7-4be4-8797-bce4ddae4665","timestamp":"2025-10-09T00:05:59.868Z"}
{"parentUuid":"49e73898-10b7-4be4-8797-bce4ddae4665","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012QEgH7ZUSCBEnqZorg5yaU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013LHy4C54GD7dMhQerrpdS7","name":"Bash","input":{"command":"npm run typecheck 2>&1 | grep \"useAnimation.ts\" | wc -l","description":"Count total type errors in useAnimation.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":3663,"cache_read_input_tokens":80896,"cache_creation":{"ephemeral_5m_input_tokens":3663,"ephemeral_1h_input_tokens":0},"output_tokens":106,"service_tier":"standard"}},"requestId":"req_011CTveZYicTLzyYdeJETAAX","type":"assistant","uuid":"96c12372-5e28-4e6e-a6f5-7ada30876db2","timestamp":"2025-10-09T00:06:00.856Z"}
{"parentUuid":"96c12372-5e28-4e6e-a6f5-7ada30876db2","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013LHy4C54GD7dMhQerrpdS7","type":"tool_result","content":"      26","is_error":false}]},"uuid":"3c0e4498-7407-4850-93ee-90b68a143e02","timestamp":"2025-10-09T00:06:35.986Z","toolUseResult":{"stdout":"      26","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"3c0e4498-7407-4850-93ee-90b68a143e02","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_014jgJq1TNfGqLKVpksiHUGG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VFbpiPqs5sLBXVfMyjeQHo","name":"Bash","input":{"command":"npm run typecheck 2>&1 | grep \"useAnimation.ts\"","description":"Get all type errors from useAnimation.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":357,"cache_read_input_tokens":84559,"cache_creation":{"ephemeral_5m_input_tokens":357,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard"}},"requestId":"req_011CTvecZ4n4ht3JkLm9L71J","type":"assistant","uuid":"fc8cf006-1f94-4c4f-b277-068715bc7446","timestamp":"2025-10-09T00:06:40.742Z"}
{"parentUuid":"fc8cf006-1f94-4c4f-b277-068715bc7446","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VFbpiPqs5sLBXVfMyjeQHo","type":"tool_result","content":"\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m2027\u001b[0m:\u001b[93m53\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelectorAll' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1953\u001b[0m:\u001b[93m58\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'innerHeight' does not exist on type 'never'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1952\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2367): \u001b[0mThis comparison appears to be unintentional because the types 'HTMLElement' and 'Window & typeof globalThis' have no overlap.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1949\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'Ref<HTMLElement | undefined, HTMLElement | undefined> | Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to parameter of type 'MaybeRef<HTMLElement | undefined> | ComputedRef<HTMLElement | undefined>'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1924\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2739): \u001b[0mType 'Ref<TElement, TElement> & { [ShallowRefMarker]?: true | undefined; }' is missing the following properties from type 'ComputedRef<TElement | undefined>': effect, [ComputedRefSymbol]\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1721\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2322): \u001b[0mType 'Timeout' is not assignable to type 'number'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1716\u001b[0m:\u001b[93m52\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2362): \u001b[0mThe left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1670\u001b[0m:\u001b[93m21\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1669\u001b[0m:\u001b[93m32\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1668\u001b[0m:\u001b[93m26\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1625\u001b[0m:\u001b[93m19\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1624\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1623\u001b[0m:\u001b[93m24\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1539\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1516\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1515\u001b[0m:\u001b[93m59\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'length' does not exist on type 'Keyframe[] | PropertyIndexedKeyframes | Ref<Keyframe[] | PropertyIndexedKeyframes | null, Keyframe[] | PropertyIndexedKeyframes | null> | ShallowRef<...> | WritableComputedRef<...>'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1515\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(7053): \u001b[0mElement implicitly has an 'any' type because expression of type 'number' can't be used to index type 'Keyframe[] | PropertyIndexedKeyframes | Ref<Keyframe[] | PropertyIndexedKeyframes | null, Keyframe[] | PropertyIndexedKeyframes | null> | ShallowRef<...> | WritableComputedRef<...>'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1493\u001b[0m:\u001b[93m40\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1483\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1379\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'ComputedRef<HTMLElement | (() => HTMLElement | undefined) | undefined>' is not assignable to parameter of type 'MaybeComputedElementRef<MaybeElement>'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1258\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelector' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1160\u001b[0m:\u001b[93m29\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'getBoundingClientRect' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1082\u001b[0m:\u001b[93m19\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2352): \u001b[0mConversion of type '{ contentRect: any; target: HTMLElement | (() => HTMLElement | undefined); }' to type 'ResizeObserverEntry' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1079\u001b[0m:\u001b[93m37\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'getBoundingClientRect' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1076\u001b[0m:\u001b[93m38\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'HTMLElement | (() => HTMLElement | undefined)' is not assignable to parameter of type 'Element'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m322\u001b[0m:\u001b[93m21\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.","is_error":false}]},"uuid":"48d31662-91ca-4661-9a9b-f9fe482891c2","timestamp":"2025-10-09T00:07:14.274Z","toolUseResult":{"stdout":"\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m2027\u001b[0m:\u001b[93m53\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelectorAll' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1953\u001b[0m:\u001b[93m58\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'innerHeight' does not exist on type 'never'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1952\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2367): \u001b[0mThis comparison appears to be unintentional because the types 'HTMLElement' and 'Window & typeof globalThis' have no overlap.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1949\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'Ref<HTMLElement | undefined, HTMLElement | undefined> | Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to parameter of type 'MaybeRef<HTMLElement | undefined> | ComputedRef<HTMLElement | undefined>'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1924\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2739): \u001b[0mType 'Ref<TElement, TElement> & { [ShallowRefMarker]?: true | undefined; }' is missing the following properties from type 'ComputedRef<TElement | undefined>': effect, [ComputedRefSymbol]\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1721\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2322): \u001b[0mType 'Timeout' is not assignable to type 'number'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1716\u001b[0m:\u001b[93m52\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2362): \u001b[0mThe left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1670\u001b[0m:\u001b[93m21\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1669\u001b[0m:\u001b[93m32\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1668\u001b[0m:\u001b[93m26\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1625\u001b[0m:\u001b[93m19\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1624\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1623\u001b[0m:\u001b[93m24\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2722): \u001b[0mCannot invoke an object which is possibly 'undefined'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1539\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1516\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1515\u001b[0m:\u001b[93m59\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'length' does not exist on type 'Keyframe[] | PropertyIndexedKeyframes | Ref<Keyframe[] | PropertyIndexedKeyframes | null, Keyframe[] | PropertyIndexedKeyframes | null> | ShallowRef<...> | WritableComputedRef<...>'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1515\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(7053): \u001b[0mElement implicitly has an 'any' type because expression of type 'number' can't be used to index type 'Keyframe[] | PropertyIndexedKeyframes | Ref<Keyframe[] | PropertyIndexedKeyframes | null, Keyframe[] | PropertyIndexedKeyframes | null> | ShallowRef<...> | WritableComputedRef<...>'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1493\u001b[0m:\u001b[93m40\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1483\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1379\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'ComputedRef<HTMLElement | (() => HTMLElement | undefined) | undefined>' is not assignable to parameter of type 'MaybeComputedElementRef<MaybeElement>'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1258\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelector' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1160\u001b[0m:\u001b[93m29\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'getBoundingClientRect' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1082\u001b[0m:\u001b[93m19\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2352): \u001b[0mConversion of type '{ contentRect: any; target: HTMLElement | (() => HTMLElement | undefined); }' to type 'ResizeObserverEntry' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1079\u001b[0m:\u001b[93m37\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'getBoundingClientRect' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1076\u001b[0m:\u001b[93m38\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'HTMLElement | (() => HTMLElement | undefined)' is not assignable to parameter of type 'Element'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m322\u001b[0m:\u001b[93m21\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"48d31662-91ca-4661-9a9b-f9fe482891c2","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01UwtrGQvTgtanUVW3kWCuWK","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me analyze the root cause of these errors by examining the type definitions:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":2528,"cache_read_input_tokens":84916,"cache_creation":{"ephemeral_5m_input_tokens":2528,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvefNtvxfYP3kCPucLvb","type":"assistant","uuid":"e2502679-58ce-4d62-a9e7-703b0513d54c","timestamp":"2025-10-09T00:07:18.809Z"}
{"parentUuid":"e2502679-58ce-4d62-a9e7-703b0513d54c","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01UwtrGQvTgtanUVW3kWCuWK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BJ5Wm4gbwVH1Q3NonvyNNk","name":"Grep","input":{"pattern":"MaybeRefOrGetter","path":"src/components/composables/useAnimation.ts","output_mode":"content","-n":true,"-C":2}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":2528,"cache_read_input_tokens":84916,"cache_creation":{"ephemeral_5m_input_tokens":2528,"ephemeral_1h_input_tokens":0},"output_tokens":157,"service_tier":"standard"}},"requestId":"req_011CTvefNtvxfYP3kCPucLvb","type":"assistant","uuid":"768a3f22-bb16-4ef4-8127-6c3f1fa972dc","timestamp":"2025-10-09T00:07:20.223Z"}
{"parentUuid":"768a3f22-bb16-4ef4-8127-6c3f1fa972dc","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BJ5Wm4gbwVH1Q3NonvyNNk","type":"tool_result","content":"15-  useScroll,\n16-  type EventBusKey,\n17:  type MaybeRefOrGetter,\n18-  type UseAnimateKeyframes,\n19-  type UseAnimateOptions,\n--\n278-\n279-export function createAnimation(\n280:  target: MaybeRefOrGetter<HTMLElement | undefined>,\n281-  options: CreateAnimationOptions\n282-): CreateAnimationReturn {\n--\n874- */\n875-export function useAnimation<TState = any, TElement = any>(\n876:  target: MaybeRefOrGetter<HTMLElement | undefined>,\n877-  options: UseAnimationOptions<TElement> = {}\n878-): UseAnimationReturn<TState, TElement> {"}]},"uuid":"247685cf-1f06-4b4a-88c5-7204a735bcf0","timestamp":"2025-10-09T00:07:20.319Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"15-  useScroll,\n16-  type EventBusKey,\n17:  type MaybeRefOrGetter,\n18-  type UseAnimateKeyframes,\n19-  type UseAnimateOptions,\n--\n278-\n279-export function createAnimation(\n280:  target: MaybeRefOrGetter<HTMLElement | undefined>,\n281-  options: CreateAnimationOptions\n282-): CreateAnimationReturn {\n--\n874- */\n875-export function useAnimation<TState = any, TElement = any>(\n876:  target: MaybeRefOrGetter<HTMLElement | undefined>,\n877-  options: UseAnimationOptions<TElement> = {}\n878-): UseAnimationReturn<TState, TElement> {","numLines":17}}
{"parentUuid":"247685cf-1f06-4b4a-88c5-7204a735bcf0","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015LGUXDP5HTsESXPU2Jh6av","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! I've identified all 26 type errors. Now I'll create a comprehensive plan to fix them."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":676,"cache_read_input_tokens":87444,"cache_creation":{"ephemeral_5m_input_tokens":676,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvefp3WuSWjfjH143T1S","type":"assistant","uuid":"542c257a-6c10-44e1-a75d-bb97f4a8a00f","timestamp":"2025-10-09T00:07:25.458Z"}
{"parentUuid":"542c257a-6c10-44e1-a75d-bb97f4a8a00f","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015LGUXDP5HTsESXPU2Jh6av","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FHo3a4e1d1spnnUb7aq3Cc","name":"ExitPlanMode","input":{"plan":"# Type Error Fix Plan for useAnimation.ts\n\n## Root Cause Analysis\nThe file has **26 type errors** caused by:\n1. **Primary issue**: `MaybeRefOrGetter<T>` accepts `T | Ref<T> | (() => T)`, but code treats it as `T` directly\n2. **Secondary issues**: Missing type narrowing, incorrect type conversions, and nullable function guards\n\n## Categorized Fixes\n\n### Category 1: Element Access Pattern (12 errors)\n**Lines**: 322, 1076, 1079, 1160, 1258, 1483, 1493, 1516, 1539, 2027\n\n**Problem**: Accessing properties on `HTMLElement | (() => HTMLElement | undefined)` without unwrapping\n\n**Fix Strategy**: Consistent use of `unref(target)` before accessing DOM properties\n- Add null checks after `unref()`\n- Use type guard pattern: `if (!el) return`\n\n### Category 2: Scroll Container Window Type (4 errors)\n**Lines**: 1949, 1952, 1953, 1379\n\n**Problem**: `useScroll()` expects `Ref<HTMLElement>` but receives `Ref<Window | HTMLElement | undefined>`\n\n**Fix Strategy**: \n- Change scroll container type from `Ref<Window | HTMLElement>` to separate window/element logic\n- Use type assertion for VueUse compatibility: `as Ref<HTMLElement | Window | undefined>`\n- Add proper type guards for window vs element checks\n\n### Category 3: Nullable Function Guards (6 errors)\n**Lines**: 1623, 1624, 1625, 1668, 1669, 1670\n\n**Problem**: Calling potentially undefined functions without optional chaining\n\n**Fix Strategy**: Add optional chaining operator `?.()`\n- `pauseSequence?.()` instead of `pauseSequence()`\n- `resumeTimeline?.()` instead of `resumeTimeline()`\n\n### Category 4: Timeout Type Mismatch (1 error)\n**Line**: 1721\n\n**Problem**: `setInterval()` returns `NodeJS.Timeout` but assigned to `number`\n\n**Fix Strategy**: Change type from `number | null` to `ReturnType<typeof setInterval> | null`\n\n### Category 5: Animation Progress Calculation (1 error)\n**Line**: 1716\n\n**Problem**: `anim.currentTime` can be `null`, causing arithmetic error\n\n**Fix Strategy**: Add null check: `anim.currentTime !== null && timing.duration ...`\n\n### Category 6: Sequence Return Type (1 error)\n**Line**: 1924\n\n**Problem**: `useCycleList().state` is `Ref<T>` but expected `ComputedRef<T | undefined>`\n\n**Fix Strategy**: Wrap in `computed()` to match expected return type\n\n### Category 7: ResizeObserver Type Cast (1 error)\n**Line**: 1082\n\n**Problem**: Manual object construction doesn't match `ResizeObserverEntry` interface\n\n**Fix Strategy**: Cast through `unknown`: `as unknown as ResizeObserverEntry`\n\n## Implementation Order\n1. **Phase 1**: Fix element access pattern (Category 1) - Most pervasive issue\n2. **Phase 2**: Fix nullable function guards (Category 3) - Quick wins with `?.()` \n3. **Phase 3**: Fix scroll container types (Category 2) - Requires careful type restructuring\n4. **Phase 4**: Fix timeout/progress types (Categories 4, 5) - Simple type updates\n5. **Phase 5**: Fix sequence/observer types (Categories 6, 7) - Edge cases\n\n## Testing Strategy\n- Run `npm run typecheck` after each category fix\n- Verify no new errors introduced\n- Check runtime behavior in browser (animations still work)\n- Test edge cases: unmounted components, rapid play/pause cycles"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":676,"cache_read_input_tokens":87444,"cache_creation":{"ephemeral_5m_input_tokens":676,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvefp3WuSWjfjH143T1S","type":"assistant","uuid":"e6f43f75-6ad0-47cf-bd7b-66b2545f620c","timestamp":"2025-10-09T00:07:44.208Z"}
{"parentUuid":"e6f43f75-6ad0-47cf-bd7b-66b2545f620c","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has approved your plan. You can now start coding. Start with updating your todo list if applicable","tool_use_id":"toolu_01FHo3a4e1d1spnnUb7aq3Cc"}]},"uuid":"26e4662c-999e-4724-b35d-91b709f651ad","timestamp":"2025-10-09T00:08:36.616Z","toolUseResult":{"plan":"# Type Error Fix Plan for useAnimation.ts\n\n## Root Cause Analysis\nThe file has **26 type errors** caused by:\n1. **Primary issue**: `MaybeRefOrGetter<T>` accepts `T | Ref<T> | (() => T)`, but code treats it as `T` directly\n2. **Secondary issues**: Missing type narrowing, incorrect type conversions, and nullable function guards\n\n## Categorized Fixes\n\n### Category 1: Element Access Pattern (12 errors)\n**Lines**: 322, 1076, 1079, 1160, 1258, 1483, 1493, 1516, 1539, 2027\n\n**Problem**: Accessing properties on `HTMLElement | (() => HTMLElement | undefined)` without unwrapping\n\n**Fix Strategy**: Consistent use of `unref(target)` before accessing DOM properties\n- Add null checks after `unref()`\n- Use type guard pattern: `if (!el) return`\n\n### Category 2: Scroll Container Window Type (4 errors)\n**Lines**: 1949, 1952, 1953, 1379\n\n**Problem**: `useScroll()` expects `Ref<HTMLElement>` but receives `Ref<Window | HTMLElement | undefined>`\n\n**Fix Strategy**: \n- Change scroll container type from `Ref<Window | HTMLElement>` to separate window/element logic\n- Use type assertion for VueUse compatibility: `as Ref<HTMLElement | Window | undefined>`\n- Add proper type guards for window vs element checks\n\n### Category 3: Nullable Function Guards (6 errors)\n**Lines**: 1623, 1624, 1625, 1668, 1669, 1670\n\n**Problem**: Calling potentially undefined functions without optional chaining\n\n**Fix Strategy**: Add optional chaining operator `?.()`\n- `pauseSequence?.()` instead of `pauseSequence()`\n- `resumeTimeline?.()` instead of `resumeTimeline()`\n\n### Category 4: Timeout Type Mismatch (1 error)\n**Line**: 1721\n\n**Problem**: `setInterval()` returns `NodeJS.Timeout` but assigned to `number`\n\n**Fix Strategy**: Change type from `number | null` to `ReturnType<typeof setInterval> | null`\n\n### Category 5: Animation Progress Calculation (1 error)\n**Line**: 1716\n\n**Problem**: `anim.currentTime` can be `null`, causing arithmetic error\n\n**Fix Strategy**: Add null check: `anim.currentTime !== null && timing.duration ...`\n\n### Category 6: Sequence Return Type (1 error)\n**Line**: 1924\n\n**Problem**: `useCycleList().state` is `Ref<T>` but expected `ComputedRef<T | undefined>`\n\n**Fix Strategy**: Wrap in `computed()` to match expected return type\n\n### Category 7: ResizeObserver Type Cast (1 error)\n**Line**: 1082\n\n**Problem**: Manual object construction doesn't match `ResizeObserverEntry` interface\n\n**Fix Strategy**: Cast through `unknown`: `as unknown as ResizeObserverEntry`\n\n## Implementation Order\n1. **Phase 1**: Fix element access pattern (Category 1) - Most pervasive issue\n2. **Phase 2**: Fix nullable function guards (Category 3) - Quick wins with `?.()` \n3. **Phase 3**: Fix scroll container types (Category 2) - Requires careful type restructuring\n4. **Phase 4**: Fix timeout/progress types (Categories 4, 5) - Simple type updates\n5. **Phase 5**: Fix sequence/observer types (Categories 6, 7) - Edge cases\n\n## Testing Strategy\n- Run `npm run typecheck` after each category fix\n- Verify no new errors introduced\n- Check runtime behavior in browser (animations still work)\n- Test edge cases: unmounted components, rapid play/pause cycles","isAgent":false}}
{"parentUuid":"26e4662c-999e-4724-b35d-91b709f651ad","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01LmSfa1mBxWBXhmp2ar8hvv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RKebShYt895zVKP94vS8hY","name":"TodoWrite","input":{"todos":[{"content":"Fix element access pattern errors (12 errors) - Lines 322, 1076, 1079, 1160, 1258, 1483, 1493, 1516, 1539, 2027","status":"in_progress","activeForm":"Fixing element access pattern errors"},{"content":"Fix nullable function guards (6 errors) - Lines 1623-1625, 1668-1670","status":"pending","activeForm":"Fixing nullable function guards"},{"content":"Fix scroll container type errors (4 errors) - Lines 1949, 1952, 1953, 1379","status":"pending","activeForm":"Fixing scroll container type errors"},{"content":"Fix timeout and progress calculation types (2 errors) - Lines 1721, 1716","status":"pending","activeForm":"Fixing timeout and progress calculation types"},{"content":"Fix sequence return type and ResizeObserver cast (2 errors) - Lines 1924, 1082","status":"pending","activeForm":"Fixing sequence return type and ResizeObserver cast"},{"content":"Run typecheck and verify all errors are fixed","status":"pending","activeForm":"Running typecheck and verifying all errors are fixed"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":1108,"cache_read_input_tokens":88120,"cache_creation":{"ephemeral_5m_input_tokens":1108,"ephemeral_1h_input_tokens":0},"output_tokens":429,"service_tier":"standard"}},"requestId":"req_011CTvemT7qqxbXQCwnTWCFr","type":"assistant","uuid":"4fbff3cc-8dca-4152-83e1-1395dff3897c","timestamp":"2025-10-09T00:08:44.566Z"}
{"parentUuid":"4fbff3cc-8dca-4152-83e1-1395dff3897c","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RKebShYt895zVKP94vS8hY","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"4335b051-3151-49af-87c0-5cd04a79517c","timestamp":"2025-10-09T00:08:44.646Z","toolUseResult":{"oldTodos":[],"newTodos":[{"content":"Fix element access pattern errors (12 errors) - Lines 322, 1076, 1079, 1160, 1258, 1483, 1493, 1516, 1539, 2027","status":"in_progress","activeForm":"Fixing element access pattern errors"},{"content":"Fix nullable function guards (6 errors) - Lines 1623-1625, 1668-1670","status":"pending","activeForm":"Fixing nullable function guards"},{"content":"Fix scroll container type errors (4 errors) - Lines 1949, 1952, 1953, 1379","status":"pending","activeForm":"Fixing scroll container type errors"},{"content":"Fix timeout and progress calculation types (2 errors) - Lines 1721, 1716","status":"pending","activeForm":"Fixing timeout and progress calculation types"},{"content":"Fix sequence return type and ResizeObserver cast (2 errors) - Lines 1924, 1082","status":"pending","activeForm":"Fixing sequence return type and ResizeObserver cast"},{"content":"Run typecheck and verify all errors are fixed","status":"pending","activeForm":"Running typecheck and verifying all errors are fixed"}]}}
{"parentUuid":"4335b051-3151-49af-87c0-5cd04a79517c","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TNaFn8PkHfiAUX2uKPQHuk","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll start fixing the errors. Let me begin with **Phase 1: Element Access Pattern** errors:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":727,"cache_read_input_tokens":89228,"cache_creation":{"ephemeral_5m_input_tokens":727,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTven3GB1WUwq284J5JBB","type":"assistant","uuid":"a2bd4a43-3e1a-49f3-865a-f138d84762f0","timestamp":"2025-10-09T00:08:49.333Z"}
{"parentUuid":"a2bd4a43-3e1a-49f3-865a-f138d84762f0","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TNaFn8PkHfiAUX2uKPQHuk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PZaHQWNPrxf9uNqjc3fivY","name":"Edit","input":{"file_path":"src/components/composables/useAnimation.ts","old_string":"    const anim = el.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })","new_string":"    const element = unref(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":727,"cache_read_input_tokens":89228,"cache_creation":{"ephemeral_5m_input_tokens":727,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTven3GB1WUwq284J5JBB","type":"assistant","uuid":"def9d88e-4594-498f-8b13-1ecf71a461f7","timestamp":"2025-10-09T00:08:52.156Z"}
{"type":"file-history-snapshot","messageId":"def9d88e-4594-498f-8b13-1ecf71a461f7","snapshot":{"messageId":"c106adea-dbec-425d-8e5d-ce26cfe13da4","trackedFileBackups":{"src/components/composables/useAnimation.ts":{"backupFileName":"6422aa91a9ff85d0@v1","version":1,"backupTime":"2025-10-09T00:08:52.271Z"}},"timestamp":"2025-10-09T00:05:13.791Z"},"isSnapshotUpdate":true}
{"parentUuid":"def9d88e-4594-498f-8b13-1ecf71a461f7","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PZaHQWNPrxf9uNqjc3fivY","type":"tool_result","content":"The file src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   318→    const duration = options.duration || ANIMATION_DURATION.NORMAL\n   319→\n   320→    options.onStart?.()\n   321→\n   322→    const element = unref(el)\n   323→    if (!element) return\n   324→\n   325→    const anim = element.animate(keyframes as Keyframe[], {\n   326→      duration,\n   327→      easing: options.easing || EASING.EASE_OUT,\n   328→      delay: options.delay || 0,\n   329→      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n   330→    })\n   331→\n   332→    animRef.value = anim\n   333→\n   334→    // Attach listeners with { once: true } to auto-cleanup"}]},"uuid":"5c4dc6d9-1fdc-40aa-be57-7da403a8d093","timestamp":"2025-10-09T00:08:52.309Z","toolUseResult":{"filePath":"src/components/composables/useAnimation.ts","oldString":"    const anim = el.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })","newString":"    const element = unref(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const anim = el.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const targetEl = unref(target)\n            if (!targetEl) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(targetEl)\n\n              // Initial measurement\n              const rect = targetEl.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: targetEl,\n                  } as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const targetEl = unref(target)\n      if (!targetEl) return { x: 1, y: 1 }\n\n      const rect = targetEl.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const targetEl = unref(target)\n      if (!targetEl) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = targetEl.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          const finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence()\n    if (motionPathAnimation) pauseMotion()\n    if (timeline) pauseTimeline()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence()\n      if (motionPathAnimation) resumeMotion()\n      if (timeline) resumeTimeline()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":319,"oldLines":7,"newStart":319,"newLines":10,"lines":[" ","     options.onStart?.()"," ","-    const anim = el.animate(keyframes as Keyframe[], {","+    const element = unref(el)","+    if (!element) return","+","+    const anim = element.animate(keyframes as Keyframe[], {","       duration,","       easing: options.easing || EASING.EASE_OUT,","       delay: options.delay || 0,"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"5c4dc6d9-1fdc-40aa-be57-7da403a8d093","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Uw44dbXnG8NDcNctreaqKn","type":"message","role":"assistant","content":[{"type":"text","text":"Good! Now let me fix the ResizeObserver section (lines 1076, 1079, 1082):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":855,"cache_read_input_tokens":89955,"cache_creation":{"ephemeral_5m_input_tokens":855,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTveniQdd7vaPTwfUYoUr","type":"assistant","uuid":"eb56793b-e9e8-4b6a-ac8c-680a1e6463f0","timestamp":"2025-10-09T00:08:59.006Z"}
{"parentUuid":"eb56793b-e9e8-4b6a-ac8c-680a1e6463f0","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Uw44dbXnG8NDcNctreaqKn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013ipNx7F7ycBaxtEqJbTS9H","name":"Edit","input":{"file_path":"src/components/composables/useAnimation.ts","old_string":"              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(targetEl)\n\n              // Initial measurement\n              const rect = targetEl.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([ {\n                    contentRect: rect,\n                    target: targetEl,\n                  } as ResizeObserverEntry,\n                ])","new_string":"              const element = unref(targetEl)\n              if (!element) return\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":855,"cache_read_input_tokens":89955,"cache_creation":{"ephemeral_5m_input_tokens":855,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTveniQdd7vaPTwfUYoUr","type":"assistant","uuid":"95d3ca35-7520-45d4-a62c-8bec8eb09f7f","timestamp":"2025-10-09T00:09:02.103Z"}
{"parentUuid":"95d3ca35-7520-45d4-a62c-8bec8eb09f7f","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>String to replace not found in file.\nString:               resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(targetEl)\n\n              // Initial measurement\n              const rect = targetEl.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([ {\n                    contentRect: rect,\n                    target: targetEl,\n                  } as ResizeObserverEntry,\n                ])</tool_use_error>","is_error":true,"tool_use_id":"toolu_013ipNx7F7ycBaxtEqJbTS9H"}]},"uuid":"2c3f0679-b3a6-44e7-b236-cfcc3469d3d8","timestamp":"2025-10-09T00:09:02.167Z","toolUseResult":"Error: String to replace not found in file.\nString:               resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(targetEl)\n\n              // Initial measurement\n              const rect = targetEl.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([ {\n                    contentRect: rect,\n                    target: targetEl,\n                  } as ResizeObserverEntry,\n                ])"}
{"parentUuid":"2c3f0679-b3a6-44e7-b236-cfcc3469d3d8","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01UmHRbVoj34ftkdZgzivg39","type":"message","role":"assistant","content":[{"type":"text","text":"Let me check the exact spacing:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":835,"cache_read_input_tokens":90810,"cache_creation":{"ephemeral_5m_input_tokens":835,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTveoKvZDGyhfWJtuG933","type":"assistant","uuid":"976e2de0-c145-4ee3-bced-f6289782ebbc","timestamp":"2025-10-09T00:09:06.505Z"}
{"parentUuid":"976e2de0-c145-4ee3-bced-f6289782ebbc","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01UmHRbVoj34ftkdZgzivg39","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JkiHhJiuGxVhXkSGciYyp7","name":"Read","input":{"file_path":"src/components/composables/useAnimation.ts","offset":1075,"limit":15}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":835,"cache_read_input_tokens":90810,"cache_creation":{"ephemeral_5m_input_tokens":835,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTveoKvZDGyhfWJtuG933","type":"assistant","uuid":"b220e538-35a2-41e7-9944-b1e537012ccf","timestamp":"2025-10-09T00:09:07.117Z"}
{"parentUuid":"b220e538-35a2-41e7-9944-b1e537012ccf","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JkiHhJiuGxVhXkSGciYyp7","type":"tool_result","content":"  1075→                return\n  1076→              }\n  1077→\n  1078→              resizeObserver = new ResizeObserver(updateDimensions)\n  1079→              resizeObserver.observe(targetEl)\n  1080→\n  1081→              // Initial measurement\n  1082→              const rect = targetEl.getBoundingClientRect()\n  1083→              if (rect.width > 0 && rect.height > 0) {\n  1084→                updateDimensions([\n  1085→                  {\n  1086→                    contentRect: rect,\n  1087→                    target: targetEl,\n  1088→                  } as ResizeObserverEntry,\n  1089→                ])\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a8f173d0-1f26-4944-b425-d118973f198f","timestamp":"2025-10-09T00:09:07.188Z","toolUseResult":{"type":"text","file":{"filePath":"src/components/composables/useAnimation.ts","content":"                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(targetEl)\n\n              // Initial measurement\n              const rect = targetEl.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: targetEl,\n                  } as ResizeObserverEntry,\n                ])","numLines":15,"startLine":1075,"totalLines":2676}}}
{"parentUuid":"a8f173d0-1f26-4944-b425-d118973f198f","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01T38wqvsJCAMjXJFZcTnrTB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016RrXyimEWPzuk4Uh5greWv","name":"Edit","input":{"file_path":"src/components/composables/useAnimation.ts","old_string":"              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(targetEl)\n\n              // Initial measurement\n              const rect = targetEl.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: targetEl,\n                  } as ResizeObserverEntry,\n                ])","new_string":"              const element = unref(targetEl)\n              if (!element) return\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":34912,"cache_read_input_tokens":91645,"cache_creation":{"ephemeral_5m_input_tokens":34912,"ephemeral_1h_input_tokens":0},"output_tokens":336,"service_tier":"standard"}},"requestId":"req_011CTveojWddsx7vx2BhcQF3","type":"assistant","uuid":"5c9feeaa-8c80-435c-a572-b2d348d95730","timestamp":"2025-10-09T00:09:17.054Z"}
{"parentUuid":"5c9feeaa-8c80-435c-a572-b2d348d95730","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016RrXyimEWPzuk4Uh5greWv","type":"tool_result","content":"The file src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1074→                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n  1075→                return\n  1076→              }\n  1077→\n  1078→              const element = unref(targetEl)\n  1079→              if (!element) return\n  1080→\n  1081→              resizeObserver = new ResizeObserver(updateDimensions)\n  1082→              resizeObserver.observe(element)\n  1083→\n  1084→              // Initial measurement\n  1085→              const rect = element.getBoundingClientRect()\n  1086→              if (rect.width > 0 && rect.height > 0) {\n  1087→                updateDimensions([\n  1088→                  {\n  1089→                    contentRect: rect,\n  1090→                    target: element,\n  1091→                  } as unknown as ResizeObserverEntry,\n  1092→                ])\n  1093→              }\n  1094→            } catch (error) {\n  1095→              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n  1096→            }"}]},"uuid":"1121ff3e-1e3d-46d8-862e-e36d15b2a997","timestamp":"2025-10-09T00:09:17.143Z","toolUseResult":{"filePath":"src/components/composables/useAnimation.ts","oldString":"              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(targetEl)\n\n              // Initial measurement\n              const rect = targetEl.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: targetEl,\n                  } as ResizeObserverEntry,\n                ])","newString":"              const element = unref(targetEl)\n              if (!element) return\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = unref(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const targetEl = unref(target)\n            if (!targetEl) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(targetEl)\n\n              // Initial measurement\n              const rect = targetEl.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: targetEl,\n                  } as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const targetEl = unref(target)\n      if (!targetEl) return { x: 1, y: 1 }\n\n      const rect = targetEl.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const targetEl = unref(target)\n      if (!targetEl) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = targetEl.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          const finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence()\n    if (motionPathAnimation) pauseMotion()\n    if (timeline) pauseTimeline()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence()\n      if (motionPathAnimation) resumeMotion()\n      if (timeline) resumeTimeline()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1075,"oldLines":17,"newStart":1075,"newLines":20,"lines":["                 return","               }"," ","+              const element = unref(targetEl)","+              if (!element) return","+","               resizeObserver = new ResizeObserver(updateDimensions)","-              resizeObserver.observe(targetEl)","+              resizeObserver.observe(element)"," ","               // Initial measurement","-              const rect = targetEl.getBoundingClientRect()","+              const rect = element.getBoundingClientRect()","               if (rect.width > 0 && rect.height > 0) {","                 updateDimensions([","                   {","                     contentRect: rect,","-                    target: targetEl,","-                  } as ResizeObserverEntry,","+                    target: element,","+                  } as unknown as ResizeObserverEntry,","                 ])","               }","             } catch (error) {"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"1121ff3e-1e3d-46d8-862e-e36d15b2a997","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Y8U8Dj3yj8ArjZzRReEVrq","type":"message","role":"assistant","content":[{"type":"text","text":"Good! Now continuing with remaining element access errors. Line 1160 (SVG getBoundingClientRect), line 1258 (grid querySelector), lines 1483/1493/1516/1539 (animateIn/animateOut), and line 2027 (stagger querySelectorAll):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":988,"cache_read_input_tokens":126557,"cache_creation":{"ephemeral_5m_input_tokens":988,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvepTqaxL7fXRkZwSd8k","type":"assistant","uuid":"5f46b0b2-f008-44db-aef9-fb5e592b8cb2","timestamp":"2025-10-09T00:09:23.734Z"}
{"parentUuid":"5f46b0b2-f008-44db-aef9-fb5e592b8cb2","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Y8U8Dj3yj8ArjZzRReEVrq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EjofjyFJS6Kps4i4ChTZkG","name":"Edit","input":{"file_path":"src/components/composables/useAnimation.ts","old_string":"    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const targetEl = unref(target)\n      if (!targetEl) return { x: 1, y: 1 }\n\n      const rect = targetEl.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })","new_string":"    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const targetEl = unref(target)\n      if (!targetEl) return { x: 1, y: 1 }\n\n      const element = unref(targetEl)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":988,"cache_read_input_tokens":126557,"cache_creation":{"ephemeral_5m_input_tokens":988,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvepTqaxL7fXRkZwSd8k","type":"assistant","uuid":"440ed8bd-375e-43a1-9e99-4a1716a79869","timestamp":"2025-10-09T00:09:26.730Z"}
{"parentUuid":"440ed8bd-375e-43a1-9e99-4a1716a79869","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EjofjyFJS6Kps4i4ChTZkG","type":"tool_result","content":"The file src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1157→\n  1158→  if (svg) {\n  1159→    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n  1160→\n  1161→    // Calculate scale factor between SVG space and screen space\n  1162→    const svgScale = computed(() => {\n  1163→      const targetEl = unref(target)\n  1164→      if (!targetEl) return { x: 1, y: 1 }\n  1165→\n  1166→      const element = unref(targetEl)\n  1167→      if (!element) return { x: 1, y: 1 }\n  1168→\n  1169→      const rect = element.getBoundingClientRect()\n  1170→      return {\n  1171→        x: rect.width / svg.viewBox.width,\n  1172→        y: rect.height / svg.viewBox.height,\n  1173→      }\n  1174→    })\n  1175→\n  1176→    // Convert SVG coordinates to screen pixels\n  1177→    const svgToScreen = computed(\n  1178→      () => (svgX: number, svgY: number) => {"}]},"uuid":"1f388942-a8a6-480f-bb73-f9e7ec604413","timestamp":"2025-10-09T00:09:26.837Z","toolUseResult":{"filePath":"src/components/composables/useAnimation.ts","oldString":"    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const targetEl = unref(target)\n      if (!targetEl) return { x: 1, y: 1 }\n\n      const rect = targetEl.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })","newString":"    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const targetEl = unref(target)\n      if (!targetEl) return { x: 1, y: 1 }\n\n      const element = unref(targetEl)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = unref(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const targetEl = unref(target)\n            if (!targetEl) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              const element = unref(targetEl)\n              if (!element) return\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const targetEl = unref(target)\n      if (!targetEl) return { x: 1, y: 1 }\n\n      const rect = targetEl.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const targetEl = unref(target)\n      if (!targetEl) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = targetEl.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          const finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence()\n    if (motionPathAnimation) pauseMotion()\n    if (timeline) pauseTimeline()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence()\n      if (motionPathAnimation) resumeMotion()\n      if (timeline) resumeTimeline()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1163,"oldLines":7,"newStart":1163,"newLines":10,"lines":["       const targetEl = unref(target)","       if (!targetEl) return { x: 1, y: 1 }"," ","-      const rect = targetEl.getBoundingClientRect()","+      const element = unref(targetEl)","+      if (!element) return { x: 1, y: 1 }","+","+      const rect = element.getBoundingClientRect()","       return {","         x: rect.width / svg.viewBox.width,","         y: rect.height / svg.viewBox.height,"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"1f388942-a8a6-480f-bb73-f9e7ec604413","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TLtkCC7kFHsageAcFXp1S2","type":"message","role":"assistant","content":[{"type":"text","text":"Wait, I made that unnecessarily complex. Let me fix it properly - `target` is already `MaybeRefOrGetter`, so I should just use `unref(target)` once:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1392,"cache_read_input_tokens":127545,"cache_creation":{"ephemeral_5m_input_tokens":1392,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTveqBoDDiUAH8DEbuz1r","type":"assistant","uuid":"59fbed54-00fe-4546-bb35-181c76aeb124","timestamp":"2025-10-09T00:09:33.027Z"}
{"parentUuid":"59fbed54-00fe-4546-bb35-181c76aeb124","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TLtkCC7kFHsageAcFXp1S2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UjtLad5PqGrX4RRTMZV9eE","name":"Edit","input":{"file_path":"src/components/composables/useAnimation.ts","old_string":"    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const targetEl = unref(target)\n      if (!targetEl) return { x: 1, y: 1 }\n\n      const element = unref(targetEl)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })","new_string":"    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = unref(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1392,"cache_read_input_tokens":127545,"cache_creation":{"ephemeral_5m_input_tokens":1392,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTveqBoDDiUAH8DEbuz1r","type":"assistant","uuid":"d21e2c69-0096-4c8c-8111-ea8d66091107","timestamp":"2025-10-09T00:09:35.784Z"}
{"parentUuid":"d21e2c69-0096-4c8c-8111-ea8d66091107","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UjtLad5PqGrX4RRTMZV9eE","type":"tool_result","content":"The file src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1157→\n  1158→  if (svg) {\n  1159→    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n  1160→\n  1161→    // Calculate scale factor between SVG space and screen space\n  1162→    const svgScale = computed(() => {\n  1163→      const element = unref(target)\n  1164→      if (!element) return { x: 1, y: 1 }\n  1165→\n  1166→      const rect = element.getBoundingClientRect()\n  1167→      return {\n  1168→        x: rect.width / svg.viewBox.width,\n  1169→        y: rect.height / svg.viewBox.height,\n  1170→      }\n  1171→    })\n  1172→\n  1173→    // Convert SVG coordinates to screen pixels\n  1174→    const svgToScreen = computed(\n  1175→      () => (svgX: number, svgY: number) => {"}]},"uuid":"3459c60f-114c-4b00-ae80-0f1674fe50cf","timestamp":"2025-10-09T00:09:35.930Z","toolUseResult":{"filePath":"src/components/composables/useAnimation.ts","oldString":"    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const targetEl = unref(target)\n      if (!targetEl) return { x: 1, y: 1 }\n\n      const element = unref(targetEl)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })","newString":"    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = unref(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = unref(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const targetEl = unref(target)\n            if (!targetEl) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              const element = unref(targetEl)\n              if (!element) return\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const targetEl = unref(target)\n      if (!targetEl) return { x: 1, y: 1 }\n\n      const element = unref(targetEl)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const targetEl = unref(target)\n      if (!targetEl) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = targetEl.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          const finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence()\n    if (motionPathAnimation) pauseMotion()\n    if (timeline) pauseTimeline()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence()\n      if (motionPathAnimation) resumeMotion()\n      if (timeline) resumeTimeline()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1160,"oldLines":10,"newStart":1160,"newLines":7,"lines":[" ","     // Calculate scale factor between SVG space and screen space","     const svgScale = computed(() => {","-      const targetEl = unref(target)","-      if (!targetEl) return { x: 1, y: 1 }","-","-      const element = unref(targetEl)","+      const element = unref(target)","       if (!element) return { x: 1, y: 1 }"," ","       const rect = element.getBoundingClientRect()"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"3459c60f-114c-4b00-ae80-0f1674fe50cf","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012en2WS9FGR6Kib2zbVQ7eg","type":"message","role":"assistant","content":[{"type":"text","text":"Now fix the grid querySelector (line 1258):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1020,"cache_read_input_tokens":128937,"cache_creation":{"ephemeral_5m_input_tokens":1020,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTveqrRfjXGXPWcDPPVj4","type":"assistant","uuid":"3d86cc26-6eb6-4c94-a851-c1e12fa91c17","timestamp":"2025-10-09T00:09:41.216Z"}
{"parentUuid":"3d86cc26-6eb6-4c94-a851-c1e12fa91c17","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012en2WS9FGR6Kib2zbVQ7eg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JugNqGupunNyMZwij9i6sN","name":"Edit","input":{"file_path":"src/components/composables/useAnimation.ts","old_string":"    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const targetEl = unref(target)\n      if (!targetEl) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = targetEl.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }","new_string":"    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = unref(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1020,"cache_read_input_tokens":128937,"cache_creation":{"ephemeral_5m_input_tokens":1020,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTveqrRfjXGXPWcDPPVj4","type":"assistant","uuid":"a72e2432-7fcf-466d-952b-aed407d9b6f4","timestamp":"2025-10-09T00:09:45.965Z"}
{"parentUuid":"a72e2432-7fcf-466d-952b-aed407d9b6f4","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JugNqGupunNyMZwij9i6sN","type":"tool_result","content":"The file src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1248→    const gridTemplateColumns = computed(() => grid.columns)\n  1249→    const gridTemplateRows = computed(() => grid.rows || '1fr')\n  1250→    const gridGap = computed(() => grid.gap || '0')\n  1251→\n  1252→    // Get the bounding rectangle of a grid zone\n  1253→    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n  1254→      const element = unref(target)\n  1255→      if (!element) return undefined\n  1256→\n  1257→      const zone = grid.zones?.[zoneName]\n  1258→      if (!zone) {\n  1259→        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n  1260→        return undefined\n  1261→      }\n  1262→\n  1263→      // Query for the zone element using data attribute or class\n  1264→      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n  1265→      if (!zoneEl) {\n  1266→        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n  1267→        return undefined\n  1268→      }\n  1269→\n  1270→      return zoneEl.getBoundingClientRect()\n  1271→    }\n  1272→\n  1273→    // Get the center point of a grid zone\n  1274→    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n  1275→      const rect = getZoneRect(zoneName)"}]},"uuid":"ecb063ed-3189-4b8c-8470-d271aaf37d9a","timestamp":"2025-10-09T00:09:46.085Z","toolUseResult":{"filePath":"src/components/composables/useAnimation.ts","oldString":"    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const targetEl = unref(target)\n      if (!targetEl) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = targetEl.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }","newString":"    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = unref(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = unref(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const targetEl = unref(target)\n            if (!targetEl) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              const element = unref(targetEl)\n              if (!element) return\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = unref(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const targetEl = unref(target)\n      if (!targetEl) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = targetEl.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          const finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence()\n    if (motionPathAnimation) pauseMotion()\n    if (timeline) pauseTimeline()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence()\n      if (motionPathAnimation) resumeMotion()\n      if (timeline) resumeTimeline()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1251,"oldLines":8,"newStart":1251,"newLines":8,"lines":[" ","     // Get the bounding rectangle of a grid zone","     const getZoneRect = (zoneName: string): DOMRect | undefined => {","-      const targetEl = unref(target)","-      if (!targetEl) return undefined","+      const element = unref(target)","+      if (!element) return undefined"," ","       const zone = grid.zones?.[zoneName]","       if (!zone) {"]},{"oldStart":1261,"oldLines":7,"newStart":1261,"newLines":7,"lines":["       }"," ","       // Query for the zone element using data attribute or class","-      const zoneEl = targetEl.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement","+      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement","       if (!zoneEl) {","         console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)","         return undefined"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"ecb063ed-3189-4b8c-8470-d271aaf37d9a","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01LAwHpshyHRCCihizLXabxj","type":"message","role":"assistant","content":[{"type":"text","text":"Now fix lines 1515-1518 in `animateOut` (outKeyframes array access issue - outKeyframes might be a Ref, need to handle properly). Actually, looking at the error more carefully, it's because `outKeyframes` parameter type is `UseAnimateKeyframes` which is a union including `Ref<>`. Let me check the actual code first:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1587,"cache_read_input_tokens":129957,"cache_creation":{"ephemeral_5m_input_tokens":1587,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvercTodv46zWwgk3odX","type":"assistant","uuid":"39341633-dec0-4a85-9179-eb9f17ed4241","timestamp":"2025-10-09T00:09:54.468Z"}
{"parentUuid":"39341633-dec0-4a85-9179-eb9f17ed4241","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01LAwHpshyHRCCihizLXabxj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ALmGtMBFnrGREs2qbSXfnM","name":"Read","input":{"file_path":"src/components/composables/useAnimation.ts","offset":1508,"limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1587,"cache_read_input_tokens":129957,"cache_creation":{"ephemeral_5m_input_tokens":1587,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvercTodv46zWwgk3odX","type":"assistant","uuid":"a6a4c2d2-71d2-4da1-84db-6d2a379a714a","timestamp":"2025-10-09T00:09:54.912Z"}
{"parentUuid":"a6a4c2d2-71d2-4da1-84db-6d2a379a714a","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ALmGtMBFnrGREs2qbSXfnM","type":"tool_result","content":"  1508→      }\n  1509→    }\n  1510→\n  1511→    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n  1512→      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n  1513→\n  1514→      if (animationQuality.value === 'none' || !canAnimate.value) {\n  1515→        const element = unref(target)\n  1516→        if (element) {\n  1517→          const defaultOutKeyframes = [\n  1518→            { opacity: 1, transform: 'scale(1)' },\n  1519→            { opacity: 0, transform: 'scale(0.8)' },\n  1520→          ]\n  1521→          const finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>\n  1522→          Object.assign(element.style, finalFrame)\n  1523→        }\n  1524→        onComplete?.()\n  1525→        return\n  1526→      }\n  1527→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"75ad393c-2520-4e9b-aa53-a56a9b4d26c0","timestamp":"2025-10-09T00:09:55.089Z","toolUseResult":{"type":"text","file":{"filePath":"src/components/composables/useAnimation.ts","content":"      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          const finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n","numLines":20,"startLine":1508,"totalLines":2679}}}
{"parentUuid":"75ad393c-2520-4e9b-aa53-a56a9b4d26c0","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Dq3MgRmtkMqpHRfGY2Nniw","type":"message","role":"assistant","content":[{"type":"text","text":"I see the issue - `outKeyframes` is `UseAnimateKeyframes` which can include refs. I need to handle this properly. The problem is on line 1521 where we try to access `.length` on something that might be a Ref. Let me fix this and the remaining element access issues (lines 1483, 1493, 1516, 1539, 2027):\n\nSince we're running low on context due to the massive system reminders, let me batch fix all remaining element access errors at once efficiently. Let me continue with the remaining fixes focusing on completing the phase-1 task.\n\nThe key insight is: lines 1483, 1493, 1516, 1539 are already fixed (they use `unref(target)` properly). Line 2027 still needs a fix - that's the stagger `querySelectorAll` which I can see in the full file content still says `targetEl.querySelectorAll(stagger.children)`. That targetEl comes from `const targetEl = unref(target)` on line 2029, so it's already fixed.\n\nLooking at line 1521 again - the issue is `outKeyframes?.[outKeyframes.length - 1]` where `outKeyframes` is type `UseAnimateKeyframes` which can be a Ref. This needs proper handling - but actually, when this code runs, `outKeyframes` is passed in as a direct parameter, not unwrapped. So for safety, we should handle the case where it might be an array or Ref/PropertyIndexedKeyframes.\n\nActually, let me simplify - the real issue is we're accessing array properties on what might not be an array. Let's fix line 1521 properly:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":34831,"cache_read_input_tokens":131544,"cache_creation":{"ephemeral_5m_input_tokens":34831,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CTvesJ9WnVh9noTNTTX6z","type":"assistant","uuid":"d88a5111-0649-4687-b494-c407c0b6a92d","timestamp":"2025-10-09T00:10:11.487Z"}
{"parentUuid":"d88a5111-0649-4687-b494-c407c0b6a92d","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Dq3MgRmtkMqpHRfGY2Nniw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014FrTpBXXLURBqxPAtYE1iH","name":"Edit","input":{"file_path":"src/components/composables/useAnimation.ts","old_string":"      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          const finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }","new_string":"      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":34831,"cache_read_input_tokens":131544,"cache_creation":{"ephemeral_5m_input_tokens":34831,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CTvesJ9WnVh9noTNTTX6z","type":"assistant","uuid":"8bcb8cda-b59c-4b1b-a1a9-7c2d8c76a939","timestamp":"2025-10-09T00:10:16.660Z"}
{"parentUuid":"8bcb8cda-b59c-4b1b-a1a9-7c2d8c76a939","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014FrTpBXXLURBqxPAtYE1iH","type":"tool_result","content":"The file src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1510→\n  1511→    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n  1512→      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n  1513→\n  1514→      if (animationQuality.value === 'none' || !canAnimate.value) {\n  1515→        const element = unref(target)\n  1516→        if (element) {\n  1517→          const defaultOutKeyframes = [\n  1518→            { opacity: 1, transform: 'scale(1)' },\n  1519→            { opacity: 0, transform: 'scale(0.8)' },\n  1520→          ]\n  1521→          // Handle outKeyframes which might be a Ref or array\n  1522→          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n  1523→          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n  1524→            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n  1525→          }\n  1526→          Object.assign(element.style, finalFrame)\n  1527→        }\n  1528→        onComplete?.()\n  1529→        return\n  1530→      }\n  1531→\n  1532→      const defaultOutKeyframes = [\n  1533→        { opacity: 1, transform: 'scale(1)' },\n  1534→        { opacity: 0, transform: 'scale(0.8)' },"}]},"uuid":"02a0226f-3e99-4a9a-b4f2-6dfe6f822dea","timestamp":"2025-10-09T00:10:16.778Z","toolUseResult":{"filePath":"src/components/composables/useAnimation.ts","oldString":"      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          const finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }","newString":"      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = unref(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const targetEl = unref(target)\n            if (!targetEl) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              const element = unref(targetEl)\n              if (!element) return\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = unref(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = unref(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          const finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence()\n    if (motionPathAnimation) pauseMotion()\n    if (timeline) pauseTimeline()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence()\n      if (motionPathAnimation) resumeMotion()\n      if (timeline) resumeTimeline()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1518,"oldLines":7,"newStart":1518,"newLines":11,"lines":["             { opacity: 1, transform: 'scale(1)' },","             { opacity: 0, transform: 'scale(0.8)' },","           ]","-          const finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>","+          // Handle outKeyframes which might be a Ref or array","+          let finalFrame: Record<string, any> = defaultOutKeyframes[1]","+          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {","+            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>","+          }","           Object.assign(element.style, finalFrame)","         }","         onComplete?.()"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"02a0226f-3e99-4a9a-b4f2-6dfe6f822dea","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01MZpy3MvsLN1VDW4pBRCvy5","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Phase 1 is complete. Now let me move to **Phase 2: Nullable function guards**. These are simple - just add optional chaining:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1931,"cache_read_input_tokens":166375,"cache_creation":{"ephemeral_5m_input_tokens":1931,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CTvetteCTeFCo9u5uMRi7","type":"assistant","uuid":"4aba8deb-3285-46e2-9f04-d1c4f7a74bb0","timestamp":"2025-10-09T00:10:22.437Z"}
{"parentUuid":"4aba8deb-3285-46e2-9f04-d1c4f7a74bb0","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01MZpy3MvsLN1VDW4pBRCvy5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0159i1ZvV6FToWAZM52nBByS","name":"TodoWrite","input":{"todos":[{"content":"Fix element access pattern errors (12 errors) - Lines 322, 1076, 1079, 1160, 1258, 1483, 1493, 1516, 1539, 2027","status":"completed","activeForm":"Fixed element access pattern errors"},{"content":"Fix nullable function guards (6 errors) - Lines 1623-1625, 1668-1670","status":"in_progress","activeForm":"Fixing nullable function guards"},{"content":"Fix scroll container type errors (4 errors) - Lines 1949, 1952, 1953, 1379","status":"pending","activeForm":"Fixing scroll container type errors"},{"content":"Fix timeout and progress calculation types (2 errors) - Lines 1721, 1716","status":"pending","activeForm":"Fixing timeout and progress calculation types"},{"content":"Fix sequence return type and ResizeObserver cast (2 errors) - Lines 1924, 1082","status":"pending","activeForm":"Fixing sequence return type and ResizeObserver cast"},{"content":"Run typecheck and verify all errors are fixed","status":"pending","activeForm":"Running typecheck and verifying all errors are fixed"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1931,"cache_read_input_tokens":166375,"cache_creation":{"ephemeral_5m_input_tokens":1931,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CTvetteCTeFCo9u5uMRi7","type":"assistant","uuid":"b7286684-dfcb-471b-81ff-2bc4ad30fc16","timestamp":"2025-10-09T00:10:25.372Z"}
{"parentUuid":"b7286684-dfcb-471b-81ff-2bc4ad30fc16","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0159i1ZvV6FToWAZM52nBByS","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"9bb25192-9164-48b9-9b81-1bc76ec902b6","timestamp":"2025-10-09T00:10:25.473Z","toolUseResult":{"oldTodos":[{"content":"Fix element access pattern errors (12 errors) - Lines 322, 1076, 1079, 1160, 1258, 1483, 1493, 1516, 1539, 2027","status":"in_progress","activeForm":"Fixing element access pattern errors"},{"content":"Fix nullable function guards (6 errors) - Lines 1623-1625, 1668-1670","status":"pending","activeForm":"Fixing nullable function guards"},{"content":"Fix scroll container type errors (4 errors) - Lines 1949, 1952, 1953, 1379","status":"pending","activeForm":"Fixing scroll container type errors"},{"content":"Fix timeout and progress calculation types (2 errors) - Lines 1721, 1716","status":"pending","activeForm":"Fixing timeout and progress calculation types"},{"content":"Fix sequence return type and ResizeObserver cast (2 errors) - Lines 1924, 1082","status":"pending","activeForm":"Fixing sequence return type and ResizeObserver cast"},{"content":"Run typecheck and verify all errors are fixed","status":"pending","activeForm":"Running typecheck and verifying all errors are fixed"}],"newTodos":[{"content":"Fix element access pattern errors (12 errors) - Lines 322, 1076, 1079, 1160, 1258, 1483, 1493, 1516, 1539, 2027","status":"completed","activeForm":"Fixed element access pattern errors"},{"content":"Fix nullable function guards (6 errors) - Lines 1623-1625, 1668-1670","status":"in_progress","activeForm":"Fixing nullable function guards"},{"content":"Fix scroll container type errors (4 errors) - Lines 1949, 1952, 1953, 1379","status":"pending","activeForm":"Fixing scroll container type errors"},{"content":"Fix timeout and progress calculation types (2 errors) - Lines 1721, 1716","status":"pending","activeForm":"Fixing timeout and progress calculation types"},{"content":"Fix sequence return type and ResizeObserver cast (2 errors) - Lines 1924, 1082","status":"pending","activeForm":"Fixing sequence return type and ResizeObserver cast"},{"content":"Run typecheck and verify all errors are fixed","status":"pending","activeForm":"Running typecheck and verifying all errors are fixed"}]}}
{"parentUuid":"9bb25192-9164-48b9-9b81-1bc76ec902b6","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01HkpBxKsXbSM9xwdWD1LUXw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XuvG2hphnLupf6QKUZUK9V","name":"Edit","input":{"file_path":"src/components/composables/useAnimation.ts","old_string":"    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence()\n    if (motionPathAnimation) pauseMotion()\n    if (timeline) pauseTimeline()","new_string":"    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":760,"cache_read_input_tokens":168306,"cache_creation":{"ephemeral_5m_input_tokens":760,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"}},"requestId":"req_011CTveuY8hJMfrbDjB3fBis","type":"assistant","uuid":"42359e58-35e8-4ba0-a844-e7e787cf26b4","timestamp":"2025-10-09T00:10:34.561Z"}
{"parentUuid":"42359e58-35e8-4ba0-a844-e7e787cf26b4","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XuvG2hphnLupf6QKUZUK9V","type":"tool_result","content":"The file src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1628→\n  1629→    isPaused.value = true\n  1630→    webAnimation?.pause()\n  1631→\n  1632→    // Explicitly pause all RAF systems\n  1633→    if (timedSequence) pauseSequence?.()\n  1634→    if (motionPathAnimation) pauseMotion?.()\n  1635→    if (timeline) pauseTimeline?.()\n  1636→\n  1637→    // Lifecycle: afterPause\n  1638→    lifecycle?.afterPause?.()\n  1639→  }"}]},"uuid":"6200f4f8-7422-4448-99ff-48d94b7a207a","timestamp":"2025-10-09T00:10:34.763Z","toolUseResult":{"filePath":"src/components/composables/useAnimation.ts","oldString":"    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence()\n    if (motionPathAnimation) pauseMotion()\n    if (timeline) pauseTimeline()","newString":"    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = unref(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const targetEl = unref(target)\n            if (!targetEl) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              const element = unref(targetEl)\n              if (!element) return\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = unref(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = unref(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence()\n    if (motionPathAnimation) pauseMotion()\n    if (timeline) pauseTimeline()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence()\n      if (motionPathAnimation) resumeMotion()\n      if (timeline) resumeTimeline()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1630,"oldLines":9,"newStart":1630,"newLines":9,"lines":["     webAnimation?.pause()"," ","     // Explicitly pause all RAF systems","-    if (timedSequence) pauseSequence()","-    if (motionPathAnimation) pauseMotion()","-    if (timeline) pauseTimeline()","+    if (timedSequence) pauseSequence?.()","+    if (motionPathAnimation) pauseMotion?.()","+    if (timeline) pauseTimeline?.()"," ","     // Lifecycle: afterPause","     lifecycle?.afterPause?.()"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"6200f4f8-7422-4448-99ff-48d94b7a207a","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01PcnjxWJEuF6iWNX4mg6dmG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01371du8sRo8yyPTSmXPjYxh","name":"Edit","input":{"file_path":"src/components/composables/useAnimation.ts","old_string":"      // Resume RAF systems\n      if (timedSequence) resumeSequence()\n      if (motionPathAnimation) resumeMotion()\n      if (timeline) resumeTimeline()","new_string":"      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":705,"cache_read_input_tokens":169066,"cache_creation":{"ephemeral_5m_input_tokens":705,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard"}},"requestId":"req_011CTvevDdjN5snVAfetkiR1","type":"assistant","uuid":"caabc0ab-e2fa-4e02-b1c9-e3edc3ed857e","timestamp":"2025-10-09T00:10:41.306Z"}
{"parentUuid":"caabc0ab-e2fa-4e02-b1c9-e3edc3ed857e","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01371du8sRo8yyPTSmXPjYxh","type":"tool_result","content":"The file src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1673→    isPaused.value = false\n  1674→    if (isPlaying.value) {\n  1675→      webAnimation?.play()\n  1676→\n  1677→      // Resume RAF systems\n  1678→      if (timedSequence) resumeSequence?.()\n  1679→      if (motionPathAnimation) resumeMotion?.()\n  1680→      if (timeline) resumeTimeline?.()\n  1681→    }\n  1682→\n  1683→    // Lifecycle: afterResume\n  1684→    lifecycle?.afterResume?.()"}]},"uuid":"5000f0a8-30ca-40df-a332-08f6d07e6276","timestamp":"2025-10-09T00:10:41.435Z","toolUseResult":{"filePath":"src/components/composables/useAnimation.ts","oldString":"      // Resume RAF systems\n      if (timedSequence) resumeSequence()\n      if (motionPathAnimation) resumeMotion()\n      if (timeline) resumeTimeline()","newString":"      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = unref(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const targetEl = unref(target)\n            if (!targetEl) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              const element = unref(targetEl)\n              if (!element) return\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = unref(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = unref(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence()\n      if (motionPathAnimation) resumeMotion()\n      if (timeline) resumeTimeline()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1675,"oldLines":9,"newStart":1675,"newLines":9,"lines":["       webAnimation?.play()"," ","       // Resume RAF systems","-      if (timedSequence) resumeSequence()","-      if (motionPathAnimation) resumeMotion()","-      if (timeline) resumeTimeline()","+      if (timedSequence) resumeSequence?.()","+      if (motionPathAnimation) resumeMotion?.()","+      if (timeline) resumeTimeline?.()","     }"," ","     // Lifecycle: afterResume"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"5000f0a8-30ca-40df-a332-08f6d07e6276","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01AKWGchsyFhzABrxY6h7r8m","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! **Phase 2 complete**. Now **Phase 3: Fix scroll container types**. The issue is that `useScroll()` doesn't accept `Window` type. We need to handle the window case separately or use type assertion:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":706,"cache_read_input_tokens":169771,"cache_creation":{"ephemeral_5m_input_tokens":706,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTveviuNVSJFBj6t4srce","type":"assistant","uuid":"bd45f3e4-e169-4d7a-a9f8-011421d3b32b","timestamp":"2025-10-09T00:10:48.997Z"}
{"parentUuid":"bd45f3e4-e169-4d7a-a9f8-011421d3b32b","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01AKWGchsyFhzABrxY6h7r8m","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0195MLQ8C2uDhnacSuQaEier","name":"TodoWrite","input":{"todos":[{"content":"Fix element access pattern errors (12 errors) - Lines 322, 1076, 1079, 1160, 1258, 1483, 1493, 1516, 1539, 2027","status":"completed","activeForm":"Fixed element access pattern errors"},{"content":"Fix nullable function guards (6 errors) - Lines 1623-1625, 1668-1670","status":"completed","activeForm":"Fixed nullable function guards"},{"content":"Fix scroll container type errors (4 errors) - Lines 1949, 1952, 1953, 1379","status":"in_progress","activeForm":"Fixing scroll container type errors"},{"content":"Fix timeout and progress calculation types (2 errors) - Lines 1721, 1716","status":"pending","activeForm":"Fixing timeout and progress calculation types"},{"content":"Fix sequence return type and ResizeObserver cast (2 errors) - Lines 1924, 1082","status":"pending","activeForm":"Fixing sequence return type and ResizeObserver cast"},{"content":"Run typecheck and verify all errors are fixed","status":"pending","activeForm":"Running typecheck and verifying all errors are fixed"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":706,"cache_read_input_tokens":169771,"cache_creation":{"ephemeral_5m_input_tokens":706,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTveviuNVSJFBj6t4srce","type":"assistant","uuid":"de10a0ed-6782-4f9a-b1b6-876487a79994","timestamp":"2025-10-09T00:10:51.674Z"}
{"parentUuid":"de10a0ed-6782-4f9a-b1b6-876487a79994","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0195MLQ8C2uDhnacSuQaEier","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"6e136a9d-19b7-4ede-ad0d-eceee590dc11","timestamp":"2025-10-09T00:10:51.785Z","toolUseResult":{"oldTodos":[{"content":"Fix element access pattern errors (12 errors) - Lines 322, 1076, 1079, 1160, 1258, 1483, 1493, 1516, 1539, 2027","status":"completed","activeForm":"Fixed element access pattern errors"},{"content":"Fix nullable function guards (6 errors) - Lines 1623-1625, 1668-1670","status":"in_progress","activeForm":"Fixing nullable function guards"},{"content":"Fix scroll container type errors (4 errors) - Lines 1949, 1952, 1953, 1379","status":"pending","activeForm":"Fixing scroll container type errors"},{"content":"Fix timeout and progress calculation types (2 errors) - Lines 1721, 1716","status":"pending","activeForm":"Fixing timeout and progress calculation types"},{"content":"Fix sequence return type and ResizeObserver cast (2 errors) - Lines 1924, 1082","status":"pending","activeForm":"Fixing sequence return type and ResizeObserver cast"},{"content":"Run typecheck and verify all errors are fixed","status":"pending","activeForm":"Running typecheck and verifying all errors are fixed"}],"newTodos":[{"content":"Fix element access pattern errors (12 errors) - Lines 322, 1076, 1079, 1160, 1258, 1483, 1493, 1516, 1539, 2027","status":"completed","activeForm":"Fixed element access pattern errors"},{"content":"Fix nullable function guards (6 errors) - Lines 1623-1625, 1668-1670","status":"completed","activeForm":"Fixed nullable function guards"},{"content":"Fix scroll container type errors (4 errors) - Lines 1949, 1952, 1953, 1379","status":"in_progress","activeForm":"Fixing scroll container type errors"},{"content":"Fix timeout and progress calculation types (2 errors) - Lines 1721, 1716","status":"pending","activeForm":"Fixing timeout and progress calculation types"},{"content":"Fix sequence return type and ResizeObserver cast (2 errors) - Lines 1924, 1082","status":"pending","activeForm":"Fixing sequence return type and ResizeObserver cast"},{"content":"Run typecheck and verify all errors are fixed","status":"pending","activeForm":"Running typecheck and verifying all errors are fixed"}]}}
{"parentUuid":"6e136a9d-19b7-4ede-ad0d-eceee590dc11","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TDmuWiwV1dJP7wRtoab75r","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to check what VueUse's `useScroll` actually accepts. The error says it doesn't accept Window. Let me check line 1379 for `useElementVisibility` first, then fix the scroll issues together. Actually, the best approach is to just use the existing `as any` cast they already have on line 1950. Let me check if that's the right approach or if we need a different fix. Let me verify the actual line numbers for the scroll errors since my edits may have shifted them:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":776,"cache_read_input_tokens":170477,"cache_creation":{"ephemeral_5m_input_tokens":776,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CTvewUAdRo7Ji9XnbvK7h","type":"assistant","uuid":"daffe155-0429-4c60-b41d-776a852a9a55","timestamp":"2025-10-09T00:10:59.858Z"}
{"parentUuid":"daffe155-0429-4c60-b41d-776a852a9a55","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TDmuWiwV1dJP7wRtoab75r","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DYa7vu6LwZPufCNJNt8yCj","name":"Bash","input":{"command":"npm run typecheck 2>&1 | grep \"useAnimation.ts\" | head -15","description":"Check remaining type errors in useAnimation.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":776,"cache_read_input_tokens":170477,"cache_creation":{"ephemeral_5m_input_tokens":776,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CTvewUAdRo7Ji9XnbvK7h","type":"assistant","uuid":"4445a533-dda6-41fc-ba32-08c2cdfd80aa","timestamp":"2025-10-09T00:11:00.899Z"}
{"parentUuid":"4445a533-dda6-41fc-ba32-08c2cdfd80aa","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DYa7vu6LwZPufCNJNt8yCj","type":"tool_result","content":"\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m2037\u001b[0m:\u001b[93m53\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelectorAll' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1963\u001b[0m:\u001b[93m58\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'innerHeight' does not exist on type 'never'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1962\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2367): \u001b[0mThis comparison appears to be unintentional because the types 'HTMLElement' and 'Window & typeof globalThis' have no overlap.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1959\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'Ref<HTMLElement | undefined, HTMLElement | undefined> | Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to parameter of type 'MaybeRef<HTMLElement | undefined> | ComputedRef<HTMLElement | undefined>'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1934\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2739): \u001b[0mType 'Ref<TElement, TElement> & { [ShallowRefMarker]?: true | undefined; }' is missing the following properties from type 'ComputedRef<TElement | undefined>': effect, [ComputedRefSymbol]\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1731\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2322): \u001b[0mType 'Timeout' is not assignable to type 'number'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1726\u001b[0m:\u001b[93m52\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2362): \u001b[0mThe left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1549\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1526\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1499\u001b[0m:\u001b[93m40\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1489\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1385\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'ComputedRef<HTMLElement | (() => HTMLElement | undefined) | undefined>' is not assignable to parameter of type 'MaybeComputedElementRef<MaybeElement>'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1264\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelector' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1166\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'getBoundingClientRect' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1085\u001b[0m:\u001b[93m36\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'getBoundingClientRect' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.","is_error":false}]},"uuid":"b456b5b9-4047-4abf-8496-b9a66f744b9d","timestamp":"2025-10-09T00:11:37.448Z","toolUseResult":{"stdout":"\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m2037\u001b[0m:\u001b[93m53\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelectorAll' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1963\u001b[0m:\u001b[93m58\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'innerHeight' does not exist on type 'never'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1962\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2367): \u001b[0mThis comparison appears to be unintentional because the types 'HTMLElement' and 'Window & typeof globalThis' have no overlap.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1959\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'Ref<HTMLElement | undefined, HTMLElement | undefined> | Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to parameter of type 'MaybeRef<HTMLElement | undefined> | ComputedRef<HTMLElement | undefined>'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1934\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2739): \u001b[0mType 'Ref<TElement, TElement> & { [ShallowRefMarker]?: true | undefined; }' is missing the following properties from type 'ComputedRef<TElement | undefined>': effect, [ComputedRefSymbol]\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1731\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2322): \u001b[0mType 'Timeout' is not assignable to type 'number'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1726\u001b[0m:\u001b[93m52\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2362): \u001b[0mThe left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1549\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1526\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1499\u001b[0m:\u001b[93m40\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1489\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1385\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'ComputedRef<HTMLElement | (() => HTMLElement | undefined) | undefined>' is not assignable to parameter of type 'MaybeComputedElementRef<MaybeElement>'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1264\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelector' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1166\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'getBoundingClientRect' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1085\u001b[0m:\u001b[93m36\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'getBoundingClientRect' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"b456b5b9-4047-4abf-8496-b9a66f744b9d","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Sd7s76CB78UmAGAQN1ns3E","type":"message","role":"assistant","content":[{"type":"text","text":"I see there are still errors! Lines have shifted, but I see new issues. Let me check which specific elements still have the problem - lines 1085, 1166, 1264 still show type errors even though I thought I fixed them. Let me re-read those sections to see why the fixes didn't work:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1802,"cache_read_input_tokens":171253,"cache_creation":{"ephemeral_5m_input_tokens":1802,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CTvezqny8YZusxhfYP27X","type":"assistant","uuid":"c23b8763-03fe-4f4d-b03f-68f403e148e2","timestamp":"2025-10-09T00:11:45.182Z"}
{"parentUuid":"c23b8763-03fe-4f4d-b03f-68f403e148e2","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Sd7s76CB78UmAGAQN1ns3E","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01K5V2y9vwTyJ4sn3EMAiLcq","name":"Read","input":{"file_path":"src/components/composables/useAnimation.ts","offset":1082,"limit":5}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1802,"cache_read_input_tokens":171253,"cache_creation":{"ephemeral_5m_input_tokens":1802,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CTvezqny8YZusxhfYP27X","type":"assistant","uuid":"3dcbb4b5-1e0a-48e9-95d2-ba897e6d868f","timestamp":"2025-10-09T00:11:45.975Z"}
{"parentUuid":"3dcbb4b5-1e0a-48e9-95d2-ba897e6d868f","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01K5V2y9vwTyJ4sn3EMAiLcq","type":"tool_result","content":"  1082→              resizeObserver.observe(element)\n  1083→\n  1084→              // Initial measurement\n  1085→              const rect = element.getBoundingClientRect()\n  1086→              if (rect.width > 0 && rect.height > 0) {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"c56de945-2284-4c95-8d05-646c6d8df9da","timestamp":"2025-10-09T00:11:46.140Z","toolUseResult":{"type":"text","file":{"filePath":"src/components/composables/useAnimation.ts","content":"              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {","numLines":5,"startLine":1082,"totalLines":2683}}}
{"parentUuid":"c56de945-2284-4c95-8d05-646c6d8df9da","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"assistant","uuid":"f93ffc47-ca50-46e5-a11f-06c5be2cb667","timestamp":"2025-10-09T00:11:52.023Z","message":{"id":"aebbd8f2-00f7-4635-88fd-40226da3057e","container":null,"model":"<synthetic>","role":"assistant","stop_reason":"stop_sequence","stop_sequence":"","type":"message","usage":{"input_tokens":0,"output_tokens":0,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"server_tool_use":{"web_search_requests":0},"service_tier":null,"cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":0}},"content":[{"type":"text","text":"Prompt is too long"}]},"isApiErrorMessage":true}
{"type":"file-history-snapshot","messageId":"09cd0690-c583-4723-a976-4af62a41d163","snapshot":{"messageId":"09cd0690-c583-4723-a976-4af62a41d163","trackedFileBackups":{"src/components/composables/useAnimation.ts":{"backupFileName":"6422aa91a9ff85d0@v2","version":2,"backupTime":"2025-10-09T00:14:26.039Z"}},"timestamp":"2025-10-09T00:14:26.018Z"},"isSnapshotUpdate":false}
{"type":"file-history-snapshot","messageId":"67c1a1f2-1c4a-4507-a438-1c6e97dbe52d","snapshot":{"messageId":"67c1a1f2-1c4a-4507-a438-1c6e97dbe52d","trackedFileBackups":{"src/components/composables/useAnimation.ts":{"backupFileName":"6422aa91a9ff85d0@v2","version":2,"backupTime":"2025-10-09T00:14:26.039Z"}},"timestamp":"2025-10-09T00:14:26.046Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"logicalParentUuid":"f93ffc47-ca50-46e5-a11f-06c5be2cb667","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"system","subtype":"compact_boundary","content":"Conversation compacted","isMeta":false,"timestamp":"2025-10-09T00:14:26.008Z","uuid":"47aea4cf-5784-48be-a390-46c3a876fe80","level":"info","compactMetadata":{"trigger":"manual","preTokens":173223}}
{"parentUuid":"47aea4cf-5784-48be-a390-46c3a876fe80","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":"This session is being continued from a previous conversation that ran out of context. The conversation is summarized below:\nAnalysis:\nLet me chronologically analyze this conversation:\n\n1. **User's Initial Request**: The user asked me to review `src/components/composables/useAnimation.ts` and create a plan to fix all type errors in the file.\n\n2. **My Initial Actions**: \n   - I ran `npm run typecheck` to identify all type errors\n   - Found 26 type errors total in the file\n   - Read the useAnimation.ts file to understand the code structure\n   - Identified the root cause: `MaybeRefOrGetter<T>` type accepts `T | Ref<T> | (() => T)`, but code was accessing properties directly without unwrapping\n\n3. **Plan Creation**: I created a comprehensive plan categorizing errors into 6 phases:\n   - Phase 1: Element access pattern errors (12 errors) - lines 322, 1076, 1079, 1160, 1258, 1483, 1493, 1516, 1539, 2027\n   - Phase 2: Nullable function guards (6 errors) - lines 1623-1625, 1668-1670\n   - Phase 3: Scroll container types (4 errors) - lines 1949, 1952, 1953, 1379\n   - Phase 4: Timeout/progress types (2 errors) - lines 1721, 1716\n   - Phase 5: Sequence return type and ResizeObserver cast (2 errors) - lines 1924, 1082\n   - Phase 6: Run typecheck to verify\n\n4. **User Approval**: User approved the plan and I started executing.\n\n5. **Phase 1 Execution** (Element Access Pattern):\n   - Fixed line 322 in `createAnimation` function by adding `unref(el)` before accessing `.animate()`\n   - Fixed lines 1078-1091 in ResizeObserver section by adding `const element = unref(targetEl)` and casting ResizeObserverEntry to `as unknown as ResizeObserverEntry`\n   - Fixed line 1163 in SVG scale computation by using `unref(target)` directly\n   - Fixed line 1254 in grid zone system by using `unref(target)`\n   - Fixed lines 1521-1526 in `animateOut` by properly handling `outKeyframes` which might be a Ref or array\n\n6. **Phase 2 Execution** (Nullable Function Guards):\n   - Fixed lines 1633-1635 in `pause()` by adding optional chaining: `pauseSequence?.()`, `pauseMotion?.()`, `pauseTimeline?.()`\n   - Fixed lines 1678-1680 in `resume()` similarly\n\n7. **Current Issue**: After running typecheck again, I discovered there are still errors remaining. The element access pattern fixes didn't fully work because some sections still show errors like line 1085, 1166, 1264, 2037. This suggests my fixes may not have been applied correctly or line numbers shifted after edits.\n\n8. **Current Status**: I was in the middle of Phase 3 (scroll container types) when the summary was requested. The todo list shows:\n   - Phase 1: Completed\n   - Phase 2: Completed  \n   - Phase 3: In progress\n   - Phases 4-6: Pending\n\nHowever, the typecheck output shows errors still exist in areas I thought I fixed, which needs investigation.\n\nSummary:\n## 1. Primary Request and Intent\n\nThe user requested a comprehensive review and fix of all TypeScript type errors in `src/components/composables/useAnimation.ts`. The file had 26 type errors that needed to be systematically resolved. The user wanted a plan first, then approved execution of that plan.\n\n## 2. Key Technical Concepts\n\n- **TypeScript Type System**: `MaybeRefOrGetter<T>` type from VueUse that accepts `T | Ref<T> | (() => T)`\n- **Vue 3 Composition API**: `ref`, `computed`, `unref`, `watch`, `onUnmounted`\n- **VueUse Composables**: `useElementVisibility`, `useScroll`, `useCycleList`, `useAnimate`, `useRafFn`\n- **Web Animations API**: Animation objects, keyframes, timing options\n- **Type Guards and Narrowing**: Using `unref()` to unwrap refs before accessing DOM properties\n- **Optional Chaining**: Using `?.()` for nullable function calls\n- **TypeScript Type Assertions**: Using `as unknown as Type` for complex type conversions\n- **WeakMap**: For memory-safe event listener tracking\n- **ResizeObserver API**: For responsive dimension tracking\n\n## 3. Files and Code Sections\n\n### `src/components/composables/useAnimation.ts`\n**Summary**: Main animation orchestration composable with 2600+ lines. Contains multiple animation systems including Web Animations API, scroll triggers, stagger animations, motion paths, and timelines.\n\n**Key Changes Made**:\n\n1. **Line 322-330** - Fixed `createAnimation` function element access:\n```typescript\n// Before:\nconst anim = el.animate(keyframes as Keyframe[], {...})\n\n// After:\nconst element = unref(el)\nif (!element) return\n\nconst anim = element.animate(keyframes as Keyframe[], {...})\n```\n\n2. **Lines 1078-1092** - Fixed ResizeObserver element access and type casting:\n```typescript\nconst element = unref(targetEl)\nif (!element) return\n\nresizeObserver = new ResizeObserver(updateDimensions)\nresizeObserver.observe(element)\n\nconst rect = element.getBoundingClientRect()\nif (rect.width > 0 && rect.height > 0) {\n  updateDimensions([\n    {\n      contentRect: rect,\n      target: element,\n    } as unknown as ResizeObserverEntry,  // Changed from 'as ResizeObserverEntry'\n  ])\n}\n```\n\n3. **Lines 1162-1171** - Fixed SVG scale computation:\n```typescript\nconst svgScale = computed(() => {\n  const element = unref(target)  // Changed from targetEl = unref(target)\n  if (!element) return { x: 1, y: 1 }\n\n  const rect = element.getBoundingClientRect()\n  return {\n    x: rect.width / svg.viewBox.width,\n    y: rect.height / svg.viewBox.height,\n  }\n})\n```\n\n4. **Lines 1253-1271** - Fixed grid zone querySelector:\n```typescript\nconst getZoneRect = (zoneName: string): DOMRect | undefined => {\n  const element = unref(target)  // Changed from targetEl\n  if (!element) return undefined\n  \n  const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n  // ...\n}\n```\n\n5. **Lines 1521-1526** - Fixed animateOut keyframes handling:\n```typescript\n// Before:\nconst finalFrame = (outKeyframes?.[outKeyframes.length - 1] || defaultOutKeyframes[1]) as Record<string, any>\n\n// After:\nlet finalFrame: Record<string, any> = defaultOutKeyframes[1]\nif (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n  finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n}\n```\n\n6. **Lines 1633-1635** - Fixed nullable function guards in pause():\n```typescript\n// Before:\nif (timedSequence) pauseSequence()\nif (motionPathAnimation) pauseMotion()\nif (timeline) pauseTimeline()\n\n// After:\nif (timedSequence) pauseSequence?.()\nif (motionPathAnimation) pauseMotion?.()\nif (timeline) pauseTimeline?.()\n```\n\n7. **Lines 1678-1680** - Fixed nullable function guards in resume():\n```typescript\nif (timedSequence) resumeSequence?.()\nif (motionPathAnimation) resumeMotion?.()\nif (timeline) resumeTimeline?.()\n```\n\n## 4. Errors and Fixes\n\n### Error Category 1: Element Access Pattern (12 errors)\n**Problem**: Accessing DOM properties on `MaybeRefOrGetter<HTMLElement | undefined>` without unwrapping\n**Lines Affected**: 322, 1076, 1079, 1160, 1258, 1483, 1493, 1516, 1539, 2027\n**Solution**: Use `unref(target)` or `unref(el)` to unwrap before accessing properties like `.animate()`, `.getBoundingClientRect()`, `.querySelector()`, `.style`\n**Status**: Partially fixed - typecheck shows some errors persist at lines 1085, 1166, 1264, 2037\n\n### Error Category 2: Nullable Function Guards (6 errors)\n**Problem**: Calling potentially undefined functions without optional chaining\n**Lines Affected**: 1623, 1624, 1625, 1668, 1669, 1670\n**Solution**: Add optional chaining operator `?.()` \n**Status**: Completed\n\n### Error Category 3: Scroll Container Types (4 errors)  \n**Problem**: `useScroll()` doesn't accept `Window` type\n**Lines Affected**: 1949, 1952, 1953, 1959, 1379\n**Solution**: Pending - was in progress when summary requested\n**Status**: In Progress\n\n### Error Category 4: Timeout/Progress Types (2 errors)\n**Problem**: \n- Line 1721: `setInterval()` returns `Timeout` but assigned to `number`\n- Line 1716: `anim.currentTime` can be `null` causing arithmetic error\n**Solution**: Pending\n**Status**: Pending\n\n### Error Category 5: Sequence/ResizeObserver Types (2 errors)\n**Problem**:\n- Line 1924: `useCycleList().state` is `Ref<T>` but expected `ComputedRef<T | undefined>`\n- Line 1082: Manual ResizeObserverEntry construction type mismatch\n**Solution**: Line 1082 fixed with `as unknown as ResizeObserverEntry`, line 1924 pending\n**Status**: Partially completed\n\n## 5. Problem Solving\n\n**Main Problem**: Systematically fixing 26 TypeScript type errors in a large animation composable file.\n\n**Approach Taken**:\n1. Created a phased plan categorizing errors by type\n2. Executed fixes phase by phase\n3. Used todo list to track progress\n\n**Ongoing Issues**:\n- After running typecheck following Phase 1-2 fixes, errors still appear at lines that were supposedly fixed (1085, 1166, 1264, 2037)\n- This suggests either:\n  - Line numbers shifted due to edits\n  - Fixes weren't applied correctly\n  - Different instances of the same pattern need fixing\n\n**Next Troubleshooting Step**: Need to re-run typecheck and verify which errors remain before continuing to Phase 3.\n\n## 6. All User Messages\n\n1. \"Review @src/components/composables/useAnimation.ts . there's a lot of type errors in this file. create a plan to fix everyone of them\"\n\n2. User approved the plan (via ExitPlanMode tool result)\n\n3. \"Your task is to create a detailed summary of the conversation...\" (current message requesting summary)\n\n## 7. Pending Tasks\n\n1. **Complete Phase 3**: Fix scroll container type errors (4 errors) - lines 1949, 1952, 1953, 1379\n2. **Phase 4**: Fix timeout and progress calculation types (2 errors) - lines 1721, 1716\n3. **Phase 5**: Fix sequence return type (line 1924)\n4. **Phase 6**: Run final typecheck and verify all errors are resolved\n5. **Investigation**: Determine why errors persist at lines 1085, 1166, 1264, 2037 after supposedly fixing them\n\n## 8. Current Work\n\nImmediately before the summary request, I was in the middle of **Phase 3: Fixing scroll container type errors**. I had just:\n\n1. Completed Phase 2 (nullable function guards) by adding optional chaining to pause/resume functions\n2. Updated the todo list to mark Phase 2 as complete\n3. Started investigating Phase 3 scroll errors by running `npm run typecheck` again\n\nThe typecheck revealed that errors still exist in areas I thought I had fixed (lines 1085, 1166, 1264, 2037), which was unexpected. I was about to investigate why these errors persist when the summary was requested.\n\n**Relevant code context for scroll errors** (lines 1952-1964):\n```typescript\nif (scroll) {\n  const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n  const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)  // Line 1954 - using 'as any'\n\n  const scrollProgress = computed(() => {\n    if (!isMounted.value) return 0\n\n    const container = unref(scrollContainer)  // Line 1959 - type error\n    if (!container) return 0\n\n    const scrollHeight = container === window  // Line 1962 - type comparison error\n      ? document.documentElement.scrollHeight - window.innerHeight  // Line 1963 - property access error\n      : container.scrollHeight - container.clientHeight\n```\n\n## 9. Optional Next Step\n\n**Next step**: Re-run typecheck to get current error state, then systematically verify which Phase 1 fixes actually applied and which didn't. This is critical before proceeding to Phase 3 because we need accurate line numbers and error counts.\n\n**Direct quote from my last work**: \n> \"After running typecheck again, I discovered there are still errors remaining. The element access pattern fixes didn't fully work because some sections still show errors like line 1085, 1166, 1264, 2037.\"\n\nThe todo list shows Phase 3 as \"in_progress\" with the task: \"Fix scroll container type errors (4 errors) - Lines 1949, 1952, 1953, 1379\"\n\nHowever, given the unexpected persistence of Phase 1 errors, the immediate next step should be verification rather than moving forward to Phase 3.."},"isVisibleInTranscriptOnly":true,"isCompactSummary":true,"uuid":"09cd0690-c583-4723-a976-4af62a41d163","timestamp":"2025-10-09T00:14:26.008Z"}
{"parentUuid":"09cd0690-c583-4723-a976-4af62a41d163","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":"Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."},"isMeta":true,"uuid":"23903025-81d7-4e9b-ae76-4b06a9cbaa1f","timestamp":"2025-10-09T00:13:11.831Z"}
{"parentUuid":"23903025-81d7-4e9b-ae76-4b06a9cbaa1f","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":"<command-name>/compact</command-name>\n            <command-message>compact</command-message>\n            <command-args></command-args>"},"uuid":"67c1a1f2-1c4a-4507-a438-1c6e97dbe52d","timestamp":"2025-10-09T00:13:11.831Z"}
{"parentUuid":"67c1a1f2-1c4a-4507-a438-1c6e97dbe52d","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":"<local-command-stdout>\u001b[2mCompacted (ctrl+o to see full summary)\u001b[22m</local-command-stdout>"},"uuid":"87b930ef-68c6-406e-ac86-2fd02d92db51","timestamp":"2025-10-09T00:14:26.113Z"}
{"type":"file-history-snapshot","messageId":"833fbd49-d63c-4dcf-a414-85aee82ae3f1","snapshot":{"messageId":"833fbd49-d63c-4dcf-a414-85aee82ae3f1","trackedFileBackups":{"src/components/composables/useAnimation.ts":{"backupFileName":"6422aa91a9ff85d0@v2","version":2,"backupTime":"2025-10-09T00:14:26.039Z"}},"timestamp":"2025-10-09T00:14:45.363Z"},"isSnapshotUpdate":false}
{"parentUuid":"87b930ef-68c6-406e-ac86-2fd02d92db51","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":"continue with fixing the type errors"},"uuid":"833fbd49-d63c-4dcf-a414-85aee82ae3f1","timestamp":"2025-10-09T00:14:45.352Z","thinkingMetadata":{"level":"none","disabled":true,"triggers":[]}}
{"parentUuid":"833fbd49-d63c-4dcf-a414-85aee82ae3f1","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VueH8XRZcgzb9b84tJxjTG","type":"message","role":"assistant","content":[{"type":"text","text":"I'll continue fixing the type errors. Let me first run typecheck to see the current state of errors after the previous fixes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":21688,"cache_read_input_tokens":28767,"cache_creation":{"ephemeral_5m_input_tokens":21688,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfEZiEAGxAupK8Nt4zj","type":"assistant","uuid":"b5b2eea9-17f3-4e16-a3c1-d027d9e5d9b7","timestamp":"2025-10-09T00:14:49.393Z"}
{"parentUuid":"b5b2eea9-17f3-4e16-a3c1-d027d9e5d9b7","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VueH8XRZcgzb9b84tJxjTG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GvKCdv1TVjJJTNcgKFsc6H","name":"Bash","input":{"command":"npm run typecheck 2>&1 | head -100","description":"Run typecheck to see remaining errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":21688,"cache_read_input_tokens":28767,"cache_creation":{"ephemeral_5m_input_tokens":21688,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfEZiEAGxAupK8Nt4zj","type":"assistant","uuid":"ad9a6b74-10ee-44e8-b1a7-596d39fa35d5","timestamp":"2025-10-09T00:14:50.065Z"}
{"parentUuid":"ad9a6b74-10ee-44e8-b1a7-596d39fa35d5","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GvKCdv1TVjJJTNcgKFsc6H","type":"tool_result","content":"> socialaize@0.0.1 typecheck\n> astro check --minimumSeverity=error\n\n17:14:57 [@astrojs/cloudflare] Enabling sessions with Cloudflare KV with the \"SOCIALAIZE\" KV binding.\n17:14:57 [@astrojs/cloudflare] If you see the error \"Invalid binding `SOCIALAIZE`\" in your build output, you need to add the binding to your wrangler config file.\n17:14:58 [content] Syncing content\n17:14:58 [content] Synced content\n17:14:58 [types] Generated 468ms\n17:14:58 [check] Getting diagnostics for Astro files in /Users/natedamstra/socialaize...\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m2037\u001b[0m:\u001b[93m53\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelectorAll' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'querySelectorAll' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m2037\u001b[0m         staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n\u001b[7m    \u001b[0m \u001b[91m                                                    ~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1963\u001b[0m:\u001b[93m58\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'innerHeight' does not exist on type 'never'.\n\n\u001b[7m1963\u001b[0m         ? document.documentElement.scrollHeight - window.innerHeight\n\u001b[7m    \u001b[0m \u001b[91m                                                         ~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1962\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2367): \u001b[0mThis comparison appears to be unintentional because the types 'HTMLElement' and 'Window & typeof globalThis' have no overlap.\n\n\u001b[7m1962\u001b[0m       const scrollHeight = container === window\n\u001b[7m    \u001b[0m \u001b[91m                           ~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1959\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'Ref<HTMLElement | undefined, HTMLElement | undefined> | Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to parameter of type 'MaybeRef<HTMLElement | undefined> | ComputedRef<HTMLElement | undefined>'.\n  Type 'Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to type 'MaybeRef<HTMLElement | undefined> | ComputedRef<HTMLElement | undefined>'.\n\n\u001b[7m1959\u001b[0m       const container = unref(scrollContainer)\n\u001b[7m    \u001b[0m \u001b[91m                              ~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1934\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2739): \u001b[0mType 'Ref<TElement, TElement> & { [ShallowRefMarker]?: true | undefined; }' is missing the following properties from type 'ComputedRef<TElement | undefined>': effect, [ComputedRefSymbol]\n\n\u001b[7m1934\u001b[0m       currentElement,\n\u001b[7m    \u001b[0m \u001b[91m      ~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1731\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2322): \u001b[0mType 'Timeout' is not assignable to type 'number'.\n\n\u001b[7m1731\u001b[0m       activeProgressInterval.value = progressInterval\n\u001b[7m    \u001b[0m \u001b[91m      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1726\u001b[0m:\u001b[93m52\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2362): \u001b[0mThe left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n\n\u001b[7m1726\u001b[0m           const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n\u001b[7m    \u001b[0m \u001b[91m                                                   ~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1549\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'animate' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1549\u001b[0m         const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n\u001b[7m    \u001b[0m \u001b[91m                             ~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1526\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'style' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1526\u001b[0m           Object.assign(element.style, finalFrame)\n\u001b[7m    \u001b[0m \u001b[91m                                ~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1499\u001b[0m:\u001b[93m40\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'animate' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1499\u001b[0m           const newAnimation = element.animate(customKeyframes as Keyframe[], {\n\u001b[7m    \u001b[0m \u001b[91m                                       ~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1489\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'style' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1489\u001b[0m           Object.assign(element.style, finalFrame)\n\u001b[7m    \u001b[0m \u001b[91m                                ~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1385\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'ComputedRef<HTMLElement | (() => HTMLElement | undefined) | undefined>' is not assignable to parameter of type 'MaybeComputedElementRef<MaybeElement>'.\n  Type 'ComputedRef<HTMLElement | (() => HTMLElement | undefined) | undefined>' is not assignable to type 'ComputedRef<MaybeElement>'.\n\n\u001b[7m1385\u001b[0m     ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n\u001b[7m    \u001b[0m \u001b[91m                           ~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1264\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelector' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'querySelector' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1264\u001b[0m       const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n\u001b[7m    \u001b[0m \u001b[91m                             ~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1166\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'getBoundingClientRect' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'getBoundingClientRect' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1166\u001b[0m       const rect = element.getBoundingClientRect()\n\u001b[7m    \u001b[0m \u001b[91m                           ~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1085\u001b[0m:\u001b[93m36\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'getBoundingClientRect' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'getBoundingClientRect' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1085\u001b[0m               const rect = element.getBoundingClientRect()\n\u001b[7m    \u001b[0m \u001b[91m                                   ~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1082\u001b[0m:\u001b[93m38\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'HTMLElement | (() => HTMLElement | undefined)' is not assignable to parameter of type 'Element'.\n  Type '() => HTMLElement | undefined' is not assignable to type 'Element'.\n\n\u001b[7m1082\u001b[0m               resizeObserver.observe(element)\n\u001b[7m    \u001b[0m \u001b[91m                                     ~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m325\u001b[0m:\u001b[93m26\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'animate' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m325\u001b[0m     const anim = element.animate(keyframes as Keyframe[], {\n\u001b[7m   \u001b[0m \u001b[91m                         ~~~~~~~\u001b[0m\n\n\u001b[96msrc/components/composables/useNotifications.ts\u001b[0m:\u001b[93m559\u001b[0m:\u001b[93m23\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type '{ metadata: { realtimeEvent: RealtimeEvent; source: string; }; id?: string | undefined; type?: NotificationType | undefined; priority?: NotificationPriority | undefined; ... 14 more ...; groupId?: string | undefined; }' is not assignable to parameter of type 'Omit<SmartNotification, \"id\" | \"timestamp\" | \"aiScore\" | \"aiPriority\">'.\n  Types of property 'type' are incompatible.\n\n\u001b[7m559\u001b[0m       addNotification({\n\u001b[7m   \u001b[0m \u001b[91m                      ~\u001b[0m\n\u001b[7m560\u001b[0m         ...template,\n\u001b[7m   \u001b[0m \u001b[91m~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[7m...\u001b[0m \n\u001b[7m564\u001b[0m         }","is_error":false}]},"uuid":"c6217044-a8a9-4c39-a4d7-6f90ffcb9dc2","timestamp":"2025-10-09T00:15:12.429Z","toolUseResult":{"stdout":"> socialaize@0.0.1 typecheck\n> astro check --minimumSeverity=error\n\n17:14:57 [@astrojs/cloudflare] Enabling sessions with Cloudflare KV with the \"SOCIALAIZE\" KV binding.\n17:14:57 [@astrojs/cloudflare] If you see the error \"Invalid binding `SOCIALAIZE`\" in your build output, you need to add the binding to your wrangler config file.\n17:14:58 [content] Syncing content\n17:14:58 [content] Synced content\n17:14:58 [types] Generated 468ms\n17:14:58 [check] Getting diagnostics for Astro files in /Users/natedamstra/socialaize...\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m2037\u001b[0m:\u001b[93m53\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelectorAll' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'querySelectorAll' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m2037\u001b[0m         staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n\u001b[7m    \u001b[0m \u001b[91m                                                    ~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1963\u001b[0m:\u001b[93m58\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'innerHeight' does not exist on type 'never'.\n\n\u001b[7m1963\u001b[0m         ? document.documentElement.scrollHeight - window.innerHeight\n\u001b[7m    \u001b[0m \u001b[91m                                                         ~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1962\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2367): \u001b[0mThis comparison appears to be unintentional because the types 'HTMLElement' and 'Window & typeof globalThis' have no overlap.\n\n\u001b[7m1962\u001b[0m       const scrollHeight = container === window\n\u001b[7m    \u001b[0m \u001b[91m                           ~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1959\u001b[0m:\u001b[93m31\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'Ref<HTMLElement | undefined, HTMLElement | undefined> | Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to parameter of type 'MaybeRef<HTMLElement | undefined> | ComputedRef<HTMLElement | undefined>'.\n  Type 'Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to type 'MaybeRef<HTMLElement | undefined> | ComputedRef<HTMLElement | undefined>'.\n\n\u001b[7m1959\u001b[0m       const container = unref(scrollContainer)\n\u001b[7m    \u001b[0m \u001b[91m                              ~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1934\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2739): \u001b[0mType 'Ref<TElement, TElement> & { [ShallowRefMarker]?: true | undefined; }' is missing the following properties from type 'ComputedRef<TElement | undefined>': effect, [ComputedRefSymbol]\n\n\u001b[7m1934\u001b[0m       currentElement,\n\u001b[7m    \u001b[0m \u001b[91m      ~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1731\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2322): \u001b[0mType 'Timeout' is not assignable to type 'number'.\n\n\u001b[7m1731\u001b[0m       activeProgressInterval.value = progressInterval\n\u001b[7m    \u001b[0m \u001b[91m      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1726\u001b[0m:\u001b[93m52\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2362): \u001b[0mThe left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n\n\u001b[7m1726\u001b[0m           const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n\u001b[7m    \u001b[0m \u001b[91m                                                   ~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1549\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'animate' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1549\u001b[0m         const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n\u001b[7m    \u001b[0m \u001b[91m                             ~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1526\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'style' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1526\u001b[0m           Object.assign(element.style, finalFrame)\n\u001b[7m    \u001b[0m \u001b[91m                                ~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1499\u001b[0m:\u001b[93m40\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'animate' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1499\u001b[0m           const newAnimation = element.animate(customKeyframes as Keyframe[], {\n\u001b[7m    \u001b[0m \u001b[91m                                       ~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1489\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'style' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'style' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1489\u001b[0m           Object.assign(element.style, finalFrame)\n\u001b[7m    \u001b[0m \u001b[91m                                ~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1385\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'ComputedRef<HTMLElement | (() => HTMLElement | undefined) | undefined>' is not assignable to parameter of type 'MaybeComputedElementRef<MaybeElement>'.\n  Type 'ComputedRef<HTMLElement | (() => HTMLElement | undefined) | undefined>' is not assignable to type 'ComputedRef<MaybeElement>'.\n\n\u001b[7m1385\u001b[0m     ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n\u001b[7m    \u001b[0m \u001b[91m                           ~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1264\u001b[0m:\u001b[93m30\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'querySelector' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'querySelector' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1264\u001b[0m       const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n\u001b[7m    \u001b[0m \u001b[91m                             ~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1166\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'getBoundingClientRect' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'getBoundingClientRect' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1166\u001b[0m       const rect = element.getBoundingClientRect()\n\u001b[7m    \u001b[0m \u001b[91m                           ~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1085\u001b[0m:\u001b[93m36\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'getBoundingClientRect' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'getBoundingClientRect' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m1085\u001b[0m               const rect = element.getBoundingClientRect()\n\u001b[7m    \u001b[0m \u001b[91m                                   ~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1082\u001b[0m:\u001b[93m38\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'HTMLElement | (() => HTMLElement | undefined)' is not assignable to parameter of type 'Element'.\n  Type '() => HTMLElement | undefined' is not assignable to type 'Element'.\n\n\u001b[7m1082\u001b[0m               resizeObserver.observe(element)\n\u001b[7m    \u001b[0m \u001b[91m                                     ~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m325\u001b[0m:\u001b[93m26\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'animate' does not exist on type 'HTMLElement | (() => HTMLElement | undefined)'.\n  Property 'animate' does not exist on type '() => HTMLElement | undefined'.\n\n\u001b[7m325\u001b[0m     const anim = element.animate(keyframes as Keyframe[], {\n\u001b[7m   \u001b[0m \u001b[91m                         ~~~~~~~\u001b[0m\n\n\u001b[96msrc/components/composables/useNotifications.ts\u001b[0m:\u001b[93m559\u001b[0m:\u001b[93m23\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type '{ metadata: { realtimeEvent: RealtimeEvent; source: string; }; id?: string | undefined; type?: NotificationType | undefined; priority?: NotificationPriority | undefined; ... 14 more ...; groupId?: string | undefined; }' is not assignable to parameter of type 'Omit<SmartNotification, \"id\" | \"timestamp\" | \"aiScore\" | \"aiPriority\">'.\n  Types of property 'type' are incompatible.\n\n\u001b[7m559\u001b[0m       addNotification({\n\u001b[7m   \u001b[0m \u001b[91m                      ~\u001b[0m\n\u001b[7m560\u001b[0m         ...template,\n\u001b[7m   \u001b[0m \u001b[91m~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[7m...\u001b[0m \n\u001b[7m564\u001b[0m         }","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"c6217044-a8a9-4c39-a4d7-6f90ffcb9dc2","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01CkK6nXF3oSkgg65SJkMavz","type":"message","role":"assistant","content":[{"type":"text","text":"I can see the errors clearly now. Looking at the errors, I notice that my previous fixes didn't work because the `element` variable is still of type `HTMLElement | (() => HTMLElement | undefined)`. The issue is that I assigned `element = unref(target)` but `target` itself is `MaybeRefOrGetter<HTMLElement | undefined>`, and `unref` only unwraps `Ref` types, not getter functions.\n\nI need to use `toValue()` from VueUse instead of `unref()`, as `toValue()` properly handles `MaybeRefOrGetter` types including getter functions.\n\nLet me check if `toValue` is already imported:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3011,"cache_read_input_tokens":50455,"cache_creation":{"ephemeral_5m_input_tokens":3011,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CTvfGZrDVvsARagSpiahx","type":"assistant","uuid":"d97a7362-6dc1-4e5b-90d9-fb4cbcdff001","timestamp":"2025-10-09T00:15:19.044Z"}
{"parentUuid":"d97a7362-6dc1-4e5b-90d9-fb4cbcdff001","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01CkK6nXF3oSkgg65SJkMavz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EKJgp4Hp1cNVTkj7pEeBxa","name":"Bash","input":{"command":"grep -n \"import.*toValue\" src/components/composables/useAnimation.ts","description":"Check if toValue is imported"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3011,"cache_read_input_tokens":50455,"cache_creation":{"ephemeral_5m_input_tokens":3011,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CTvfGZrDVvsARagSpiahx","type":"assistant","uuid":"57867926-b094-4741-9a2d-57d56f3af246","timestamp":"2025-10-09T00:15:19.608Z"}
{"parentUuid":"57867926-b094-4741-9a2d-57d56f3af246","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EKJgp4Hp1cNVTkj7pEeBxa","type":"tool_result","content":"","is_error":false}]},"uuid":"b6e034ea-9482-4d47-9633-0b717ba3093c","timestamp":"2025-10-09T00:15:20.717Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false,"returnCodeInterpretation":"No matches found"}}
{"parentUuid":"b6e034ea-9482-4d47-9633-0b717ba3093c","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012NHrHgpFbm69TKPrrkX1DV","type":"message","role":"assistant","content":[{"type":"text","text":"`toValue` is not imported. Let me check the current imports and add it:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":276,"cache_read_input_tokens":53466,"cache_creation":{"ephemeral_5m_input_tokens":276,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfHCnxnxsbGDjfGBtYg","type":"assistant","uuid":"6ff4e05b-a8ef-4508-b5fb-4a07f830c244","timestamp":"2025-10-09T00:15:24.358Z"}
{"parentUuid":"6ff4e05b-a8ef-4508-b5fb-4a07f830c244","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012NHrHgpFbm69TKPrrkX1DV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0136bCE9xkdo3eA8oudEsntZ","name":"Read","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","offset":1,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":276,"cache_read_input_tokens":53466,"cache_creation":{"ephemeral_5m_input_tokens":276,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfHCnxnxsbGDjfGBtYg","type":"assistant","uuid":"4710a525-e17c-46ca-9481-5ff4407c0a8d","timestamp":"2025-10-09T00:15:25.345Z"}
{"parentUuid":"4710a525-e17c-46ca-9481-5ff4407c0a8d","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0136bCE9xkdo3eA8oudEsntZ","type":"tool_result","content":"     1→import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\n     2→import {\n     3→  useElementVisibility,\n     4→  useDocumentVisibility,\n     5→  usePreferredReducedMotion,\n     6→  useRafFn,\n     7→  useEventBus,\n     8→  useMounted,\n     9→  useBattery,\n    10→  useFps,\n    11→  useIdle,\n    12→  usePageLeave,\n    13→  useAnimate,\n    14→  useCycleList,\n    15→  useScroll,\n    16→  type EventBusKey,\n    17→  type MaybeRefOrGetter,\n    18→  type UseAnimateKeyframes,\n    19→  type UseAnimateOptions,\n    20→} from '@vueuse/core'\n    21→\n    22→// Import existing presets and constants\n    23→import { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n    24→\n    25→// Export preset system for convenient animation configuration\n    26→export { preset, presets } from './useAnimationPresets'\n    27→\n    28→export interface AnimationPreset {\n    29→  keyframes: UseAnimateKeyframes\n    30→  options: number | UseAnimateOptions\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"508cc1da-2504-47d8-a3a5-2e2cb69bad58","timestamp":"2025-10-09T00:15:25.456Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","content":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions","numLines":30,"startLine":1,"totalLines":2683}}}
{"parentUuid":"508cc1da-2504-47d8-a3a5-2e2cb69bad58","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01UzF8akRLaFeHZ5cbK74zKn","type":"message","role":"assistant","content":[{"type":"text","text":"Good! I need to add `toValue` to the imports from `@vueuse/core`. Let me update the import and then fix all the element access errors by replacing `unref` with `toValue`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":34351,"cache_read_input_tokens":53742,"cache_creation":{"ephemeral_5m_input_tokens":34351,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfHaG3nsXrPg7sxeM3U","type":"assistant","uuid":"30af45b6-a504-46e0-83ba-7aecd7d46dd5","timestamp":"2025-10-09T00:15:32.526Z"}
{"parentUuid":"30af45b6-a504-46e0-83ba-7aecd7d46dd5","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01UzF8akRLaFeHZ5cbK74zKn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LPL1kFs2z7WbEVYvxtUXyH","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","old_string":"import {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'","new_string":"import {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":34351,"cache_read_input_tokens":53742,"cache_creation":{"ephemeral_5m_input_tokens":34351,"ephemeral_1h_input_tokens":0},"output_tokens":445,"service_tier":"standard"}},"requestId":"req_011CTvfHaG3nsXrPg7sxeM3U","type":"assistant","uuid":"8aff3df8-aaf0-4072-97a1-47d58001d738","timestamp":"2025-10-09T00:15:37.275Z"}
{"parentUuid":"8aff3df8-aaf0-4072-97a1-47d58001d738","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LPL1kFs2z7WbEVYvxtUXyH","type":"tool_result","content":"The file /Users/natedamstra/socialaize/src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     1→import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\n     2→import {\n     3→  useElementVisibility,\n     4→  useDocumentVisibility,\n     5→  usePreferredReducedMotion,\n     6→  useRafFn,\n     7→  useEventBus,\n     8→  useMounted,\n     9→  useBattery,\n    10→  useFps,\n    11→  useIdle,\n    12→  usePageLeave,\n    13→  useAnimate,\n    14→  useCycleList,\n    15→  useScroll,\n    16→  toValue,\n    17→  type EventBusKey,\n    18→  type MaybeRefOrGetter,\n    19→  type UseAnimateKeyframes,\n    20→  type UseAnimateOptions,\n    21→} from '@vueuse/core'\n    22→\n    23→// Import existing presets and constants\n    24→import { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n    25→"}]},"uuid":"523ffc26-da7e-42c5-9bcd-ac71bdda1c4a","timestamp":"2025-10-09T00:15:37.375Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","oldString":"import {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'","newString":"import {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = unref(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const targetEl = unref(target)\n            if (!targetEl) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              const element = unref(targetEl)\n              if (!element) return\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = unref(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = unref(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":13,"oldLines":6,"newStart":13,"newLines":7,"lines":["   useAnimate,","   useCycleList,","   useScroll,","+  toValue,","   type EventBusKey,","   type MaybeRefOrGetter,","   type UseAnimateKeyframes,"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"523ffc26-da7e-42c5-9bcd-ac71bdda1c4a","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_011KL3zzC5tXR8r3yoAtSpVc","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update all the places where I use `unref(target)` to use `toValue(target)` instead, since `toValue` properly handles `MaybeRefOrGetter` types (including getter functions). Let me systematically fix all the element access errors. I'll start by updating the createAnimation function:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1105,"cache_read_input_tokens":88093,"cache_creation":{"ephemeral_5m_input_tokens":1105,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfJTivdo6W9BDSboRBu","type":"assistant","uuid":"b32fbb0f-d390-47dd-9b12-d92c0622408e","timestamp":"2025-10-09T00:15:43.270Z"}
{"parentUuid":"b32fbb0f-d390-47dd-9b12-d92c0622408e","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_011KL3zzC5tXR8r3yoAtSpVc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ByUG3gWeU4LbaVjJXPWDNz","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","old_string":"    options.onStart?.()\n\n    const element = unref(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {","new_string":"    options.onStart?.()\n\n    const element = toValue(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1105,"cache_read_input_tokens":88093,"cache_creation":{"ephemeral_5m_input_tokens":1105,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfJTivdo6W9BDSboRBu","type":"assistant","uuid":"b8f4ac80-2421-4a55-9b4a-89127eebfd7b","timestamp":"2025-10-09T00:15:45.141Z"}
{"parentUuid":"b8f4ac80-2421-4a55-9b4a-89127eebfd7b","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ByUG3gWeU4LbaVjJXPWDNz","type":"tool_result","content":"The file /Users/natedamstra/socialaize/src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   317→      { opacity: 0 }\n   318→    ]\n   319→    const duration = options.duration || ANIMATION_DURATION.NORMAL\n   320→\n   321→    options.onStart?.()\n   322→\n   323→    const element = toValue(el)\n   324→    if (!element) return\n   325→\n   326→    const anim = element.animate(keyframes as Keyframe[], {\n   327→      duration,\n   328→      easing: options.easing || EASING.EASE_OUT,\n   329→      delay: options.delay || 0,\n   330→      fill: options.fill || FILL_MODE.FORWARDS as FillMode"}]},"uuid":"ba6a0410-54a3-41c0-b1ba-c53daec35320","timestamp":"2025-10-09T00:15:45.250Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","oldString":"    options.onStart?.()\n\n    const element = unref(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {","newString":"    options.onStart?.()\n\n    const element = toValue(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = unref(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const targetEl = unref(target)\n            if (!targetEl) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              const element = unref(targetEl)\n              if (!element) return\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = unref(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = unref(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":320,"oldLines":7,"newStart":320,"newLines":7,"lines":[" ","     options.onStart?.()"," ","-    const element = unref(el)","+    const element = toValue(el)","     if (!element) return"," ","     const anim = element.animate(keyframes as Keyframe[], {"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"ba6a0410-54a3-41c0-b1ba-c53daec35320","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01JT6gCLZCzUPi1zauts7BBt","type":"message","role":"assistant","content":[{"type":"text","text":"Good! Now let me fix the ResizeObserver section (lines 1065-1092):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":498,"cache_read_input_tokens":89198,"cache_creation":{"ephemeral_5m_input_tokens":498,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfK4KnUyFoACimKhT2i","type":"assistant","uuid":"b7bcf283-6002-42f9-b222-ae3574bcee8c","timestamp":"2025-10-09T00:15:49.702Z"}
{"parentUuid":"b7bcf283-6002-42f9-b222-ae3574bcee8c","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01JT6gCLZCzUPi1zauts7BBt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YYGqfkXNebXDSwCzx1EcdC","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","old_string":"      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const targetEl = unref(target)\n            if (!targetEl) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              const element = unref(targetEl)\n              if (!element) return\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )","new_string":"      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const element = toValue(target)\n            if (!element) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":498,"cache_read_input_tokens":89198,"cache_creation":{"ephemeral_5m_input_tokens":498,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfK4KnUyFoACimKhT2i","type":"assistant","uuid":"3c08575e-2741-4048-9aed-405468ac5759","timestamp":"2025-10-09T00:15:56.625Z"}
{"parentUuid":"3c08575e-2741-4048-9aed-405468ac5759","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YYGqfkXNebXDSwCzx1EcdC","type":"tool_result","content":"The file /Users/natedamstra/socialaize/src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1058→        }, responsiveOptions.debounce)\n  1059→      }\n  1060→\n  1061→      // Setup ResizeObserver on mount\n  1062→      watch(\n  1063→        isMounted,\n  1064→        (mounted) => {\n  1065→          if (mounted) {\n  1066→            const element = toValue(target)\n  1067→            if (!element) {\n  1068→              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n  1069→              return\n  1070→            }\n  1071→\n  1072→            try {\n  1073→              // Check if ResizeObserver is supported\n  1074→              if (typeof ResizeObserver === 'undefined') {\n  1075→                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n  1076→                return\n  1077→              }\n  1078→\n  1079→              resizeObserver = new ResizeObserver(updateDimensions)\n  1080→              resizeObserver.observe(element)\n  1081→\n  1082→              // Initial measurement\n  1083→              const rect = element.getBoundingClientRect()\n  1084→              if (rect.width > 0 && rect.height > 0) {\n  1085→                updateDimensions([\n  1086→                  {\n  1087→                    contentRect: rect,\n  1088→                    target: element,\n  1089→                  } as unknown as ResizeObserverEntry,\n  1090→                ])\n  1091→              }\n  1092→            } catch (error) {\n  1093→              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n  1094→            }\n  1095→          }\n  1096→        },\n  1097→        { immediate: true }\n  1098→      )\n  1099→\n  1100→      // Helper functions\n  1101→      const scaleValue = computed(\n  1102→        () => (baseValue: number) => baseValue * dimensions.value.scale"}]},"uuid":"aded86ad-14a2-433a-8c3c-6364dad94042","timestamp":"2025-10-09T00:15:56.768Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","oldString":"      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const targetEl = unref(target)\n            if (!targetEl) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              const element = unref(targetEl)\n              if (!element) return\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )","newString":"      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const element = toValue(target)\n            if (!element) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = toValue(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const targetEl = unref(target)\n            if (!targetEl) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              const element = unref(targetEl)\n              if (!element) return\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = unref(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = unref(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1063,"oldLines":8,"newStart":1063,"newLines":8,"lines":["         isMounted,","         (mounted) => {","           if (mounted) {","-            const targetEl = unref(target)","-            if (!targetEl) {","+            const element = toValue(target)","+            if (!element) {","               console.warn('[useAnimation] Cannot setup responsive system: target element not found')","               return","             }"]},{"oldStart":1076,"oldLines":9,"newStart":1076,"newLines":6,"lines":["                 return","               }"," ","-              const element = unref(targetEl)","-              if (!element) return","-","               resizeObserver = new ResizeObserver(updateDimensions)","               resizeObserver.observe(element)"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"aded86ad-14a2-433a-8c3c-6364dad94042","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Rvjrj4yrRAaaNVvBbJ3mkk","type":"message","role":"assistant","content":[{"type":"text","text":"Good! Now let me fix the SVG scale computation (line 1163):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":1590,"cache_read_input_tokens":89696,"cache_creation":{"ephemeral_5m_input_tokens":1590,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfKtn5gTjvC6v9YDPVR","type":"assistant","uuid":"7759cf25-026f-4ed1-9a2d-f61bec006378","timestamp":"2025-10-09T00:16:02.258Z"}
{"parentUuid":"7759cf25-026f-4ed1-9a2d-f61bec006378","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Rvjrj4yrRAaaNVvBbJ3mkk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019mYfDRbZXvKXzm169f4H3k","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","old_string":"    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = unref(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })","new_string":"    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = toValue(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":1590,"cache_read_input_tokens":89696,"cache_creation":{"ephemeral_5m_input_tokens":1590,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfKtn5gTjvC6v9YDPVR","type":"assistant","uuid":"f0b25730-cec5-4186-b9e0-82e37418e64b","timestamp":"2025-10-09T00:16:05.148Z"}
{"parentUuid":"f0b25730-cec5-4186-b9e0-82e37418e64b","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019mYfDRbZXvKXzm169f4H3k","type":"tool_result","content":"The file /Users/natedamstra/socialaize/src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1155→\n  1156→  if (svg) {\n  1157→    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n  1158→\n  1159→    // Calculate scale factor between SVG space and screen space\n  1160→    const svgScale = computed(() => {\n  1161→      const element = toValue(target)\n  1162→      if (!element) return { x: 1, y: 1 }\n  1163→\n  1164→      const rect = element.getBoundingClientRect()\n  1165→      return {\n  1166→        x: rect.width / svg.viewBox.width,\n  1167→        y: rect.height / svg.viewBox.height,\n  1168→      }\n  1169→    })\n  1170→\n  1171→    // Convert SVG coordinates to screen pixels\n  1172→    const svgToScreen = computed(\n  1173→      () => (svgX: number, svgY: number) => {"}]},"uuid":"2ed0344d-9bcd-408b-835f-988cb3ea4551","timestamp":"2025-10-09T00:16:05.259Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","oldString":"    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = unref(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })","newString":"    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = toValue(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = toValue(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const element = toValue(target)\n            if (!element) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = unref(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = unref(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1158,"oldLines":7,"newStart":1158,"newLines":7,"lines":[" ","     // Calculate scale factor between SVG space and screen space","     const svgScale = computed(() => {","-      const element = unref(target)","+      const element = toValue(target)","       if (!element) return { x: 1, y: 1 }"," ","       const rect = element.getBoundingClientRect()"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"2ed0344d-9bcd-408b-835f-988cb3ea4551","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01T9CEFEpBP2LsdKZzRx3v5x","type":"message","role":"assistant","content":[{"type":"text","text":"Good! Now let me fix the grid zone querySelector (line 1254):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":663,"cache_read_input_tokens":91286,"cache_creation":{"ephemeral_5m_input_tokens":663,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfLXCaUYqzWPR1PzJK5","type":"assistant","uuid":"78e72301-14fb-424f-9fae-623884d11e8e","timestamp":"2025-10-09T00:16:09.329Z"}
{"parentUuid":"78e72301-14fb-424f-9fae-623884d11e8e","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01T9CEFEpBP2LsdKZzRx3v5x","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JskkYwkeuGUKXoo41dqGas","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","old_string":"    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = unref(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement","new_string":"    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = toValue(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":663,"cache_read_input_tokens":91286,"cache_creation":{"ephemeral_5m_input_tokens":663,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfLXCaUYqzWPR1PzJK5","type":"assistant","uuid":"e4da212c-4a5c-4f67-a281-1c34f48f8277","timestamp":"2025-10-09T00:16:12.922Z"}
{"parentUuid":"e4da212c-4a5c-4f67-a281-1c34f48f8277","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JskkYwkeuGUKXoo41dqGas","type":"tool_result","content":"The file /Users/natedamstra/socialaize/src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1246→    const gridTemplateColumns = computed(() => grid.columns)\n  1247→    const gridTemplateRows = computed(() => grid.rows || '1fr')\n  1248→    const gridGap = computed(() => grid.gap || '0')\n  1249→\n  1250→    // Get the bounding rectangle of a grid zone\n  1251→    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n  1252→      const element = toValue(target)\n  1253→      if (!element) return undefined\n  1254→\n  1255→      const zone = grid.zones?.[zoneName]\n  1256→      if (!zone) {\n  1257→        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n  1258→        return undefined\n  1259→      }\n  1260→\n  1261→      // Query for the zone element using data attribute or class\n  1262→      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n  1263→      if (!zoneEl) {\n  1264→        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n  1265→        return undefined\n  1266→      }"}]},"uuid":"b4fa9f9c-adc6-4a51-83fe-35a3d8d76a41","timestamp":"2025-10-09T00:16:13.030Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","oldString":"    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = unref(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement","newString":"    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = toValue(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = toValue(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const element = toValue(target)\n            if (!element) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = toValue(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = unref(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1249,"oldLines":7,"newStart":1249,"newLines":7,"lines":[" ","     // Get the bounding rectangle of a grid zone","     const getZoneRect = (zoneName: string): DOMRect | undefined => {","-      const element = unref(target)","+      const element = toValue(target)","       if (!element) return undefined"," ","       const zone = grid.zones?.[zoneName]"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"b4fa9f9c-adc6-4a51-83fe-35a3d8d76a41","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_016BbPdaMeXsq44SkbMjF8LH","type":"message","role":"assistant","content":[{"type":"text","text":"Good! Now let me fix the animateIn and animateOut functions (lines 1486-1549). I'll fix both at once:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1067,"cache_read_input_tokens":91949,"cache_creation":{"ephemeral_5m_input_tokens":1067,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfM6VZLsrxnM6NWqdkY","type":"assistant","uuid":"2ce69251-2ce5-40ee-87b7-4088b09150a3","timestamp":"2025-10-09T00:16:18.157Z"}
{"parentUuid":"2ce69251-2ce5-40ee-87b7-4088b09150a3","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_016BbPdaMeXsq44SkbMjF8LH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01V4aeGdoJs7ivJyfwva6v2D","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","old_string":"    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }","new_string":"    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = toValue(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = toValue(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1067,"cache_read_input_tokens":91949,"cache_creation":{"ephemeral_5m_input_tokens":1067,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfM6VZLsrxnM6NWqdkY","type":"assistant","uuid":"a35a39a0-f3cc-4c4d-a8c6-96393d403914","timestamp":"2025-10-09T00:16:36.374Z"}
{"parentUuid":"a35a39a0-f3cc-4c4d-a8c6-96393d403914","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01V4aeGdoJs7ivJyfwva6v2D","type":"tool_result","content":"The file /Users/natedamstra/socialaize/src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1476→    )\n  1477→\n  1478→    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n  1479→\n  1480→    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n  1481→      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n  1482→\n  1483→      if (animationQuality.value === 'none' || !canAnimate.value) {\n  1484→        const element = toValue(target)\n  1485→        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n  1486→          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n  1487→          Object.assign(element.style, finalFrame)\n  1488→        }\n  1489→        onComplete?.()\n  1490→        return\n  1491→      }\n  1492→\n  1493→      if (customKeyframes && webAnimAPI.animate.value) {\n  1494→        webAnimAPI.cancel()\n  1495→        const element = toValue(target)\n  1496→        if (element) {\n  1497→          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n  1498→            ...animationOptions.value,\n  1499→            ...customOptions,\n  1500→          })\n  1501→          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n  1502→          return newAnimation\n  1503→        }\n  1504→      } else {\n  1505→        webAnimAPI.play()\n  1506→      }\n  1507→    }\n  1508→\n  1509→    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n  1510→      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n  1511→\n  1512→      if (animationQuality.value === 'none' || !canAnimate.value) {\n  1513→        const element = toValue(target)\n  1514→        if (element) {\n  1515→          const defaultOutKeyframes = [\n  1516→            { opacity: 1, transform: 'scale(1)' },\n  1517→            { opacity: 0, transform: 'scale(0.8)' },\n  1518→          ]\n  1519→          // Handle outKeyframes which might be a Ref or array\n  1520→          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n  1521→          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n  1522→            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n  1523→          }\n  1524→          Object.assign(element.style, finalFrame)\n  1525→        }\n  1526→        onComplete?.()\n  1527→        return\n  1528→      }\n  1529→\n  1530→      const defaultOutKeyframes = [\n  1531→        { opacity: 1, transform: 'scale(1)' },\n  1532→        { opacity: 0, transform: 'scale(0.8)' },\n  1533→      ]\n  1534→      const defaultOutDuration =\n  1535→        animationQuality.value === 'low'\n  1536→          ? ANIMATION_DURATION.FAST * 0.3\n  1537→          : animationQuality.value === 'medium'\n  1538→            ? ANIMATION_DURATION.FAST * 0.6\n  1539→            : ANIMATION_DURATION.FAST\n  1540→      const defaultOutOptions = {\n  1541→        duration: defaultOutDuration,\n  1542→        easing: EASING.EASE_OUT,\n  1543→        fill: FILL_MODE.FORWARDS as FillMode,\n  1544→      }\n  1545→      const element = toValue(target)\n  1546→      if (element) {\n  1547→        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n  1548→          ...defaultOutOptions,\n  1549→          ...outOptions,\n  1550→        })\n  1551→        if (onComplete) anim.addEventListener('finish', onComplete)\n  1552→        return anim\n  1553→      }\n  1554→    }\n  1555→\n  1556→    webAnimation = {\n  1557→      animate: webAnimAPI.animate,\n  1558→      play: webAnimAPI.play,"}]},"uuid":"57206e54-cc12-4458-ac33-726f8e5b3f86","timestamp":"2025-10-09T00:16:36.532Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","oldString":"    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }","newString":"    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = toValue(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = toValue(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = toValue(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const element = toValue(target)\n            if (!element) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = toValue(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = toValue(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = unref(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = unref(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = unref(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1481,"oldLines":7,"newStart":1481,"newLines":7,"lines":["       if (!isMounted.value || !webAnimAPI.isSupported.value) return"," ","       if (animationQuality.value === 'none' || !canAnimate.value) {","-        const element = unref(target)","+        const element = toValue(target)","         if (element && Array.isArray(keyframes) && keyframes.length > 0) {","           const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>","           Object.assign(element.style, finalFrame)"]},{"oldStart":1492,"oldLines":7,"newStart":1492,"newLines":7,"lines":[" ","       if (customKeyframes && webAnimAPI.animate.value) {","         webAnimAPI.cancel()","-        const element = unref(target)","+        const element = toValue(target)","         if (element) {","           const newAnimation = element.animate(customKeyframes as Keyframe[], {","             ...animationOptions.value,"]},{"oldStart":1510,"oldLines":7,"newStart":1510,"newLines":7,"lines":["       if (!isMounted.value || !webAnimAPI.isSupported.value) return"," ","       if (animationQuality.value === 'none' || !canAnimate.value) {","-        const element = unref(target)","+        const element = toValue(target)","         if (element) {","           const defaultOutKeyframes = [","             { opacity: 1, transform: 'scale(1)' },"]},{"oldStart":1542,"oldLines":7,"newStart":1542,"newLines":7,"lines":["         easing: EASING.EASE_OUT,","         fill: FILL_MODE.FORWARDS as FillMode,","       }","-      const element = unref(target)","+      const element = toValue(target)","       if (element) {","         const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {","           ...defaultOutOptions,"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"57206e54-cc12-4458-ac33-726f8e5b3f86","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01S4N9j5H1uWJdM83nwakYdP","type":"message","role":"assistant","content":[{"type":"text","text":"Good! Now let me fix the stagger elements querySelector (line 2037):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3019,"cache_read_input_tokens":93016,"cache_creation":{"ephemeral_5m_input_tokens":3019,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfNqLJ9J74qiMesPHPF","type":"assistant","uuid":"bb3d3383-5e41-4455-bef3-465f082f40ea","timestamp":"2025-10-09T00:16:41.871Z"}
{"parentUuid":"bb3d3383-5e41-4455-bef3-465f082f40ea","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01S4N9j5H1uWJdM83nwakYdP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01T1QwAW9JdrnxpUQexqDhHi","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","old_string":"    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))","new_string":"    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = toValue(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3019,"cache_read_input_tokens":93016,"cache_creation":{"ephemeral_5m_input_tokens":3019,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfNqLJ9J74qiMesPHPF","type":"assistant","uuid":"83241d1b-273f-497f-acf2-48195c01d3bd","timestamp":"2025-10-09T00:16:44.889Z"}
{"parentUuid":"83241d1b-273f-497f-acf2-48195c01d3bd","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01T1QwAW9JdrnxpUQexqDhHi","type":"tool_result","content":"The file /Users/natedamstra/socialaize/src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  2024→    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n  2025→    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n  2026→    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n  2027→\n  2028→    const updateStaggerElements = () => {\n  2029→      if (!isMounted.value) return\n  2030→\n  2031→      const targetEl = toValue(target)\n  2032→      if (!targetEl) return\n  2033→\n  2034→      if (typeof stagger.children === 'string') {\n  2035→        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n  2036→      } else if (Array.isArray(stagger.children)) {\n  2037→        staggerElements.value = stagger.children\n  2038→      } else {\n  2039→        staggerElements.value = unref(stagger.children) || []"}]},"uuid":"92e2d711-c3b2-4146-9592-140af85b4b4f","timestamp":"2025-10-09T00:16:45.002Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","oldString":"    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))","newString":"    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = toValue(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = toValue(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const element = toValue(target)\n            if (!element) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = toValue(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = toValue(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = toValue(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = toValue(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":2028,"oldLines":7,"newStart":2028,"newLines":7,"lines":["     const updateStaggerElements = () => {","       if (!isMounted.value) return"," ","-      const targetEl = unref(target)","+      const targetEl = toValue(target)","       if (!targetEl) return"," ","       if (typeof stagger.children === 'string') {"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"92e2d711-c3b2-4146-9592-140af85b4b4f","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_014tFvxcPdriMnJUXBRtLzpz","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now I need to fix the element access error at line 1385 (useElementVisibility) and the scroll container errors. Let me also update a few more places that use `unref` with `target`. Let me first fix line 1383 where `targetElement` is computed:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":916,"cache_read_input_tokens":96035,"cache_creation":{"ephemeral_5m_input_tokens":916,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfPUG4TT9aUYVHzppF8","type":"assistant","uuid":"84571f47-37bd-466d-98db-0e44ff3876eb","timestamp":"2025-10-09T00:16:54.341Z"}
{"parentUuid":"84571f47-37bd-466d-98db-0e44ff3876eb","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_014tFvxcPdriMnJUXBRtLzpz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013sLKnhEkpFbap4V3H5X2Em","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","old_string":"  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))","new_string":"  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => toValue(target))"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":916,"cache_read_input_tokens":96035,"cache_creation":{"ephemeral_5m_input_tokens":916,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfPUG4TT9aUYVHzppF8","type":"assistant","uuid":"de2d67f8-5030-414c-b9ff-a6d1dbcd6340","timestamp":"2025-10-09T00:16:54.734Z"}
{"parentUuid":"de2d67f8-5030-414c-b9ff-a6d1dbcd6340","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013sLKnhEkpFbap4V3H5X2Em","type":"tool_result","content":"The file /Users/natedamstra/socialaize/src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1374→    })\n  1375→    stopListeners.push(unsubscribe)\n  1376→  }\n  1377→\n  1378→  // ===============================\n  1379→  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  1380→  // ===============================\n  1381→  const targetElement = computed(() => toValue(target))\n  1382→  const elementVisible = autoplay\n  1383→    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n  1384→    : ref(false)\n  1385→  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')"}]},"uuid":"515fb36a-05ec-4337-8740-2a56311d0f0e","timestamp":"2025-10-09T00:16:55.876Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","oldString":"  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))","newString":"  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => toValue(target))","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = toValue(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const element = toValue(target)\n            if (!element) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = toValue(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = toValue(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => unref(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = toValue(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = toValue(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = toValue(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1378,"oldLines":7,"newStart":1378,"newLines":7,"lines":["   // ===============================","   // AUTO-PLAY LOGIC (replaces manual visibility watchers)","   // ===============================","-  const targetElement = computed(() => unref(target))","+  const targetElement = computed(() => toValue(target))","   const elementVisible = autoplay","     ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })","     : ref(false)"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"515fb36a-05ec-4337-8740-2a56311d0f0e","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01DAUNPWwm499XGWme4aqH8W","type":"message","role":"assistant","content":[{"type":"text","text":"Good! Now let me update the todo list to mark Phase 1 as truly completed and move to Phase 3 (scroll container errors):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":486,"cache_read_input_tokens":96951,"cache_creation":{"ephemeral_5m_input_tokens":486,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfQFpETgQ6qg1JuJJDD","type":"assistant","uuid":"aeacf940-fbe5-44e7-af06-597442b36a2d","timestamp":"2025-10-09T00:17:00.716Z"}
{"parentUuid":"aeacf940-fbe5-44e7-af06-597442b36a2d","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01DAUNPWwm499XGWme4aqH8W","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WYvegaL9jX8abzhL9UMqC5","name":"TodoWrite","input":{"todos":[{"content":"Fix element access pattern errors with toValue() (12 errors)","status":"completed","activeForm":"Fixed element access pattern errors with toValue()"},{"content":"Fix nullable function guards (6 errors) - Lines 1623-1625, 1668-1670","status":"completed","activeForm":"Fixed nullable function guards"},{"content":"Fix scroll container type errors (4 errors) - Lines 1949, 1952, 1953, 1959","status":"in_progress","activeForm":"Fixing scroll container type errors"},{"content":"Fix timeout and progress calculation types (2 errors) - Lines 1731, 1726","status":"pending","activeForm":"Fixing timeout and progress calculation types"},{"content":"Fix sequence return type (line 1934)","status":"pending","activeForm":"Fixing sequence return type"},{"content":"Run typecheck and verify all errors are fixed","status":"pending","activeForm":"Running typecheck and verifying all errors are fixed"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":486,"cache_read_input_tokens":96951,"cache_creation":{"ephemeral_5m_input_tokens":486,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfQFpETgQ6qg1JuJJDD","type":"assistant","uuid":"5337c176-7cb9-4b9d-a226-0ee18d4a1772","timestamp":"2025-10-09T00:17:04.200Z"}
{"parentUuid":"5337c176-7cb9-4b9d-a226-0ee18d4a1772","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WYvegaL9jX8abzhL9UMqC5","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"b46da9a6-439f-43e8-b818-c93405770681","timestamp":"2025-10-09T00:17:04.304Z","toolUseResult":{"oldTodos":[{"content":"Fix element access pattern errors (12 errors) - Lines 322, 1076, 1079, 1160, 1258, 1483, 1493, 1516, 1539, 2027","status":"completed","activeForm":"Fixed element access pattern errors"},{"content":"Fix nullable function guards (6 errors) - Lines 1623-1625, 1668-1670","status":"completed","activeForm":"Fixed nullable function guards"},{"content":"Fix scroll container type errors (4 errors) - Lines 1949, 1952, 1953, 1379","status":"in_progress","activeForm":"Fixing scroll container type errors"},{"content":"Fix timeout and progress calculation types (2 errors) - Lines 1721, 1716","status":"pending","activeForm":"Fixing timeout and progress calculation types"},{"content":"Fix sequence return type and ResizeObserver cast (2 errors) - Lines 1924, 1082","status":"pending","activeForm":"Fixing sequence return type and ResizeObserver cast"},{"content":"Run typecheck and verify all errors are fixed","status":"pending","activeForm":"Running typecheck and verifying all errors are fixed"}],"newTodos":[{"content":"Fix element access pattern errors with toValue() (12 errors)","status":"completed","activeForm":"Fixed element access pattern errors with toValue()"},{"content":"Fix nullable function guards (6 errors) - Lines 1623-1625, 1668-1670","status":"completed","activeForm":"Fixed nullable function guards"},{"content":"Fix scroll container type errors (4 errors) - Lines 1949, 1952, 1953, 1959","status":"in_progress","activeForm":"Fixing scroll container type errors"},{"content":"Fix timeout and progress calculation types (2 errors) - Lines 1731, 1726","status":"pending","activeForm":"Fixing timeout and progress calculation types"},{"content":"Fix sequence return type (line 1934)","status":"pending","activeForm":"Fixing sequence return type"},{"content":"Run typecheck and verify all errors are fixed","status":"pending","activeForm":"Running typecheck and verifying all errors are fixed"}]}}
{"parentUuid":"b46da9a6-439f-43e8-b818-c93405770681","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01QVphN84Af7EUjkPtC6s23f","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me fix the scroll container type errors. The issue is that `useScroll` doesn't accept `Window` type directly. I need to handle the Window case separately. Let me read the error context again and fix it:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":378,"cache_read_input_tokens":97437,"cache_creation":{"ephemeral_5m_input_tokens":378,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfQscGkuJuSVhog2aPC","type":"assistant","uuid":"d7f1d6d0-8015-4e7b-821b-06eecef79063","timestamp":"2025-10-09T00:17:09.533Z"}
{"parentUuid":"d7f1d6d0-8015-4e7b-821b-06eecef79063","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01QVphN84Af7EUjkPtC6s23f","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FbaCt3xt8xfkdRUTY5G9Ei","name":"Read","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","offset":1948,"limit":1970}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":378,"cache_read_input_tokens":97437,"cache_creation":{"ephemeral_5m_input_tokens":378,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfQscGkuJuSVhog2aPC","type":"assistant","uuid":"fb3b2286-dc88-47b8-a8bf-6a3b6f951e3f","timestamp":"2025-10-09T00:17:10.311Z"}
{"parentUuid":"fb3b2286-dc88-47b8-a8bf-6a3b6f951e3f","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FbaCt3xt8xfkdRUTY5G9Ei","type":"tool_result","content":"  1948→    | undefined\n  1949→\n  1950→  if (scroll) {\n  1951→    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n  1952→    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n  1953→\n  1954→    const scrollProgress = computed(() => {\n  1955→      if (!isMounted.value) return 0\n  1956→\n  1957→      const container = unref(scrollContainer)\n  1958→      if (!container) return 0\n  1959→\n  1960→      const scrollHeight = container === window\n  1961→        ? document.documentElement.scrollHeight - window.innerHeight\n  1962→        : container.scrollHeight - container.clientHeight\n  1963→\n  1964→      if (scrollHeight <= 0) return 0\n  1965→\n  1966→      const rawProgress = scrollY.value / scrollHeight\n  1967→      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n  1968→\n  1969→      // Apply offsets\n  1970→      const offsetStart = scroll.offset?.start || 0\n  1971→      const offsetEnd = scroll.offset?.end || 0\n  1972→      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n  1973→\n  1974→      // Clamp between threshold values with division-by-zero protection\n  1975→      const denominator = thresholdEnd - thresholdStart\n  1976→      const normalizedProgress = denominator > 0\n  1977→        ? (adjustedProgress - thresholdStart) / denominator\n  1978→        : 0 // Default to 0 if thresholds are equal\n  1979→\n  1980→      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n  1981→\n  1982→      // Safety check for NaN\n  1983→      return isNaN(clampedProgress) ? 0 : clampedProgress\n  1984→    })\n  1985→\n  1986→    // Watch progress and trigger callbacks\n  1987→    watch(scrollProgress, (progress) => {\n  1988→      if (scroll.mode === 'toggle') {\n  1989→        const [thresholdStart] = scroll.threshold || [0, 1]\n  1990→        if (progress >= thresholdStart && !isPlaying.value) {\n  1991→          play()\n  1992→        } else if (progress < thresholdStart && isPlaying.value) {\n  1993→          stop()\n  1994→        }\n  1995→      }\n  1996→\n  1997→      // Single call for all modes (toggle, scrub, or undefined)\n  1998→      scroll.onProgress?.(progress)\n  1999→    })\n  2000→\n  2001→    scrollAnimation = {\n  2002→      progress: scrollProgress,\n  2003→      isScrolling,\n  2004→    }\n  2005→  }\n  2006→\n  2007→  // ===============================\n  2008→  // STAGGER ANIMATIONS\n  2009→  // ===============================\n  2010→  let staggerAnimation:\n  2011→    | {\n  2012→        elements: Ref<HTMLElement[]>\n  2013→        triggerStagger: () => void\n  2014→        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n  2015→        activeAnimations: Ref<Animation[]>\n  2016→      }\n  2017→    | undefined\n  2018→\n  2019→  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n  2020→\n  2021→  if (stagger) {\n  2022→    const staggerElements = ref<HTMLElement[]>([])\n  2023→    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n  2024→    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n  2025→    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n  2026→    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n  2027→\n  2028→    const updateStaggerElements = () => {\n  2029→      if (!isMounted.value) return\n  2030→\n  2031→      const targetEl = toValue(target)\n  2032→      if (!targetEl) return\n  2033→\n  2034→      if (typeof stagger.children === 'string') {\n  2035→        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n  2036→      } else if (Array.isArray(stagger.children)) {\n  2037→        staggerElements.value = stagger.children\n  2038→      } else {\n  2039→        staggerElements.value = unref(stagger.children) || []\n  2040→      }\n  2041→    }\n  2042→\n  2043→    const triggerStagger = async () => {\n  2044→      // Clear any existing timeouts to prevent overlapping animations\n  2045→      activeTimeouts.value.forEach(id => clearTimeout(id))\n  2046→      activeTimeouts.value = []\n  2047→\n  2048→      // Clear any existing animations\n  2049→      activeAnimations.value.forEach(anim => anim.cancel())\n  2050→      activeAnimations.value = []\n  2051→\n  2052→      // Wait for DOM to be ready\n  2053→      await nextTick()\n  2054→      updateStaggerElements()\n  2055→\n  2056→      const elements = staggerElements.value\n  2057→\n  2058→      if (!elements.length) {\n  2059→        return\n  2060→      }\n  2061→\n  2062→      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n  2063→      const shouldReset = stagger.resetOnRestart !== false\n  2064→      if (shouldReset) {\n  2065→        elements.forEach(el => {\n  2066→          // Capture initial state on first run\n  2067→          if (!initialElementStates.has(el)) {\n  2068→            const computedStyle = getComputedStyle(el)\n  2069→            initialElementStates.set(el, {\n  2070→              opacity: computedStyle.opacity,\n  2071→              transform: computedStyle.transform\n  2072→            })\n  2073→          }\n  2074→\n  2075→          // Reset to initial state\n  2076→          const initialState = initialElementStates.get(el)\n  2077→          if (initialState) {\n  2078→            el.style.opacity = initialState.opacity\n  2079→            el.style.transform = initialState.transform\n  2080→          }\n  2081→        })\n  2082→\n  2083→        // Small delay to ensure style reset applies before animation starts\n  2084→        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n  2085→      }\n  2086→\n  2087→      const delays = calculateStaggerDelays(elements.length, stagger)\n  2088→\n  2089→      elements.forEach((el, index) => {\n  2090→        const delay = delays[index]\n  2091→\n  2092→        const timeoutId = setTimeout(() => {\n  2093→          // Skip animation if quality is none or cannot animate\n  2094→          if (!canAnimate.value || animationQuality.value === 'none') {\n  2095→            // Apply final state immediately without animation\n  2096→            if (animation) {\n  2097→              const preset = animation.preset || 'fadeIn'\n  2098→              const presetConfig = animationPresets[preset]\n  2099→              const keyframes = animation.keyframes || presetConfig.keyframes\n  2100→              if (Array.isArray(keyframes) && keyframes.length > 0) {\n  2101→                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n  2102→                Object.assign(el.style, finalFrame)\n  2103→              }\n  2104→            }\n  2105→            return\n  2106→          }\n  2107→\n  2108→          if (animation) {\n  2109→            const preset = animation.preset || 'fadeIn'\n  2110→            const presetConfig = animationPresets[preset]\n  2111→            const keyframes = animation.keyframes || presetConfig.keyframes\n  2112→            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n  2113→            const effectiveDuration = duration * (\n  2114→              animationQuality.value === 'low' ? 0.3 :\n  2115→              animationQuality.value === 'medium' ? 0.6 : 1\n  2116→            )\n  2117→            const easing = animation.easing || EASING.EASE_OUT\n  2118→\n  2119→            // Use Web Animations API for consistency and proper control\n  2120→            const anim = el.animate(keyframes as Keyframe[], {\n  2121→              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n  2122→              easing: easing,\n  2123→              fill: 'forwards' as FillMode\n  2124→            })\n  2125→\n  2126→            activeAnimations.value.push(anim)\n  2127→\n  2128→            // Add completion callback for last element\n  2129→            if (index === elements.length - 1) {\n  2130→              anim.addEventListener('finish', () => {\n  2131→                emit('stagger-complete')\n  2132→\n  2133→                // Handle loop if enabled\n  2134→                if (stagger.loop && isPlaying.value) {\n  2135→                  const loopDelay = stagger.loopDelay || 0\n  2136→                  staggerLoopTimeoutId = setTimeout(() => {\n  2137→                    if (isPlaying.value) {\n  2138→                      triggerStagger()\n  2139→                    }\n  2140→                  }, loopDelay)\n  2141→                }\n  2142→              })\n  2143→            }\n  2144→          }\n  2145→        }, delay)\n  2146→\n  2147→        // Track timeout ID for cleanup\n  2148→        activeTimeouts.value.push(timeoutId)\n  2149→      })\n  2150→    }\n  2151→\n  2152→    // Auto-trigger on mount or play\n  2153→    watch([isMounted, isPlaying], ([mounted, playing]) => {\n  2154→      if (mounted && playing && autoplay) {\n  2155→        nextTick(() => triggerStagger())\n  2156→      } else if (!playing) {\n  2157→        // Clear loop timeout when stopping\n  2158→        if (staggerLoopTimeoutId !== null) {\n  2159→          clearTimeout(staggerLoopTimeoutId)\n  2160→          staggerLoopTimeoutId = null\n  2161→        }\n  2162→      }\n  2163→    }, { immediate: true })\n  2164→\n  2165→    staggerAnimation = {\n  2166→      elements: staggerElements,\n  2167→      triggerStagger,\n  2168→      activeTimeouts,\n  2169→      activeAnimations\n  2170→    }\n  2171→  }\n  2172→\n  2173→  // ===============================\n  2174→  // MOTION PATH ANIMATIONS\n  2175→  // ===============================\n  2176→  let motionPathAnimation:\n  2177→    | {\n  2178→        progress: Ref<number>\n  2179→        setProgress: (progress: number) => void\n  2180→      }\n  2181→    | undefined\n  2182→\n  2183→  if (motionPath) {\n  2184→    const motionProgress = ref(0)\n  2185→    const motionStartTime = ref<number | null>(null)\n  2186→\n  2187→    const setProgress = (progress: number) => {\n  2188→      motionProgress.value = Math.max(0, Math.min(1, progress))\n  2189→      updateMotionPathPosition()\n  2190→    }\n  2191→\n  2192→    const updateMotionPathPosition = () => {\n  2193→      const targetEl = unref(target)\n  2194→      if (!targetEl) return\n  2195→\n  2196→      const progress = motionProgress.value\n  2197→\n  2198→      if (motionPath.type === 'circular') {\n  2199→        const radius = typeof motionPath.radius === 'number'\n  2200→          ? motionPath.radius\n  2201→          : motionPath.radius?.x || 100\n  2202→\n  2203→        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n  2204→        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n  2205→        const angle = startAngle + (direction * 2 * Math.PI * progress)\n  2206→\n  2207→        const x = Math.cos(angle) * radius\n  2208→        const y = Math.sin(angle) * radius\n  2209→\n  2210→        // Set CSS custom properties for flexibility\n  2211→        setCSSVar('--motion-x', `${x}px`)\n  2212→        setCSSVar('--motion-y', `${y}px`)\n  2213→\n  2214→        if (motionPath.autoRotate) {\n  2215→          const rotation = -angle * (180 / Math.PI)\n  2216→          setCSSVar('--motion-rotation', `${rotation}deg`)\n  2217→        } else {\n  2218→          setCSSVar('--motion-rotation', '0deg')\n  2219→        }\n  2220→\n  2221→      } else if (motionPath.type === 'elliptical') {\n  2222→        const radiusX = typeof motionPath.radius === 'object'\n  2223→          ? motionPath.radius.x\n  2224→          : motionPath.radius || 100\n  2225→        const radiusY = typeof motionPath.radius === 'object'\n  2226→          ? motionPath.radius.y\n  2227→          : motionPath.radius || 60\n  2228→\n  2229→        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n  2230→        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n  2231→        const angle = startAngle + (direction * 2 * Math.PI * progress)\n  2232→\n  2233→        const x = Math.cos(angle) * radiusX\n  2234→        const y = Math.sin(angle) * radiusY\n  2235→\n  2236→        // Set CSS custom properties for flexibility\n  2237→        setCSSVar('--motion-x', `${x}px`)\n  2238→        setCSSVar('--motion-y', `${y}px`)\n  2239→\n  2240→        if (motionPath.autoRotate) {\n  2241→          const rotation = -angle * (180 / Math.PI)\n  2242→          setCSSVar('--motion-rotation', `${rotation}deg`)\n  2243→        } else {\n  2244→          setCSSVar('--motion-rotation', '0deg')\n  2245→        }\n  2246→\n  2247→      } else if (motionPath.type === 'custom' && motionPath.path) {\n  2248→        // For custom SVG paths - would need more complex implementation\n  2249→        // This is a placeholder for now\n  2250→        console.warn('Custom motion paths not yet fully implemented')\n  2251→      }\n  2252→    }\n  2253→\n  2254→    // Animation loop for motion path\n  2255→    const motionRafControls = useRafFn(\n  2256→      (args) => {\n  2257→        if (!isPlaying.value || isPaused.value) {\n  2258→          motionRafControls.pause()\n  2259→          return\n  2260→        }\n  2261→\n  2262→        const now = args.timestamp\n  2263→        if (motionStartTime.value === null) {\n  2264→          motionStartTime.value = now\n  2265→        }\n  2266→\n  2267→        const elapsed = now - motionStartTime.value\n  2268→        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n  2269→\n  2270→        updateMotionPathPosition()\n  2271→      },\n  2272→      { immediate: false }\n  2273→    )\n  2274→\n  2275→    // Assign pause/resume to outer scope for use in pause()/resume() functions\n  2276→    pauseMotion = motionRafControls.pause\n  2277→    resumeMotion = motionRafControls.resume\n  2278→\n  2279→    watch(isPlaying, (playing) => {\n  2280→      if (playing) {\n  2281→        // Reset state for new cycle (initialization happens in RAF)\n  2282→        motionRafControls.resume()\n  2283→      } else {\n  2284→        motionRafControls.pause()\n  2285→        motionStartTime.value = null\n  2286→      }\n  2287→    })\n  2288→\n  2289→    motionPathAnimation = {\n  2290→      progress: motionProgress,\n  2291→      setProgress,\n  2292→    }\n  2293→  }\n  2294→\n  2295→  // ===============================\n  2296→  // ANIMATION TIMELINE\n  2297→  // ===============================\n  2298→  if (timeline) {\n  2299→    const timelineStartTime = ref<number | null>(null)\n  2300→    const executedSteps = new Set<number>()\n  2301→\n  2302→    const timelineRafControls = useRafFn(\n  2303→      (args) => {\n  2304→        if (!isPlaying.value || isPaused.value) {\n  2305→          timelineRafControls.pause()\n  2306→          return\n  2307→        }\n  2308→\n  2309→        const now = args.timestamp\n  2310→\n  2311→        // Initialize on first RAF callback instead of relying on watch\n  2312→        if (timelineStartTime.value === null) {\n  2313→          timelineStartTime.value = now\n  2314→        }\n  2315→\n  2316→        const elapsed = now - timelineStartTime.value\n  2317→        const duration = timeline.duration || Infinity\n  2318→\n  2319→        timeline.steps.forEach((step, index) => {\n  2320→          if (executedSteps.has(index)) return\n  2321→\n  2322→          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n  2323→\n  2324→          if (elapsed >= stepTime) {\n  2325→            executeTimelineStep(step)\n  2326→            executedSteps.add(index)\n  2327→          }\n  2328→        })\n  2329→\n  2330→        if (timeline.loop && elapsed >= duration) {\n  2331→          // Reset for loop\n  2332→          timelineStartTime.value = now\n  2333→          executedSteps.clear()\n  2334→        }\n  2335→      },\n  2336→      { immediate: false }\n  2337→    )\n  2338→\n  2339→    // Assign pause/resume to outer scope for use in pause()/resume() functions\n  2340→    pauseTimeline = timelineRafControls.pause\n  2341→    resumeTimeline = timelineRafControls.resume\n  2342→\n  2343→    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n  2344→      switch (step.action) {\n  2345→        case 'play':\n  2346→          if (step.target) {\n  2347→            // Animate a different target\n  2348→            const targetEl = unref(step.target)\n  2349→            if (targetEl && step.animation) {\n  2350→              const preset = step.animation.preset || 'fadeIn'\n  2351→              const presetConfig = animationPresets[preset]\n  2352→              const keyframes = step.animation.keyframes || presetConfig.keyframes\n  2353→              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n  2354→\n  2355→              targetEl.animate(keyframes as Keyframe[], {\n  2356→                duration,\n  2357→                easing: step.animation.easing || EASING.EASE_OUT,\n  2358→                fill: FILL_MODE.FORWARDS as FillMode,\n  2359→              })\n  2360→            }\n  2361→          } else {\n  2362→            play()\n  2363→          }\n  2364→          break\n  2365→        case 'pause':\n  2366→          pause()\n  2367→          break\n  2368→        case 'emit':\n  2369→          if (step.event) {\n  2370→            emit(step.event)\n  2371→          }\n  2372→          break\n  2373→        case 'callback':\n  2374→          step.callback?.()\n  2375→          break\n  2376→      }\n  2377→    }\n  2378→\n  2379→    watch(isPlaying, (playing) => {\n  2380→      if (playing) {\n  2381→        // Reset state for new cycle\n  2382→        executedSteps.clear()\n  2383→        timelineRafControls.resume()\n  2384→      } else {\n  2385→        timelineRafControls.pause()\n  2386→        timelineStartTime.value = null\n  2387→      }\n  2388→    })\n  2389→  }\n  2390→\n  2391→  // ===============================\n  2392→  // ENTER/EXIT PATTERN\n  2393→  // ===============================\n  2394→  if (enterExit) {\n  2395→    const hasEntered = ref(false)\n  2396→\n  2397→    // Set initial state based on trigger value\n  2398→    watch(isMounted, (mounted) => {\n  2399→      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n  2400→        const targetEl = unref(target) as HTMLElement | undefined\n  2401→        if (targetEl) {\n  2402→          const preset = enterExit.exit.preset || 'fadeOut'\n  2403→          const presetConfig = animationPresets[preset]\n  2404→          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n  2405→\n  2406→          // Apply final exit state immediately without animation\n  2407→          if (Array.isArray(keyframes) && keyframes.length > 0) {\n  2408→            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n  2409→            Object.assign(targetEl.style, finalFrame)\n  2410→          }\n  2411→        }\n  2412→      }\n  2413→    }, { immediate: true })\n  2414→\n  2415→    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n  2416→      if (!isMounted.value) return\n  2417→\n  2418→      if (shouldEnter && !wasEntered) {\n  2419→        // Enter animation\n  2420→        enterExit.onEnterStart?.()\n  2421→\n  2422→        if (!enterExit.skipInitial || hasEntered.value) {\n  2423→          const targetEl = unref(target) as HTMLElement | undefined\n  2424→          if (targetEl && enterExit.enter) {\n  2425→            const preset = enterExit.enter.preset || 'fadeIn'\n  2426→            const presetConfig = animationPresets[preset]\n  2427→            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n  2428→            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n  2429→\n  2430→            const anim = targetEl.animate(keyframes as Keyframe[], {\n  2431→              duration,\n  2432→              easing: enterExit.enter.easing || EASING.EASE_OUT,\n  2433→              fill: FILL_MODE.FORWARDS as FillMode,\n  2434→            })\n  2435→\n  2436→            await anim.finished\n  2437→          }\n  2438→        }\n  2439→\n  2440→        hasEntered.value = true\n  2441→        enterExit.onEnterComplete?.()\n  2442→\n  2443→      } else if (!shouldEnter && wasEntered) {\n  2444→        // Exit animation\n  2445→        enterExit.onExitStart?.()\n  2446→\n  2447→        if (!enterExit.skipInitial) {\n  2448→          const targetEl = unref(target) as HTMLElement | undefined\n  2449→          if (targetEl && enterExit.exit) {\n  2450→            const preset = enterExit.exit.preset || 'fadeOut'\n  2451→            const presetConfig = animationPresets[preset]\n  2452→            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n  2453→            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n  2454→\n  2455→            const anim = targetEl.animate(keyframes as Keyframe[], {\n  2456→              duration,\n  2457→              easing: enterExit.exit.easing || EASING.EASE_OUT,\n  2458→              fill: FILL_MODE.FORWARDS as FillMode,\n  2459→            })\n  2460→\n  2461→            await anim.finished\n  2462→          }\n  2463→        }\n  2464→\n  2465→        enterExit.onExitComplete?.()\n  2466→      }\n  2467→    }, { immediate: !enterExit.skipInitial })\n  2468→  }\n  2469→\n  2470→  // ===============================\n  2471→  // CSS VARIABLE INTEGRATION\n  2472→  // ===============================\n  2473→  const cssVarWatchers: Array<() => void> = []\n  2474→  const appliedCSSVars = new Set<string>()\n  2475→\n  2476→  const setCSSVar = (name: string, value: string | number) => {\n  2477→    const targetEl = unref(target) as HTMLElement | undefined\n  2478→    if (!targetEl) return\n  2479→\n  2480→    const varName = name.startsWith('--') ? name : `--${name}`\n  2481→    targetEl.style.setProperty(varName, String(value))\n  2482→    appliedCSSVars.add(varName)\n  2483→  }\n  2484→\n  2485→  const getCSSVar = (name: string): string | undefined => {\n  2486→    const targetEl = unref(target) as HTMLElement | undefined\n  2487→    if (!targetEl) return undefined\n  2488→\n  2489→    const varName = name.startsWith('--') ? name : `--${name}`\n  2490→    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  2491→  }\n  2492→\n  2493→  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n  2494→    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n  2495→      return watch(\n  2496→        valueRef,\n  2497→        (value) => {\n  2498→          setCSSVar(name, value)\n  2499→        },\n  2500→        { immediate: true }\n  2501→      )\n  2502→    })\n  2503→\n  2504→    cssVarWatchers.push(...stopHandles)\n  2505→\n  2506→    return () => {\n  2507→      stopHandles.forEach(stop => stop())\n  2508→    }\n  2509→  }\n  2510→\n  2511→  // ===============================\n  2512→  // CLEANUP\n  2513→  // ===============================\n  2514→  const cleanup = () => {\n  2515→    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n  2516→    isPlaying.value = false\n  2517→    isPaused.value = false\n  2518→\n  2519→    // Stop all RAF loops BEFORE state reset\n  2520→    pauseSequence?.()\n  2521→    pauseMotion?.()\n  2522→    pauseTimeline?.()\n  2523→\n  2524→    // Cleanup responsive system\n  2525→    cleanupResponsive?.()\n  2526→\n  2527→    // Now call stop() to cleanup other resources\n  2528→    stop()\n  2529→\n  2530→    // Remove all CSS variables\n  2531→    const targetEl = unref(target) as HTMLElement | undefined\n  2532→    if (targetEl) {\n  2533→      appliedCSSVars.forEach(varName => {\n  2534→        targetEl.style.removeProperty(varName)\n  2535→      })\n  2536→      appliedCSSVars.clear()\n  2537→    }\n  2538→\n  2539→    // Remove finish listeners\n  2540→    const anim = webAnimation?.animate.value\n  2541→    if (anim && finishListeners.has(anim)) {\n  2542→      const listener = finishListeners.get(anim)!\n  2543→      anim.removeEventListener('finish', listener)\n  2544→      finishListeners.delete(anim)\n  2545→    }\n  2546→\n  2547→    // Cleanup event listeners\n  2548→    stopListeners.forEach((unsubscribe) => unsubscribe())\n  2549→    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n  2550→\n  2551→    // Cancel animations\n  2552→    webAnimation?.cancel()\n  2553→\n  2554→    // Cleanup progress interval and watcher\n  2555→    if (activeProgressInterval.value !== null) {\n  2556→      clearInterval(activeProgressInterval.value)\n  2557→      activeProgressInterval.value = null\n  2558→    }\n  2559→    progressWatchStop?.() // Stop the progress watch itself\n  2560→\n  2561→    // Cleanup navigation listeners (Issue #3)\n  2562→    navigationCleanup.value?.()\n  2563→    navigationCleanup.value = null\n  2564→\n  2565→    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n  2566→    if (staggerAnimation?.activeTimeouts) {\n  2567→      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n  2568→      staggerAnimation.activeTimeouts.value = []\n  2569→    }\n  2570→    if (staggerAnimation?.activeAnimations) {\n  2571→      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n  2572→      staggerAnimation.activeAnimations.value = []\n  2573→    }\n  2574→    // Clear stagger loop timeout\n  2575→    if (stagger && staggerLoopTimeoutId !== null) {\n  2576→      clearTimeout(staggerLoopTimeoutId)\n  2577→      staggerLoopTimeoutId = null\n  2578→    }\n  2579→\n  2580→    // Reset state refs\n  2581→    if (motionPathAnimation) {\n  2582→      motionPathAnimation.progress.value = 0\n  2583→    }\n  2584→    if (timedSequence) {\n  2585→      timedSequence.currentIndex.value = 0\n  2586→      timedSequence.cycleIndex.value = 0\n  2587→    }\n  2588→\n  2589→    // Unregister consumer and cleanup state cache if no consumers remain\n  2590→    if (stateName && stateConsumers.has(stateName)) {\n  2591→      const consumers = stateConsumers.get(stateName)!\n  2592→      consumers.delete(consumerId)\n  2593→\n  2594→      // Issue #6 Fix: Use nextTick for atomic cleanup\n  2595→      cleanupStateName(stateName, consumers)\n  2596→    }\n  2597→  }\n  2598→\n  2599→  // Only register onUnmounted if we're in a component context\n  2600→  // getCurrentInstance returns null if called outside setup()\n  2601→  if (getCurrentInstance()) {\n  2602→    onUnmounted(cleanup)\n  2603→  }\n  2604→  // Note: If not in component context, caller must manually call cleanup()\n  2605→  // This is expected for tests and utilities that create animations dynamically\n  2606→\n  2607→  // ===============================\n  2608→  // RETURN API\n  2609→  // ===============================\n  2610→  return {\n  2611→    // Playback controls\n  2612→    play,\n  2613→    pause,\n  2614→    stop,\n  2615→    resume,\n  2616→\n  2617→    // State\n  2618→    isPlaying,\n  2619→    state,\n  2620→\n  2621→    // Events\n  2622→    emit,\n  2623→    on,\n  2624→\n  2625→    // Environment\n  2626→    canAnimate,\n  2627→    animationQuality,\n  2628→    shouldPauseAnimations,\n  2629→\n  2630→    // Web Animations\n  2631→    ...(webAnimation && {\n  2632→      animate: webAnimation.animate,\n  2633→      animateIn: webAnimation.animateIn,\n  2634→      animateOut: webAnimation.animateOut,\n  2635→    }),\n  2636→\n  2637→    // Timed Sequence\n  2638→    ...(timedSequence && {\n  2639→      sequence: timedSequence,\n  2640→    }),\n  2641→\n  2642→    // Scroll\n  2643→    ...(scrollAnimation && {\n  2644→      scroll: scrollAnimation,\n  2645→    }),\n  2646→\n  2647→    // Stagger\n  2648→    ...(staggerAnimation && {\n  2649→      stagger: staggerAnimation,\n  2650→    }),\n  2651→\n  2652→    // Motion Path\n  2653→    ...(motionPathAnimation && {\n  2654→      motionPath: motionPathAnimation,\n  2655→    }),\n  2656→\n  2657→    // Responsive (if enabled)\n  2658→    ...(responsiveSystem && {\n  2659→      responsive: responsiveSystem,\n  2660→    }),\n  2661→\n  2662→    // SVG ViewBox (if enabled)\n  2663→    ...(svgSystem && {\n  2664→      svg: svgSystem,\n  2665→    }),\n  2666→\n  2667→    // Grid Zones (if enabled)\n  2668→    ...(gridSystem && {\n  2669→      grid: gridSystem,\n  2670→    }),\n  2671→\n  2672→    // CSS Variables\n  2673→    setCSSVar,\n  2674→    getCSSVar,\n  2675→    syncCSSVars,\n  2676→\n  2677→    // Cleanup\n  2678→    cleanup,\n  2679→  }\n  2680→}\n  2681→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"97942d0f-15b3-4452-aa7d-0e625d72d409","timestamp":"2025-10-09T00:17:10.386Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","content":"    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = toValue(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","numLines":734,"startLine":1948,"totalLines":2681}}}
{"parentUuid":"97942d0f-15b3-4452-aa7d-0e625d72d409","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Gaskd56sZcXzSPcwSekZht","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me look at the scroll container code more carefully. The problem is on line 1951-1957. Let me fix the scroll container handling:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":34383,"cache_read_input_tokens":97815,"cache_creation":{"ephemeral_5m_input_tokens":34383,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfRQAoSvzYhDab9wgmc","type":"assistant","uuid":"c7dca1b1-8186-4a00-ba0a-a697ddf6577a","timestamp":"2025-10-09T00:17:17.361Z"}
{"parentUuid":"c7dca1b1-8186-4a00-ba0a-a697ddf6577a","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Gaskd56sZcXzSPcwSekZht","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TiRm8bYiJ9tXWtk16EgDB7","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","old_string":"  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight","new_string":"  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = toValue(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":34383,"cache_read_input_tokens":97815,"cache_creation":{"ephemeral_5m_input_tokens":34383,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfRQAoSvzYhDab9wgmc","type":"assistant","uuid":"77f6ad2b-8eb4-416f-9399-7bb6f6de4a8c","timestamp":"2025-10-09T00:17:21.218Z"}
{"parentUuid":"77f6ad2b-8eb4-416f-9399-7bb6f6de4a8c","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TiRm8bYiJ9tXWtk16EgDB7","type":"tool_result","content":"The file /Users/natedamstra/socialaize/src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1946→        isScrolling: Ref<boolean>\n  1947→      }\n  1948→    | undefined\n  1949→\n  1950→  if (scroll) {\n  1951→    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n  1952→    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n  1953→\n  1954→    const scrollProgress = computed(() => {\n  1955→      if (!isMounted.value) return 0\n  1956→\n  1957→      const container = toValue(scrollContainer)\n  1958→      if (!container) return 0\n  1959→\n  1960→      const scrollHeight = container === window\n  1961→        ? document.documentElement.scrollHeight - window.innerHeight\n  1962→        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight\n  1963→\n  1964→      if (scrollHeight <= 0) return 0\n  1965→\n  1966→      const rawProgress = scrollY.value / scrollHeight"}]},"uuid":"501b7c00-fa24-4ed8-8237-007551b5c6bb","timestamp":"2025-10-09T00:17:21.321Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","oldString":"  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight","newString":"  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = toValue(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = toValue(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const element = toValue(target)\n            if (!element) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = toValue(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = toValue(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => toValue(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = toValue(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = toValue(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = unref(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : container.scrollHeight - container.clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = toValue(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1954,"oldLines":12,"newStart":1954,"newLines":12,"lines":["     const scrollProgress = computed(() => {","       if (!isMounted.value) return 0"," ","-      const container = unref(scrollContainer)","+      const container = toValue(scrollContainer)","       if (!container) return 0"," ","       const scrollHeight = container === window","         ? document.documentElement.scrollHeight - window.innerHeight","-        : container.scrollHeight - container.clientHeight","+        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight"," ","       if (scrollHeight <= 0) return 0"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"501b7c00-fa24-4ed8-8237-007551b5c6bb","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013kAQaCoRVZ2BCKeXHrrvdT","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now let me mark Phase 3 as completed and move to Phase 4. Let me run a quick typecheck to see the remaining errors:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":751,"cache_read_input_tokens":132198,"cache_creation":{"ephemeral_5m_input_tokens":751,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfSAVZDVGQqfuXW7Hsw","type":"assistant","uuid":"74cdba6b-61b7-407f-9785-1926cc21750e","timestamp":"2025-10-09T00:17:27.394Z"}
{"parentUuid":"74cdba6b-61b7-407f-9785-1926cc21750e","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013kAQaCoRVZ2BCKeXHrrvdT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VJvLHBt2AvzneqcBYvKqdb","name":"Bash","input":{"command":"npm run typecheck 2>&1 | grep -A 2 \"error ts\"","description":"Check remaining type errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":751,"cache_read_input_tokens":132198,"cache_creation":{"ephemeral_5m_input_tokens":751,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfSAVZDVGQqfuXW7Hsw","type":"assistant","uuid":"e7c6cec8-152c-4631-a8a9-18933f18a0c0","timestamp":"2025-10-09T00:17:28.364Z"}
{"parentUuid":"e7c6cec8-152c-4631-a8a9-18933f18a0c0","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VJvLHBt2AvzneqcBYvKqdb","type":"tool_result","content":"","is_error":false}]},"uuid":"c32669cf-cf9d-487f-81c8-ec01ff1ef062","timestamp":"2025-10-09T00:17:57.625Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false,"returnCodeInterpretation":"No matches found"}}
{"parentUuid":"c32669cf-cf9d-487f-81c8-ec01ff1ef062","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01UXsprGNd1Gi9jN4khwtLJH","type":"message","role":"assistant","content":[{"type":"text","text":"Let me run full typecheck to count errors:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":381,"cache_read_input_tokens":132949,"cache_creation":{"ephemeral_5m_input_tokens":381,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CTvfUr9LErLuYqsiwh8nL","type":"assistant","uuid":"373343e0-6c56-42d4-b82c-3f81625ed0a2","timestamp":"2025-10-09T00:18:03.104Z"}
{"parentUuid":"373343e0-6c56-42d4-b82c-3f81625ed0a2","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01UXsprGNd1Gi9jN4khwtLJH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PMmcyyCtgXwBsPhAwBMDg9","name":"Bash","input":{"command":"npm run typecheck 2>&1 | grep -c \"error ts\" || echo \"0\"","description":"Count total typecheck errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":381,"cache_read_input_tokens":132949,"cache_creation":{"ephemeral_5m_input_tokens":381,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CTvfUr9LErLuYqsiwh8nL","type":"assistant","uuid":"36a2f93c-2716-4d64-b788-6f9666bbf91a","timestamp":"2025-10-09T00:18:03.925Z"}
{"parentUuid":"36a2f93c-2716-4d64-b788-6f9666bbf91a","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PMmcyyCtgXwBsPhAwBMDg9","type":"tool_result","content":"0\n0","is_error":false}]},"uuid":"463acb58-0790-470f-b1f5-0cd8e857a758","timestamp":"2025-10-09T00:18:32.640Z","toolUseResult":{"stdout":"0\n0","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"463acb58-0790-470f-b1f5-0cd8e857a758","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01G9m3jHgg8uyPYz9WuSWZ8a","type":"message","role":"assistant","content":[{"type":"text","text":"Excellent! All type errors are now fixed! Let me run the full typecheck one more time to verify:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":120,"cache_read_input_tokens":133330,"cache_creation":{"ephemeral_5m_input_tokens":120,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CTvfXRCENnTEa5scSMtQ8","type":"assistant","uuid":"bbd7b4fc-e83b-4053-90bc-2e1efbd90327","timestamp":"2025-10-09T00:18:37.583Z"}
{"parentUuid":"bbd7b4fc-e83b-4053-90bc-2e1efbd90327","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01G9m3jHgg8uyPYz9WuSWZ8a","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01F5Y2PmBif73bscv6mVB2j4","name":"Bash","input":{"command":"npm run typecheck","description":"Run full typecheck to verify fixes","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":120,"cache_read_input_tokens":133330,"cache_creation":{"ephemeral_5m_input_tokens":120,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CTvfXRCENnTEa5scSMtQ8","type":"assistant","uuid":"92691e12-dc6b-4510-ae88-935a27582342","timestamp":"2025-10-09T00:18:38.312Z"}
{"parentUuid":"92691e12-dc6b-4510-ae88-935a27582342","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"> socialaize@0.0.1 typecheck\n> astro check --minimumSeverity=error\n\n17:18:43 [@astrojs/cloudflare] Enabling sessions with Cloudflare KV with the \"SOCIALAIZE\" KV binding.\n17:18:43 [@astrojs/cloudflare] If you see the error \"Invalid binding `SOCIALAIZE`\" in your build output, you need to add the binding to your wrangler config file.\n17:18:44 [content] Syncing content\n17:18:44 [content] Synced content\n17:18:44 [types] Generated 396ms\n17:18:44 [check] Getting diagnostics for Astro files in /Users/natedamstra/socialaize...\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1961\u001b[0m:\u001b[93m58\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'innerHeight' does not exist on type 'never'.\n\n\u001b[7m1961\u001b[0m         ? document.documentElement.scrollHeight - window.innerHeight\n\u001b[7m    \u001b[0m \u001b[91m                                                         ~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1960\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2367): \u001b[0mThis comparison appears to be unintentional because the types 'HTMLElement' and 'Window & typeof globalThis' have no overlap.\n\n\u001b[7m1960\u001b[0m       const scrollHeight = container === window\n\u001b[7m    \u001b[0m \u001b[91m                           ~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1957\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'Ref<HTMLElement | undefined, HTMLElement | undefined> | Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to parameter of type 'MaybeRefOrGetter<HTMLElement | undefined>'.\n  Type 'Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to type 'MaybeRefOrGetter<HTMLElement | undefined>'.\n\n\u001b[7m1957\u001b[0m       const container = toValue(scrollContainer)\n\u001b[7m    \u001b[0m \u001b[91m                                ~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1932\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2739): \u001b[0mType 'Ref<TElement, TElement> & { [ShallowRefMarker]?: true | undefined; }' is missing the following properties from type 'ComputedRef<TElement | undefined>': effect, [ComputedRefSymbol]\n\n\u001b[7m1932\u001b[0m       currentElement,\n\u001b[7m    \u001b[0m \u001b[91m      ~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1729\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2322): \u001b[0mType 'Timeout' is not assignable to type 'number'.\n\n\u001b[7m1729\u001b[0m       activeProgressInterval.value = progressInterval\n\u001b[7m    \u001b[0m \u001b[91m      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1724\u001b[0m:\u001b[93m52\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2362): \u001b[0mThe left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n\n\u001b[7m1724\u001b[0m           const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n\u001b[7m    \u001b[0m \u001b[91m                                                   ~~~~~~~~~~~~~~~~\u001b[0m\n\n\u001b[96msrc/components/composables/useNotifications.ts\u001b[0m:\u001b[93m559\u001b[0m:\u001b[93m23\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type '{ metadata: { realtimeEvent: RealtimeEvent; source: string; }; id?: string | undefined; type?: NotificationType | undefined; priority?: NotificationPriority | undefined; ... 14 more ...; groupId?: string | undefined; }' is not assignable to parameter of type 'Omit<SmartNotification, \"id\" | \"timestamp\" | \"aiScore\" | \"aiPriority\">'.\n  Types of property 'type' are incompatible.\n\n\u001b[7m559\u001b[0m       addNotification({\n\u001b[7m   \u001b[0m \u001b[91m                      ~\u001b[0m\n\u001b[7m560\u001b[0m         ...template,\n\u001b[7m   \u001b[0m \u001b[91m~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[7m...\u001b[0m \n\u001b[7m564\u001b[0m         }\n\u001b[7m   \u001b[0m \u001b[91m~~~~~~~~~\u001b[0m\n\u001b[7m565\u001b[0m       });\n\u001b[7m   \u001b[0m \u001b[91m~~~~~~~\u001b[0m\n\n\u001b[96msrc/components/composables/useResponsiveContainer.ts\u001b[0m:\u001b[93m71\u001b[0m:\u001b[93m23\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2352): \u001b[0mConversion of type '{ contentRect: DOMRect; target: HTMLElement; }' to type 'ResizeObserverEntry' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.\n  Type '{ contentRect: DOMRect; target: HTMLElement; }' is missing the following properties from type 'ResizeObserverEntry': borderBoxSize, contentBoxSize, devicePixelContentBoxSize\n\n\u001b[7m71\u001b[0m     updateDimensions([{\n\u001b[7m  \u001b[0m \u001b[91m                      ~\u001b[0m\n\u001b[7m72\u001b[0m       contentRect: rect,\n\u001b[7m  \u001b[0m \u001b[91m~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[7m73\u001b[0m       target: containerRef.value\n\u001b[7m  \u001b[0m \u001b[91m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[7m74\u001b[0m     } as ResizeObserverEntry])\n\u001b[7m  \u001b[0m \u001b[91m~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n\u001b[96msrc/components/composables/useStripe.ts\u001b[0m:\u001b[93m290\u001b[0m:\u001b[93m64\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2366): \u001b[0mFunction lacks ending return statement and return type does not include 'undefined'.\n\n\u001b[7m290\u001b[0m   const mountCheckout = async (element: HTMLElement | string): Promise<boolean> => {\n\u001b[7m   \u001b[0m \u001b[91m                         \n\n... [45869 characters truncated] ...\n\n $permissions: string[]; oauthAccountId: string; ... 4 more ...; sourceTeamId?: string | ... 1 more ... | undefined; }' is missing the following properties from type '{ $id: string; $createdAt: string; $updatedAt: string; $permissions: string[]; oauthAccountId: string; requestedBy: string; message?: string | null | undefined; title?: string | null | undefined; ... 7 more ...; sourceTeamId?: string | ... 1 more ... | undefined; }': $id, $createdAt, $updatedAt\n\n\u001b[7m 39\u001b[0m       {\n\u001b[7m   \u001b[0m \u001b[91m      ~\u001b[0m\n\u001b[7m 40\u001b[0m         ...data,\n\u001b[7m   \u001b[0m \u001b[91m~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[7m...\u001b[0m \n\u001b[7m 44\u001b[0m         processedAt: null,\n\u001b[7m   \u001b[0m \u001b[91m~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[7m 45\u001b[0m       },\n\u001b[7m   \u001b[0m \u001b[91m~~~~~~~\u001b[0m\n\n\u001b[96msrc/stores/hub/socialHubStore.ts\u001b[0m:\u001b[93m419\u001b[0m:\u001b[93m9\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2741): \u001b[0mProperty '$permissions' is missing in type '{ $id: string; displayName: string; handle: string | undefined; avatarId: string | undefined; avatarUrl: string | undefined; userPlatformId: string; platform: \"mastodon\" | \"bluesky\" | ... 6 more ... | \"youtube\"; $createdAt: string; $updatedAt: string; }' but required in type '{ platform: \"mastodon\" | \"bluesky\" | \"instagram\" | \"facebook\" | \"threads\" | \"tiktok\" | \"linkedin\" | \"pinterest\" | \"youtube\"; $id: string; $createdAt: string; $updatedAt: string; $permissions: string[]; ... 11 more ...; miscData?: string | ... 1 more ... | undefined; }'.\n\n\u001b[7m419\u001b[0m         content.author = {\n\u001b[7m   \u001b[0m \u001b[91m        ~~~~~~~~~~~~~~\u001b[0m\n\n\u001b[96msrc/stores/providers/tiktokStore.ts\u001b[0m:\u001b[93m25\u001b[0m:\u001b[93m34\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2307): \u001b[0mCannot find module '@appwrite/schemas/tiktokVideo' or its corresponding type declarations.\n\n\u001b[7m25\u001b[0m import type { TiktokVideo } from \"@appwrite/schemas/tiktokVideo\";\n\u001b[7m  \u001b[0m \u001b[91m                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n\u001b[96msrc/types/pricing.ts\u001b[0m:\u001b[93m53\u001b[0m:\u001b[93m3\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2739): \u001b[0mType '{ name: any; description: any; billingKey: any; monthlyPrice: any; yearlyPrice: any; connectionsMax: any; teamsMax: any; usersMax: any; storageMax: any; aiCreditsMax: any; encodingEnabled: any; chatEnabled: any; unlimitedExecutions: any; isPopular: any; buttonText: any; }' is missing the following properties from type 'UnifiedPricingTier': $id, $createdAt, $updatedAt, $permissions\n\n\u001b[7m53\u001b[0m   return {\n\u001b[7m  \u001b[0m \u001b[91m  ~~~~~~\u001b[0m\n\u001b[96msrc/types/pricing.ts\u001b[0m:\u001b[93m28\u001b[0m:\u001b[93m3\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2739): \u001b[0mType '{ id: string; name: string; description: string; billingKey: string; monthlyPrice: number; yearlyPrice: number; connectionsMax: number; teamsMax: number; usersMax: number; storageMax: number; aiCreditsMax: number; ... 6 more ...; buttonText: string; }' is missing the following properties from type 'UnifiedPricingTier': $id, $createdAt, $updatedAt, $permissions\n\n\u001b[7m28\u001b[0m   return {\n\u001b[7m  \u001b[0m \u001b[91m  ~~~~~~\u001b[0m\n\n\u001b[96msrc/utils/adminUsageQueries.ts\u001b[0m:\u001b[93m231\u001b[0m:\u001b[93m42\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'string | null' is not assignable to parameter of type 'QueryTypes'.\n  Type 'null' is not assignable to type 'QueryTypes'.\n\n\u001b[7m231\u001b[0m         Query.lessThanEqual('timestamp', endOfDay.toISO()),\n\u001b[7m   \u001b[0m \u001b[91m                                         ~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/utils/adminUsageQueries.ts\u001b[0m:\u001b[93m230\u001b[0m:\u001b[93m45\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'string | null' is not assignable to parameter of type 'QueryTypes'.\n  Type 'null' is not assignable to type 'QueryTypes'.\n\n\u001b[7m230\u001b[0m         Query.greaterThanEqual('timestamp', startOfDay.toISO()),\n\u001b[7m   \u001b[0m \u001b[91m                                            ~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/utils/adminUsageQueries.ts\u001b[0m:\u001b[93m89\u001b[0m:\u001b[93m42\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'string | null' is not assignable to parameter of type 'QueryTypes'.\n  Type 'null' is not assignable to type 'QueryTypes'.\n\n\u001b[7m89\u001b[0m         Query.lessThanEqual('timestamp', endOfDay.toISO()),\n\u001b[7m  \u001b[0m \u001b[91m                                         ~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/utils/adminUsageQueries.ts\u001b[0m:\u001b[93m88\u001b[0m:\u001b[93m45\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'string | null' is not assignable to parameter of type 'QueryTypes'.\n  Type 'null' is not assignable to type 'QueryTypes'.\n\n\u001b[7m88\u001b[0m         Query.greaterThanEqual('timestamp', startOfDay.toISO()),\n\u001b[7m  \u001b[0m \u001b[91m                                            ~~~~~~~~~~~~~~~~~~\u001b[0m\n\n\u001b[96msrc/utils/analytics/dataTransformationPipeline.ts\u001b[0m:\u001b[93m200\u001b[0m:\u001b[93m61\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'PartialDataTransformationConfig' is not assignable to parameter of type 'Partial<DataTransformationConfig>'.\n  Types of property 'validation' are incompatible.\n\n\u001b[7m200\u001b[0m     this.config = this.mergeConfig(DEFAULT_PIPELINE_CONFIG, config);\n\u001b[7m   \u001b[0m \u001b[91m                                                            ~~~~~~\u001b[0m\n\nResult (274 files): \n- 67 errors","is_error":true,"tool_use_id":"toolu_01F5Y2PmBif73bscv6mVB2j4"}]},"uuid":"6042c44b-8127-4e87-8b39-71014f53bc6f","timestamp":"2025-10-09T00:19:04.843Z","toolUseResult":"Error: > socialaize@0.0.1 typecheck\n> astro check --minimumSeverity=error\n\n17:18:43 [@astrojs/cloudflare] Enabling sessions with Cloudflare KV with the \"SOCIALAIZE\" KV binding.\n17:18:43 [@astrojs/cloudflare] If you see the error \"Invalid binding `SOCIALAIZE`\" in your build output, you need to add the binding to your wrangler config file.\n17:18:44 [content] Syncing content\n17:18:44 [content] Synced content\n17:18:44 [types] Generated 396ms\n17:18:44 [check] Getting diagnostics for Astro files in /Users/natedamstra/socialaize...\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1961\u001b[0m:\u001b[93m58\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2339): \u001b[0mProperty 'innerHeight' does not exist on type 'never'.\n\n\u001b[7m1961\u001b[0m         ? document.documentElement.scrollHeight - window.innerHeight\n\u001b[7m    \u001b[0m \u001b[91m                                                         ~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1960\u001b[0m:\u001b[93m28\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2367): \u001b[0mThis comparison appears to be unintentional because the types 'HTMLElement' and 'Window & typeof globalThis' have no overlap.\n\n\u001b[7m1960\u001b[0m       const scrollHeight = container === window\n\u001b[7m    \u001b[0m \u001b[91m                           ~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1957\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'Ref<HTMLElement | undefined, HTMLElement | undefined> | Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to parameter of type 'MaybeRefOrGetter<HTMLElement | undefined>'.\n  Type 'Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to type 'MaybeRefOrGetter<HTMLElement | undefined>'.\n\n\u001b[7m1957\u001b[0m       const container = toValue(scrollContainer)\n\u001b[7m    \u001b[0m \u001b[91m                                ~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1932\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2739): \u001b[0mType 'Ref<TElement, TElement> & { [ShallowRefMarker]?: true | undefined; }' is missing the following properties from type 'ComputedRef<TElement | undefined>': effect, [ComputedRefSymbol]\n\n\u001b[7m1932\u001b[0m       currentElement,\n\u001b[7m    \u001b[0m \u001b[91m      ~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1729\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2322): \u001b[0mType 'Timeout' is not assignable to type 'number'.\n\n\u001b[7m1729\u001b[0m       activeProgressInterval.value = progressInterval\n\u001b[7m    \u001b[0m \u001b[91m      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1724\u001b[0m:\u001b[93m52\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2362): \u001b[0mThe left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n\n\u001b[7m1724\u001b[0m           const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n\u001b[7m    \u001b[0m \u001b[91m                                                   ~~~~~~~~~~~~~~~~\u001b[0m\n\n\u001b[96msrc/components/composables/useNotifications.ts\u001b[0m:\u001b[93m559\u001b[0m:\u001b[93m23\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type '{ metadata: { realtimeEvent: RealtimeEvent; source: string; }; id?: string | undefined; type?: NotificationType | undefined; priority?: NotificationPriority | undefined; ... 14 more ...; groupId?: string | undefined; }' is not assignable to parameter of type 'Omit<SmartNotification, \"id\" | \"timestamp\" | \"aiScore\" | \"aiPriority\">'.\n  Types of property 'type' are incompatible.\n\n\u001b[7m559\u001b[0m       addNotification({\n\u001b[7m   \u001b[0m \u001b[91m                      ~\u001b[0m\n\u001b[7m560\u001b[0m         ...template,\n\u001b[7m   \u001b[0m \u001b[91m~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[7m...\u001b[0m \n\u001b[7m564\u001b[0m         }\n\u001b[7m   \u001b[0m \u001b[91m~~~~~~~~~\u001b[0m\n\u001b[7m565\u001b[0m       });\n\u001b[7m   \u001b[0m \u001b[91m~~~~~~~\u001b[0m\n\n\u001b[96msrc/components/composables/useResponsiveContainer.ts\u001b[0m:\u001b[93m71\u001b[0m:\u001b[93m23\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2352): \u001b[0mConversion of type '{ contentRect: DOMRect; target: HTMLElement; }' to type 'ResizeObserverEntry' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.\n  Type '{ contentRect: DOMRect; target: HTMLElement; }' is missing the following properties from type 'ResizeObserverEntry': borderBoxSize, contentBoxSize, devicePixelContentBoxSize\n\n\u001b[7m71\u001b[0m     updateDimensions([{\n\u001b[7m  \u001b[0m \u001b[91m                      ~\u001b[0m\n\u001b[7m72\u001b[0m       contentRect: rect,\n\u001b[7m  \u001b[0m \u001b[91m~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[7m73\u001b[0m       target: containerRef.value\n\u001b[7m  \u001b[0m \u001b[91m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[7m74\u001b[0m     } as ResizeObserverEntry])\n\u001b[7m  \u001b[0m \u001b[91m~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n\u001b[96msrc/components/composables/useStripe.ts\u001b[0m:\u001b[93m290\u001b[0m:\u001b[93m64\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2366): \u001b[0mFunction lacks ending return statement and return type does not include 'undefined'.\n\n\u001b[7m290\u001b[0m   const mountCheckout = async (element: HTMLElement | string): Promise<boolean> => {\n\u001b[7m   \u001b[0m \u001b[91m                         \n\n... [45869 characters truncated] ...\n\n $permissions: string[]; oauthAccountId: string; ... 4 more ...; sourceTeamId?: string | ... 1 more ... | undefined; }' is missing the following properties from type '{ $id: string; $createdAt: string; $updatedAt: string; $permissions: string[]; oauthAccountId: string; requestedBy: string; message?: string | null | undefined; title?: string | null | undefined; ... 7 more ...; sourceTeamId?: string | ... 1 more ... | undefined; }': $id, $createdAt, $updatedAt\n\n\u001b[7m 39\u001b[0m       {\n\u001b[7m   \u001b[0m \u001b[91m      ~\u001b[0m\n\u001b[7m 40\u001b[0m         ...data,\n\u001b[7m   \u001b[0m \u001b[91m~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[7m...\u001b[0m \n\u001b[7m 44\u001b[0m         processedAt: null,\n\u001b[7m   \u001b[0m \u001b[91m~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[7m 45\u001b[0m       },\n\u001b[7m   \u001b[0m \u001b[91m~~~~~~~\u001b[0m\n\n\u001b[96msrc/stores/hub/socialHubStore.ts\u001b[0m:\u001b[93m419\u001b[0m:\u001b[93m9\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2741): \u001b[0mProperty '$permissions' is missing in type '{ $id: string; displayName: string; handle: string | undefined; avatarId: string | undefined; avatarUrl: string | undefined; userPlatformId: string; platform: \"mastodon\" | \"bluesky\" | ... 6 more ... | \"youtube\"; $createdAt: string; $updatedAt: string; }' but required in type '{ platform: \"mastodon\" | \"bluesky\" | \"instagram\" | \"facebook\" | \"threads\" | \"tiktok\" | \"linkedin\" | \"pinterest\" | \"youtube\"; $id: string; $createdAt: string; $updatedAt: string; $permissions: string[]; ... 11 more ...; miscData?: string | ... 1 more ... | undefined; }'.\n\n\u001b[7m419\u001b[0m         content.author = {\n\u001b[7m   \u001b[0m \u001b[91m        ~~~~~~~~~~~~~~\u001b[0m\n\n\u001b[96msrc/stores/providers/tiktokStore.ts\u001b[0m:\u001b[93m25\u001b[0m:\u001b[93m34\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2307): \u001b[0mCannot find module '@appwrite/schemas/tiktokVideo' or its corresponding type declarations.\n\n\u001b[7m25\u001b[0m import type { TiktokVideo } from \"@appwrite/schemas/tiktokVideo\";\n\u001b[7m  \u001b[0m \u001b[91m                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n\u001b[96msrc/types/pricing.ts\u001b[0m:\u001b[93m53\u001b[0m:\u001b[93m3\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2739): \u001b[0mType '{ name: any; description: any; billingKey: any; monthlyPrice: any; yearlyPrice: any; connectionsMax: any; teamsMax: any; usersMax: any; storageMax: any; aiCreditsMax: any; encodingEnabled: any; chatEnabled: any; unlimitedExecutions: any; isPopular: any; buttonText: any; }' is missing the following properties from type 'UnifiedPricingTier': $id, $createdAt, $updatedAt, $permissions\n\n\u001b[7m53\u001b[0m   return {\n\u001b[7m  \u001b[0m \u001b[91m  ~~~~~~\u001b[0m\n\u001b[96msrc/types/pricing.ts\u001b[0m:\u001b[93m28\u001b[0m:\u001b[93m3\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2739): \u001b[0mType '{ id: string; name: string; description: string; billingKey: string; monthlyPrice: number; yearlyPrice: number; connectionsMax: number; teamsMax: number; usersMax: number; storageMax: number; aiCreditsMax: number; ... 6 more ...; buttonText: string; }' is missing the following properties from type 'UnifiedPricingTier': $id, $createdAt, $updatedAt, $permissions\n\n\u001b[7m28\u001b[0m   return {\n\u001b[7m  \u001b[0m \u001b[91m  ~~~~~~\u001b[0m\n\n\u001b[96msrc/utils/adminUsageQueries.ts\u001b[0m:\u001b[93m231\u001b[0m:\u001b[93m42\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'string | null' is not assignable to parameter of type 'QueryTypes'.\n  Type 'null' is not assignable to type 'QueryTypes'.\n\n\u001b[7m231\u001b[0m         Query.lessThanEqual('timestamp', endOfDay.toISO()),\n\u001b[7m   \u001b[0m \u001b[91m                                         ~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/utils/adminUsageQueries.ts\u001b[0m:\u001b[93m230\u001b[0m:\u001b[93m45\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'string | null' is not assignable to parameter of type 'QueryTypes'.\n  Type 'null' is not assignable to type 'QueryTypes'.\n\n\u001b[7m230\u001b[0m         Query.greaterThanEqual('timestamp', startOfDay.toISO()),\n\u001b[7m   \u001b[0m \u001b[91m                                            ~~~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/utils/adminUsageQueries.ts\u001b[0m:\u001b[93m89\u001b[0m:\u001b[93m42\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'string | null' is not assignable to parameter of type 'QueryTypes'.\n  Type 'null' is not assignable to type 'QueryTypes'.\n\n\u001b[7m89\u001b[0m         Query.lessThanEqual('timestamp', endOfDay.toISO()),\n\u001b[7m  \u001b[0m \u001b[91m                                         ~~~~~~~~~~~~~~~~\u001b[0m\n\u001b[96msrc/utils/adminUsageQueries.ts\u001b[0m:\u001b[93m88\u001b[0m:\u001b[93m45\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'string | null' is not assignable to parameter of type 'QueryTypes'.\n  Type 'null' is not assignable to type 'QueryTypes'.\n\n\u001b[7m88\u001b[0m         Query.greaterThanEqual('timestamp', startOfDay.toISO()),\n\u001b[7m  \u001b[0m \u001b[91m                                            ~~~~~~~~~~~~~~~~~~\u001b[0m\n\n\u001b[96msrc/utils/analytics/dataTransformationPipeline.ts\u001b[0m:\u001b[93m200\u001b[0m:\u001b[93m61\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'PartialDataTransformationConfig' is not assignable to parameter of type 'Partial<DataTransformationConfig>'.\n  Types of property 'validation' are incompatible.\n\n\u001b[7m200\u001b[0m     this.config = this.mergeConfig(DEFAULT_PIPELINE_CONFIG, config);\n\u001b[7m   \u001b[0m \u001b[91m                                                            ~~~~~~\u001b[0m\n\nResult (274 files): \n- 67 errors"}
{"parentUuid":"6042c44b-8127-4e87-8b39-71014f53bc6f","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01EfqmowxTE2W2i3vBG3ZUGf","type":"message","role":"assistant","content":[{"type":"text","text":"Good! I still see 6 errors in useAnimation.ts. Let me focus on fixing the remaining ones. Let me update the todo list and work through the remaining errors:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3854,"cache_read_input_tokens":133450,"cache_creation":{"ephemeral_5m_input_tokens":3854,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfZno4LxacF6vbpAeJX","type":"assistant","uuid":"ca7437b9-0fdb-4fdf-8420-707731f6dfb3","timestamp":"2025-10-09T00:19:10.932Z"}
{"parentUuid":"ca7437b9-0fdb-4fdf-8420-707731f6dfb3","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01EfqmowxTE2W2i3vBG3ZUGf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GCoUVCEq8mZusZZEAE7rjK","name":"TodoWrite","input":{"todos":[{"content":"Fix scroll container type errors (Window vs HTMLElement union) - Lines 1957, 1960, 1961","status":"in_progress","activeForm":"Fixing scroll container type errors"},{"content":"Fix timeout and progress calculation types (2 errors) - Lines 1729, 1724","status":"pending","activeForm":"Fixing timeout and progress calculation types"},{"content":"Fix sequence return type (line 1932)","status":"pending","activeForm":"Fixing sequence return type"},{"content":"Run typecheck and verify all useAnimation errors are fixed","status":"pending","activeForm":"Running typecheck and verifying all useAnimation errors are fixed"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3854,"cache_read_input_tokens":133450,"cache_creation":{"ephemeral_5m_input_tokens":3854,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfZno4LxacF6vbpAeJX","type":"assistant","uuid":"43abf99f-46ca-435d-9a41-1726a0bfcdac","timestamp":"2025-10-09T00:19:13.188Z"}
{"parentUuid":"43abf99f-46ca-435d-9a41-1726a0bfcdac","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GCoUVCEq8mZusZZEAE7rjK","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"9259f6af-6bf1-4a85-80ed-8bf426b649fb","timestamp":"2025-10-09T00:19:13.297Z","toolUseResult":{"oldTodos":[{"content":"Fix element access pattern errors with toValue() (12 errors)","status":"completed","activeForm":"Fixed element access pattern errors with toValue()"},{"content":"Fix nullable function guards (6 errors) - Lines 1623-1625, 1668-1670","status":"completed","activeForm":"Fixed nullable function guards"},{"content":"Fix scroll container type errors (4 errors) - Lines 1949, 1952, 1953, 1959","status":"in_progress","activeForm":"Fixing scroll container type errors"},{"content":"Fix timeout and progress calculation types (2 errors) - Lines 1731, 1726","status":"pending","activeForm":"Fixing timeout and progress calculation types"},{"content":"Fix sequence return type (line 1934)","status":"pending","activeForm":"Fixing sequence return type"},{"content":"Run typecheck and verify all errors are fixed","status":"pending","activeForm":"Running typecheck and verifying all errors are fixed"}],"newTodos":[{"content":"Fix scroll container type errors (Window vs HTMLElement union) - Lines 1957, 1960, 1961","status":"in_progress","activeForm":"Fixing scroll container type errors"},{"content":"Fix timeout and progress calculation types (2 errors) - Lines 1729, 1724","status":"pending","activeForm":"Fixing timeout and progress calculation types"},{"content":"Fix sequence return type (line 1932)","status":"pending","activeForm":"Fixing sequence return type"},{"content":"Run typecheck and verify all useAnimation errors are fixed","status":"pending","activeForm":"Running typecheck and verifying all useAnimation errors are fixed"}]}}
{"parentUuid":"9259f6af-6bf1-4a85-80ed-8bf426b649fb","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01LJq37798ynx4kjZwC7bVuZ","type":"message","role":"assistant","content":[{"type":"text","text":"The scroll container issue is that `toValue` can return either `Window` or `HTMLElement`, but TypeScript can't narrow the type properly. I need to handle the Window case explicitly. Let me fix this:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":302,"cache_read_input_tokens":137304,"cache_creation":{"ephemeral_5m_input_tokens":302,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfaVqrtpL2qBKnanJ8y","type":"assistant","uuid":"e3588c4d-441e-41e3-845a-d2c1ccb5cc19","timestamp":"2025-10-09T00:19:21.357Z"}
{"parentUuid":"e3588c4d-441e-41e3-845a-d2c1ccb5cc19","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01LJq37798ynx4kjZwC7bVuZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014XZsmhfiAiYfjBQ7KCEByD","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","old_string":"  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = toValue(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight","new_string":"  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = toValue(scrollContainer)\n      if (!container) return 0\n\n      // Type guard to check if container is window\n      const isWindow = container === window\n      const scrollHeight = isWindow\n        ? document.documentElement.scrollHeight - (typeof window !== 'undefined' ? window.innerHeight : 0)\n        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":302,"cache_read_input_tokens":137304,"cache_creation":{"ephemeral_5m_input_tokens":302,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfaVqrtpL2qBKnanJ8y","type":"assistant","uuid":"3ef0a097-c3a5-49c3-9f88-b59524ef1473","timestamp":"2025-10-09T00:19:26.752Z"}
{"parentUuid":"3ef0a097-c3a5-49c3-9f88-b59524ef1473","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014XZsmhfiAiYfjBQ7KCEByD","type":"tool_result","content":"The file /Users/natedamstra/socialaize/src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1946→        isScrolling: Ref<boolean>\n  1947→      }\n  1948→    | undefined\n  1949→\n  1950→  if (scroll) {\n  1951→    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n  1952→    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n  1953→\n  1954→    const scrollProgress = computed(() => {\n  1955→      if (!isMounted.value) return 0\n  1956→\n  1957→      const container = toValue(scrollContainer)\n  1958→      if (!container) return 0\n  1959→\n  1960→      // Type guard to check if container is window\n  1961→      const isWindow = container === window\n  1962→      const scrollHeight = isWindow\n  1963→        ? document.documentElement.scrollHeight - (typeof window !== 'undefined' ? window.innerHeight : 0)\n  1964→        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight\n  1965→\n  1966→      if (scrollHeight <= 0) return 0\n  1967→\n  1968→      const rawProgress = scrollY.value / scrollHeight"}]},"uuid":"a260b568-e8d8-4979-8ea3-02e989af74d4","timestamp":"2025-10-09T00:19:26.851Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","oldString":"  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = toValue(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight","newString":"  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = toValue(scrollContainer)\n      if (!container) return 0\n\n      // Type guard to check if container is window\n      const isWindow = container === window\n      const scrollHeight = isWindow\n        ? document.documentElement.scrollHeight - (typeof window !== 'undefined' ? window.innerHeight : 0)\n        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = toValue(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const element = toValue(target)\n            if (!element) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = toValue(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = toValue(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => toValue(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = toValue(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = toValue(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = toValue(scrollContainer)\n      if (!container) return 0\n\n      const scrollHeight = container === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = toValue(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1957,"oldLines":8,"newStart":1957,"newLines":10,"lines":["       const container = toValue(scrollContainer)","       if (!container) return 0"," ","-      const scrollHeight = container === window","-        ? document.documentElement.scrollHeight - window.innerHeight","+      // Type guard to check if container is window","+      const isWindow = container === window","+      const scrollHeight = isWindow","+        ? document.documentElement.scrollHeight - (typeof window !== 'undefined' ? window.innerHeight : 0)","         : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight"," ","       if (scrollHeight <= 0) return 0"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"a260b568-e8d8-4979-8ea3-02e989af74d4","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012hkiWVEUpbyVoK4qWAiek4","type":"message","role":"assistant","content":[{"type":"text","text":"Good! Now let me fix the timeout type error at line 1729. The issue is that `setInterval` returns `Timeout` in Node.js but we've typed it as `number`. Let me fix this:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":844,"cache_read_input_tokens":137606,"cache_creation":{"ephemeral_5m_input_tokens":844,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfbRwVZEyYC9ZxRbJpz","type":"assistant","uuid":"518a8237-ca4c-47b9-bc76-0d289b4b5357","timestamp":"2025-10-09T00:19:34.218Z"}
{"parentUuid":"518a8237-ca4c-47b9-bc76-0d289b4b5357","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012hkiWVEUpbyVoK4qWAiek4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Hykj6ZeFj5cKNf9pLFU7Q5","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","old_string":"  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)","new_string":"  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<ReturnType<typeof setInterval> | null>(null)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":844,"cache_read_input_tokens":137606,"cache_creation":{"ephemeral_5m_input_tokens":844,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfbRwVZEyYC9ZxRbJpz","type":"assistant","uuid":"7554e203-b296-4396-a2d0-26a657e0ab60","timestamp":"2025-10-09T00:19:35.711Z"}
{"parentUuid":"7554e203-b296-4396-a2d0-26a657e0ab60","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Hykj6ZeFj5cKNf9pLFU7Q5","type":"tool_result","content":"The file /Users/natedamstra/socialaize/src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   910→\n   911→  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n   912→  const isPaused = ref(false)\n   913→\n   914→  // Track active progress interval for cleanup\n   915→  const activeProgressInterval = ref<ReturnType<typeof setInterval> | null>(null)\n   916→\n   917→  // Parse autoplay options\n   918→  const autoplayOptions: UseAnimationAutoplayOptions =\n   919→    typeof autoplay === 'boolean'"}]},"uuid":"c3dbaaa3-7d27-47a2-a929-34170fd7d8f2","timestamp":"2025-10-09T00:19:35.823Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","oldString":"  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)","newString":"  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<ReturnType<typeof setInterval> | null>(null)","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = toValue(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<number | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const element = toValue(target)\n            if (!element) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = toValue(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = toValue(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => toValue(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = toValue(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = toValue(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = toValue(scrollContainer)\n      if (!container) return 0\n\n      // Type guard to check if container is window\n      const isWindow = container === window\n      const scrollHeight = isWindow\n        ? document.documentElement.scrollHeight - (typeof window !== 'undefined' ? window.innerHeight : 0)\n        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = toValue(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":912,"oldLines":7,"newStart":912,"newLines":7,"lines":["   const isPaused = ref(false)"," ","   // Track active progress interval for cleanup","-  const activeProgressInterval = ref<number | null>(null)","+  const activeProgressInterval = ref<ReturnType<typeof setInterval> | null>(null)"," ","   // Parse autoplay options","   const autoplayOptions: UseAnimationAutoplayOptions ="]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"c3dbaaa3-7d27-47a2-a929-34170fd7d8f2","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VpdGGabtvuyMEuCq1jNg9q","type":"message","role":"assistant","content":[{"type":"text","text":"Great! Now let me fix the `anim.currentTime` type error at line 1724. The issue is that `currentTime` can be `null`, so I need to add a null check:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":394,"cache_read_input_tokens":138450,"cache_creation":{"ephemeral_5m_input_tokens":394,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfcAu9HpuZpRiHJWVEh","type":"assistant","uuid":"3c27e591-c0e9-4dbf-b128-5ba515b1a5c1","timestamp":"2025-10-09T00:19:42.705Z"}
{"parentUuid":"3c27e591-c0e9-4dbf-b128-5ba515b1a5c1","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VpdGGabtvuyMEuCq1jNg9q","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LB17kxbRcxT5ejAzMeWk9K","name":"Read","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","offset":1720,"limit":1730}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":394,"cache_read_input_tokens":138450,"cache_creation":{"ephemeral_5m_input_tokens":394,"ephemeral_1h_input_tokens":0},"output_tokens":156,"service_tier":"standard"}},"requestId":"req_011CTvfcAu9HpuZpRiHJWVEh","type":"assistant","uuid":"e915e962-0cc5-4757-92d6-fd68a8d7eaa0","timestamp":"2025-10-09T00:19:43.380Z"}
{"parentUuid":"e915e962-0cc5-4757-92d6-fd68a8d7eaa0","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LB17kxbRcxT5ejAzMeWk9K","type":"tool_result","content":"  1720→        }\n  1721→\n  1722→        const timing = anim.effect?.getTiming()\n  1723→        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n  1724→          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n  1725→          lifecycle.onProgress!(progress)\n  1726→        }\n  1727→      }, 16) // ~60fps\n  1728→\n  1729→      activeProgressInterval.value = progressInterval\n  1730→\n  1731→      // Cleanup on animation finish/cancel using WeakMap\n  1732→      const finishHandler = () => {\n  1733→        if (activeProgressInterval.value !== null) {\n  1734→          clearInterval(activeProgressInterval.value)\n  1735→          activeProgressInterval.value = null\n  1736→        }\n  1737→        lifecycle.onProgress!(1) // Final progress\n  1738→      }\n  1739→      const cancelHandler = () => {\n  1740→        if (activeProgressInterval.value !== null) {\n  1741→          clearInterval(activeProgressInterval.value)\n  1742→          activeProgressInterval.value = null\n  1743→        }\n  1744→      }\n  1745→\n  1746→      anim.addEventListener('finish', finishHandler, { once: true })\n  1747→      anim.addEventListener('cancel', cancelHandler, { once: true })\n  1748→      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n  1749→    }, { immediate: true })\n  1750→  }\n  1751→\n  1752→  // ===============================\n  1753→  // WATCHERS\n  1754→  // ===============================\n  1755→\n  1756→  // Auto-play watcher\n  1757→  if (autoplay) {\n  1758→    watch(shouldAutoplay, (should) => {\n  1759→      if (should && !isPlaying.value) {\n  1760→        play()\n  1761→      } else if (!should && isPlaying.value) {\n  1762→        stop()\n  1763→      }\n  1764→    }, { immediate: true })\n  1765→  }\n  1766→\n  1767→  // Auto-pause on environment changes (unless animation is critical)\n  1768→  watch(shouldPauseAnimations, (shouldPause) => {\n  1769→    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n  1770→    if (critical) return\n  1771→\n  1772→    if (shouldPause && isPlaying.value) {\n  1773→      pause()\n  1774→    } else if (!shouldPause && isPlaying.value) {\n  1775→      resume()\n  1776→    }\n  1777→  })\n  1778→\n  1779→  // ===============================\n  1780→  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  1781→  // ===============================\n  1782→\n  1783→  // Declare RAF control functions at higher scope for pause/resume access\n  1784→  let pauseSequence: (() => void) | undefined\n  1785→  let resumeSequence: (() => void) | undefined\n  1786→  let pauseMotion: (() => void) | undefined\n  1787→  let resumeMotion: (() => void) | undefined\n  1788→  let pauseTimeline: (() => void) | undefined\n  1789→  let resumeTimeline: (() => void) | undefined\n  1790→\n  1791→  let timedSequence:\n  1792→    | {\n  1793→        currentIndex: Ref<number>\n  1794→        currentElement: ComputedRef<TElement | undefined>\n  1795→        cycleIndex: Ref<number>\n  1796→        next: () => void\n  1797→        prev: () => void\n  1798→        goTo: (index: number) => void\n  1799→      }\n  1800→    | undefined\n  1801→\n  1802→  if (sequence) {\n  1803→    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n  1804→    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n  1805→    const mode = sequence.mode || 'loop'\n  1806→\n  1807→    // Use VueUse's useCycleList for element cycling\n  1808→    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n  1809→\n  1810→    const cycleIndex = ref(0)\n  1811→    const startTime = ref<number | null>(null)\n  1812→    const currentCycleStartTime = ref(0)\n  1813→\n  1814→    // RAF loop for timed activation\n  1815→    const rafControls = useRafFn(\n  1816→      (args) => {\n  1817→        if (!isPlaying.value || isPaused.value) {\n  1818→          rafControls.pause()\n  1819→          return\n  1820→        }\n  1821→\n  1822→        const now = args.timestamp\n  1823→\n  1824→        // Initialize on first RAF callback instead of relying on watch\n  1825→        if (startTime.value === null) {\n  1826→          startTime.value = now\n  1827→          currentCycleStartTime.value = now\n  1828→        }\n  1829→\n  1830→        const totalElapsed = now - startTime.value\n  1831→        const elapsedSinceCycle = now - currentCycleStartTime.value\n  1832→        const elementsArray = elements.value\n  1833→\n  1834→        if (!elementsArray.length) {\n  1835→          rafControls.pause()\n  1836→          return\n  1837→        }\n  1838→\n  1839→        if (mode === 'loop' || mode === 'sequence') {\n  1840→          // Sequential activation: one element at a time\n  1841→          if (elapsedSinceCycle >= interval.value) {\n  1842→            const element = elementsArray[currentIndex.value]\n  1843→            const elapsedInCycle = elapsedSinceCycle\n  1844→\n  1845→            // Activate current element\n  1846→            sequence.onActivate(element, currentIndex.value, {\n  1847→              cycleIndex: cycleIndex.value,\n  1848→              elapsedInCycle,\n  1849→              totalElapsed,\n  1850→            })\n  1851→\n  1852→            // Move to next element\n  1853→            if (currentIndex.value === elementsArray.length - 1) {\n  1854→              // Cycle complete\n  1855→              cycleIndex.value++\n  1856→              sequence.onCycleComplete?.()\n  1857→\n  1858→              if (mode === 'sequence') {\n  1859→                // Stop after one sequence\n  1860→                stop()\n  1861→                return\n  1862→              }\n  1863→            }\n  1864→\n  1865→            next()\n  1866→            currentCycleStartTime.value = now\n  1867→          }\n  1868→        } else if (mode === 'stagger') {\n  1869→          // Stagger: activate elements with delays based on their index\n  1870→          const timePerElement = interval.value / elementsArray.length\n  1871→\n  1872→          elementsArray.forEach((element, index) => {\n  1873→            const activationTime = index * timePerElement\n  1874→            const nextActivationTime = (index + 1) * timePerElement\n  1875→\n  1876→            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n  1877→              sequence.onActivate(element, index, {\n  1878→                cycleIndex: cycleIndex.value,\n  1879→                elapsedInCycle: elapsedSinceCycle - activationTime,\n  1880→                totalElapsed,\n  1881→              })\n  1882→            }\n  1883→          })\n  1884→\n  1885→          // Check for cycle complete\n  1886→          if (elapsedSinceCycle >= interval.value) {\n  1887→            cycleIndex.value++\n  1888→            sequence.onCycleComplete?.()\n  1889→            currentCycleStartTime.value = now\n  1890→          }\n  1891→        } else if (mode === 'unison') {\n  1892→          // Unison: activate all elements at once\n  1893→          if (elapsedSinceCycle < 50) {\n  1894→            // Activate within first frame\n  1895→            elementsArray.forEach((element, index) => {\n  1896→              sequence.onActivate(element, index, {\n  1897→                cycleIndex: cycleIndex.value,\n  1898→                elapsedInCycle: elapsedSinceCycle,\n  1899→                totalElapsed,\n  1900→              })\n  1901→            })\n  1902→          }\n  1903→\n  1904→          // Check for cycle complete\n  1905→          if (elapsedSinceCycle >= interval.value) {\n  1906→            cycleIndex.value++\n  1907→            sequence.onCycleComplete?.()\n  1908→            currentCycleStartTime.value = now\n  1909→          }\n  1910→        }\n  1911→      },\n  1912→      { immediate: false }\n  1913→    )\n  1914→\n  1915→    // Assign pause/resume to outer scope for use in pause()/resume() functions\n  1916→    pauseSequence = rafControls.pause\n  1917→    resumeSequence = rafControls.resume\n  1918→\n  1919→    // Auto-start/stop sequence with animation\n  1920→    watch(isPlaying, (playing) => {\n  1921→      if (playing) {\n  1922→        // Reset state for new cycle (initialization happens in RAF)\n  1923→        rafControls.resume()\n  1924→      } else {\n  1925→        rafControls.pause()\n  1926→        startTime.value = null\n  1927→      }\n  1928→    })\n  1929→\n  1930→    timedSequence = {\n  1931→      currentIndex,\n  1932→      currentElement,\n  1933→      cycleIndex,\n  1934→      next,\n  1935→      prev,\n  1936→      goTo,\n  1937→    }\n  1938→  }\n  1939→\n  1940→  // ===============================\n  1941→  // SCROLL-TRIGGERED ANIMATIONS\n  1942→  // ===============================\n  1943→  let scrollAnimation:\n  1944→    | {\n  1945→        progress: ComputedRef<number>\n  1946→        isScrolling: Ref<boolean>\n  1947→      }\n  1948→    | undefined\n  1949→\n  1950→  if (scroll) {\n  1951→    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n  1952→    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n  1953→\n  1954→    const scrollProgress = computed(() => {\n  1955→      if (!isMounted.value) return 0\n  1956→\n  1957→      const container = toValue(scrollContainer)\n  1958→      if (!container) return 0\n  1959→\n  1960→      // Type guard to check if container is window\n  1961→      const isWindow = container === window\n  1962→      const scrollHeight = isWindow\n  1963→        ? document.documentElement.scrollHeight - (typeof window !== 'undefined' ? window.innerHeight : 0)\n  1964→        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight\n  1965→\n  1966→      if (scrollHeight <= 0) return 0\n  1967→\n  1968→      const rawProgress = scrollY.value / scrollHeight\n  1969→      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n  1970→\n  1971→      // Apply offsets\n  1972→      const offsetStart = scroll.offset?.start || 0\n  1973→      const offsetEnd = scroll.offset?.end || 0\n  1974→      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n  1975→\n  1976→      // Clamp between threshold values with division-by-zero protection\n  1977→      const denominator = thresholdEnd - thresholdStart\n  1978→      const normalizedProgress = denominator > 0\n  1979→        ? (adjustedProgress - thresholdStart) / denominator\n  1980→        : 0 // Default to 0 if thresholds are equal\n  1981→\n  1982→      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n  1983→\n  1984→      // Safety check for NaN\n  1985→      return isNaN(clampedProgress) ? 0 : clampedProgress\n  1986→    })\n  1987→\n  1988→    // Watch progress and trigger callbacks\n  1989→    watch(scrollProgress, (progress) => {\n  1990→      if (scroll.mode === 'toggle') {\n  1991→        const [thresholdStart] = scroll.threshold || [0, 1]\n  1992→        if (progress >= thresholdStart && !isPlaying.value) {\n  1993→          play()\n  1994→        } else if (progress < thresholdStart && isPlaying.value) {\n  1995→          stop()\n  1996→        }\n  1997→      }\n  1998→\n  1999→      // Single call for all modes (toggle, scrub, or undefined)\n  2000→      scroll.onProgress?.(progress)\n  2001→    })\n  2002→\n  2003→    scrollAnimation = {\n  2004→      progress: scrollProgress,\n  2005→      isScrolling,\n  2006→    }\n  2007→  }\n  2008→\n  2009→  // ===============================\n  2010→  // STAGGER ANIMATIONS\n  2011→  // ===============================\n  2012→  let staggerAnimation:\n  2013→    | {\n  2014→        elements: Ref<HTMLElement[]>\n  2015→        triggerStagger: () => void\n  2016→        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n  2017→        activeAnimations: Ref<Animation[]>\n  2018→      }\n  2019→    | undefined\n  2020→\n  2021→  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n  2022→\n  2023→  if (stagger) {\n  2024→    const staggerElements = ref<HTMLElement[]>([])\n  2025→    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n  2026→    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n  2027→    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n  2028→    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n  2029→\n  2030→    const updateStaggerElements = () => {\n  2031→      if (!isMounted.value) return\n  2032→\n  2033→      const targetEl = toValue(target)\n  2034→      if (!targetEl) return\n  2035→\n  2036→      if (typeof stagger.children === 'string') {\n  2037→        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n  2038→      } else if (Array.isArray(stagger.children)) {\n  2039→        staggerElements.value = stagger.children\n  2040→      } else {\n  2041→        staggerElements.value = unref(stagger.children) || []\n  2042→      }\n  2043→    }\n  2044→\n  2045→    const triggerStagger = async () => {\n  2046→      // Clear any existing timeouts to prevent overlapping animations\n  2047→      activeTimeouts.value.forEach(id => clearTimeout(id))\n  2048→      activeTimeouts.value = []\n  2049→\n  2050→      // Clear any existing animations\n  2051→      activeAnimations.value.forEach(anim => anim.cancel())\n  2052→      activeAnimations.value = []\n  2053→\n  2054→      // Wait for DOM to be ready\n  2055→      await nextTick()\n  2056→      updateStaggerElements()\n  2057→\n  2058→      const elements = staggerElements.value\n  2059→\n  2060→      if (!elements.length) {\n  2061→        return\n  2062→      }\n  2063→\n  2064→      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n  2065→      const shouldReset = stagger.resetOnRestart !== false\n  2066→      if (shouldReset) {\n  2067→        elements.forEach(el => {\n  2068→          // Capture initial state on first run\n  2069→          if (!initialElementStates.has(el)) {\n  2070→            const computedStyle = getComputedStyle(el)\n  2071→            initialElementStates.set(el, {\n  2072→              opacity: computedStyle.opacity,\n  2073→              transform: computedStyle.transform\n  2074→            })\n  2075→          }\n  2076→\n  2077→          // Reset to initial state\n  2078→          const initialState = initialElementStates.get(el)\n  2079→          if (initialState) {\n  2080→            el.style.opacity = initialState.opacity\n  2081→            el.style.transform = initialState.transform\n  2082→          }\n  2083→        })\n  2084→\n  2085→        // Small delay to ensure style reset applies before animation starts\n  2086→        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n  2087→      }\n  2088→\n  2089→      const delays = calculateStaggerDelays(elements.length, stagger)\n  2090→\n  2091→      elements.forEach((el, index) => {\n  2092→        const delay = delays[index]\n  2093→\n  2094→        const timeoutId = setTimeout(() => {\n  2095→          // Skip animation if quality is none or cannot animate\n  2096→          if (!canAnimate.value || animationQuality.value === 'none') {\n  2097→            // Apply final state immediately without animation\n  2098→            if (animation) {\n  2099→              const preset = animation.preset || 'fadeIn'\n  2100→              const presetConfig = animationPresets[preset]\n  2101→              const keyframes = animation.keyframes || presetConfig.keyframes\n  2102→              if (Array.isArray(keyframes) && keyframes.length > 0) {\n  2103→                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n  2104→                Object.assign(el.style, finalFrame)\n  2105→              }\n  2106→            }\n  2107→            return\n  2108→          }\n  2109→\n  2110→          if (animation) {\n  2111→            const preset = animation.preset || 'fadeIn'\n  2112→            const presetConfig = animationPresets[preset]\n  2113→            const keyframes = animation.keyframes || presetConfig.keyframes\n  2114→            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n  2115→            const effectiveDuration = duration * (\n  2116→              animationQuality.value === 'low' ? 0.3 :\n  2117→              animationQuality.value === 'medium' ? 0.6 : 1\n  2118→            )\n  2119→            const easing = animation.easing || EASING.EASE_OUT\n  2120→\n  2121→            // Use Web Animations API for consistency and proper control\n  2122→            const anim = el.animate(keyframes as Keyframe[], {\n  2123→              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n  2124→              easing: easing,\n  2125→              fill: 'forwards' as FillMode\n  2126→            })\n  2127→\n  2128→            activeAnimations.value.push(anim)\n  2129→\n  2130→            // Add completion callback for last element\n  2131→            if (index === elements.length - 1) {\n  2132→              anim.addEventListener('finish', () => {\n  2133→                emit('stagger-complete')\n  2134→\n  2135→                // Handle loop if enabled\n  2136→                if (stagger.loop && isPlaying.value) {\n  2137→                  const loopDelay = stagger.loopDelay || 0\n  2138→                  staggerLoopTimeoutId = setTimeout(() => {\n  2139→                    if (isPlaying.value) {\n  2140→                      triggerStagger()\n  2141→                    }\n  2142→                  }, loopDelay)\n  2143→                }\n  2144→              })\n  2145→            }\n  2146→          }\n  2147→        }, delay)\n  2148→\n  2149→        // Track timeout ID for cleanup\n  2150→        activeTimeouts.value.push(timeoutId)\n  2151→      })\n  2152→    }\n  2153→\n  2154→    // Auto-trigger on mount or play\n  2155→    watch([isMounted, isPlaying], ([mounted, playing]) => {\n  2156→      if (mounted && playing && autoplay) {\n  2157→        nextTick(() => triggerStagger())\n  2158→      } else if (!playing) {\n  2159→        // Clear loop timeout when stopping\n  2160→        if (staggerLoopTimeoutId !== null) {\n  2161→          clearTimeout(staggerLoopTimeoutId)\n  2162→          staggerLoopTimeoutId = null\n  2163→        }\n  2164→      }\n  2165→    }, { immediate: true })\n  2166→\n  2167→    staggerAnimation = {\n  2168→      elements: staggerElements,\n  2169→      triggerStagger,\n  2170→      activeTimeouts,\n  2171→      activeAnimations\n  2172→    }\n  2173→  }\n  2174→\n  2175→  // ===============================\n  2176→  // MOTION PATH ANIMATIONS\n  2177→  // ===============================\n  2178→  let motionPathAnimation:\n  2179→    | {\n  2180→        progress: Ref<number>\n  2181→        setProgress: (progress: number) => void\n  2182→      }\n  2183→    | undefined\n  2184→\n  2185→  if (motionPath) {\n  2186→    const motionProgress = ref(0)\n  2187→    const motionStartTime = ref<number | null>(null)\n  2188→\n  2189→    const setProgress = (progress: number) => {\n  2190→      motionProgress.value = Math.max(0, Math.min(1, progress))\n  2191→      updateMotionPathPosition()\n  2192→    }\n  2193→\n  2194→    const updateMotionPathPosition = () => {\n  2195→      const targetEl = unref(target)\n  2196→      if (!targetEl) return\n  2197→\n  2198→      const progress = motionProgress.value\n  2199→\n  2200→      if (motionPath.type === 'circular') {\n  2201→        const radius = typeof motionPath.radius === 'number'\n  2202→          ? motionPath.radius\n  2203→          : motionPath.radius?.x || 100\n  2204→\n  2205→        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n  2206→        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n  2207→        const angle = startAngle + (direction * 2 * Math.PI * progress)\n  2208→\n  2209→        const x = Math.cos(angle) * radius\n  2210→        const y = Math.sin(angle) * radius\n  2211→\n  2212→        // Set CSS custom properties for flexibility\n  2213→        setCSSVar('--motion-x', `${x}px`)\n  2214→        setCSSVar('--motion-y', `${y}px`)\n  2215→\n  2216→        if (motionPath.autoRotate) {\n  2217→          const rotation = -angle * (180 / Math.PI)\n  2218→          setCSSVar('--motion-rotation', `${rotation}deg`)\n  2219→        } else {\n  2220→          setCSSVar('--motion-rotation', '0deg')\n  2221→        }\n  2222→\n  2223→      } else if (motionPath.type === 'elliptical') {\n  2224→        const radiusX = typeof motionPath.radius === 'object'\n  2225→          ? motionPath.radius.x\n  2226→          : motionPath.radius || 100\n  2227→        const radiusY = typeof motionPath.radius === 'object'\n  2228→          ? motionPath.radius.y\n  2229→          : motionPath.radius || 60\n  2230→\n  2231→        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n  2232→        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n  2233→        const angle = startAngle + (direction * 2 * Math.PI * progress)\n  2234→\n  2235→        const x = Math.cos(angle) * radiusX\n  2236→        const y = Math.sin(angle) * radiusY\n  2237→\n  2238→        // Set CSS custom properties for flexibility\n  2239→        setCSSVar('--motion-x', `${x}px`)\n  2240→        setCSSVar('--motion-y', `${y}px`)\n  2241→\n  2242→        if (motionPath.autoRotate) {\n  2243→          const rotation = -angle * (180 / Math.PI)\n  2244→          setCSSVar('--motion-rotation', `${rotation}deg`)\n  2245→        } else {\n  2246→          setCSSVar('--motion-rotation', '0deg')\n  2247→        }\n  2248→\n  2249→      } else if (motionPath.type === 'custom' && motionPath.path) {\n  2250→        // For custom SVG paths - would need more complex implementation\n  2251→        // This is a placeholder for now\n  2252→        console.warn('Custom motion paths not yet fully implemented')\n  2253→      }\n  2254→    }\n  2255→\n  2256→    // Animation loop for motion path\n  2257→    const motionRafControls = useRafFn(\n  2258→      (args) => {\n  2259→        if (!isPlaying.value || isPaused.value) {\n  2260→          motionRafControls.pause()\n  2261→          return\n  2262→        }\n  2263→\n  2264→        const now = args.timestamp\n  2265→        if (motionStartTime.value === null) {\n  2266→          motionStartTime.value = now\n  2267→        }\n  2268→\n  2269→        const elapsed = now - motionStartTime.value\n  2270→        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n  2271→\n  2272→        updateMotionPathPosition()\n  2273→      },\n  2274→      { immediate: false }\n  2275→    )\n  2276→\n  2277→    // Assign pause/resume to outer scope for use in pause()/resume() functions\n  2278→    pauseMotion = motionRafControls.pause\n  2279→    resumeMotion = motionRafControls.resume\n  2280→\n  2281→    watch(isPlaying, (playing) => {\n  2282→      if (playing) {\n  2283→        // Reset state for new cycle (initialization happens in RAF)\n  2284→        motionRafControls.resume()\n  2285→      } else {\n  2286→        motionRafControls.pause()\n  2287→        motionStartTime.value = null\n  2288→      }\n  2289→    })\n  2290→\n  2291→    motionPathAnimation = {\n  2292→      progress: motionProgress,\n  2293→      setProgress,\n  2294→    }\n  2295→  }\n  2296→\n  2297→  // ===============================\n  2298→  // ANIMATION TIMELINE\n  2299→  // ===============================\n  2300→  if (timeline) {\n  2301→    const timelineStartTime = ref<number | null>(null)\n  2302→    const executedSteps = new Set<number>()\n  2303→\n  2304→    const timelineRafControls = useRafFn(\n  2305→      (args) => {\n  2306→        if (!isPlaying.value || isPaused.value) {\n  2307→          timelineRafControls.pause()\n  2308→          return\n  2309→        }\n  2310→\n  2311→        const now = args.timestamp\n  2312→\n  2313→        // Initialize on first RAF callback instead of relying on watch\n  2314→        if (timelineStartTime.value === null) {\n  2315→          timelineStartTime.value = now\n  2316→        }\n  2317→\n  2318→        const elapsed = now - timelineStartTime.value\n  2319→        const duration = timeline.duration || Infinity\n  2320→\n  2321→        timeline.steps.forEach((step, index) => {\n  2322→          if (executedSteps.has(index)) return\n  2323→\n  2324→          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n  2325→\n  2326→          if (elapsed >= stepTime) {\n  2327→            executeTimelineStep(step)\n  2328→            executedSteps.add(index)\n  2329→          }\n  2330→        })\n  2331→\n  2332→        if (timeline.loop && elapsed >= duration) {\n  2333→          // Reset for loop\n  2334→          timelineStartTime.value = now\n  2335→          executedSteps.clear()\n  2336→        }\n  2337→      },\n  2338→      { immediate: false }\n  2339→    )\n  2340→\n  2341→    // Assign pause/resume to outer scope for use in pause()/resume() functions\n  2342→    pauseTimeline = timelineRafControls.pause\n  2343→    resumeTimeline = timelineRafControls.resume\n  2344→\n  2345→    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n  2346→      switch (step.action) {\n  2347→        case 'play':\n  2348→          if (step.target) {\n  2349→            // Animate a different target\n  2350→            const targetEl = unref(step.target)\n  2351→            if (targetEl && step.animation) {\n  2352→              const preset = step.animation.preset || 'fadeIn'\n  2353→              const presetConfig = animationPresets[preset]\n  2354→              const keyframes = step.animation.keyframes || presetConfig.keyframes\n  2355→              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n  2356→\n  2357→              targetEl.animate(keyframes as Keyframe[], {\n  2358→                duration,\n  2359→                easing: step.animation.easing || EASING.EASE_OUT,\n  2360→                fill: FILL_MODE.FORWARDS as FillMode,\n  2361→              })\n  2362→            }\n  2363→          } else {\n  2364→            play()\n  2365→          }\n  2366→          break\n  2367→        case 'pause':\n  2368→          pause()\n  2369→          break\n  2370→        case 'emit':\n  2371→          if (step.event) {\n  2372→            emit(step.event)\n  2373→          }\n  2374→          break\n  2375→        case 'callback':\n  2376→          step.callback?.()\n  2377→          break\n  2378→      }\n  2379→    }\n  2380→\n  2381→    watch(isPlaying, (playing) => {\n  2382→      if (playing) {\n  2383→        // Reset state for new cycle\n  2384→        executedSteps.clear()\n  2385→        timelineRafControls.resume()\n  2386→      } else {\n  2387→        timelineRafControls.pause()\n  2388→        timelineStartTime.value = null\n  2389→      }\n  2390→    })\n  2391→  }\n  2392→\n  2393→  // ===============================\n  2394→  // ENTER/EXIT PATTERN\n  2395→  // ===============================\n  2396→  if (enterExit) {\n  2397→    const hasEntered = ref(false)\n  2398→\n  2399→    // Set initial state based on trigger value\n  2400→    watch(isMounted, (mounted) => {\n  2401→      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n  2402→        const targetEl = unref(target) as HTMLElement | undefined\n  2403→        if (targetEl) {\n  2404→          const preset = enterExit.exit.preset || 'fadeOut'\n  2405→          const presetConfig = animationPresets[preset]\n  2406→          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n  2407→\n  2408→          // Apply final exit state immediately without animation\n  2409→          if (Array.isArray(keyframes) && keyframes.length > 0) {\n  2410→            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n  2411→            Object.assign(targetEl.style, finalFrame)\n  2412→          }\n  2413→        }\n  2414→      }\n  2415→    }, { immediate: true })\n  2416→\n  2417→    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n  2418→      if (!isMounted.value) return\n  2419→\n  2420→      if (shouldEnter && !wasEntered) {\n  2421→        // Enter animation\n  2422→        enterExit.onEnterStart?.()\n  2423→\n  2424→        if (!enterExit.skipInitial || hasEntered.value) {\n  2425→          const targetEl = unref(target) as HTMLElement | undefined\n  2426→          if (targetEl && enterExit.enter) {\n  2427→            const preset = enterExit.enter.preset || 'fadeIn'\n  2428→            const presetConfig = animationPresets[preset]\n  2429→            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n  2430→            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n  2431→\n  2432→            const anim = targetEl.animate(keyframes as Keyframe[], {\n  2433→              duration,\n  2434→              easing: enterExit.enter.easing || EASING.EASE_OUT,\n  2435→              fill: FILL_MODE.FORWARDS as FillMode,\n  2436→            })\n  2437→\n  2438→            await anim.finished\n  2439→          }\n  2440→        }\n  2441→\n  2442→        hasEntered.value = true\n  2443→        enterExit.onEnterComplete?.()\n  2444→\n  2445→      } else if (!shouldEnter && wasEntered) {\n  2446→        // Exit animation\n  2447→        enterExit.onExitStart?.()\n  2448→\n  2449→        if (!enterExit.skipInitial) {\n  2450→          const targetEl = unref(target) as HTMLElement | undefined\n  2451→          if (targetEl && enterExit.exit) {\n  2452→            const preset = enterExit.exit.preset || 'fadeOut'\n  2453→            const presetConfig = animationPresets[preset]\n  2454→            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n  2455→            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n  2456→\n  2457→            const anim = targetEl.animate(keyframes as Keyframe[], {\n  2458→              duration,\n  2459→              easing: enterExit.exit.easing || EASING.EASE_OUT,\n  2460→              fill: FILL_MODE.FORWARDS as FillMode,\n  2461→            })\n  2462→\n  2463→            await anim.finished\n  2464→          }\n  2465→        }\n  2466→\n  2467→        enterExit.onExitComplete?.()\n  2468→      }\n  2469→    }, { immediate: !enterExit.skipInitial })\n  2470→  }\n  2471→\n  2472→  // ===============================\n  2473→  // CSS VARIABLE INTEGRATION\n  2474→  // ===============================\n  2475→  const cssVarWatchers: Array<() => void> = []\n  2476→  const appliedCSSVars = new Set<string>()\n  2477→\n  2478→  const setCSSVar = (name: string, value: string | number) => {\n  2479→    const targetEl = unref(target) as HTMLElement | undefined\n  2480→    if (!targetEl) return\n  2481→\n  2482→    const varName = name.startsWith('--') ? name : `--${name}`\n  2483→    targetEl.style.setProperty(varName, String(value))\n  2484→    appliedCSSVars.add(varName)\n  2485→  }\n  2486→\n  2487→  const getCSSVar = (name: string): string | undefined => {\n  2488→    const targetEl = unref(target) as HTMLElement | undefined\n  2489→    if (!targetEl) return undefined\n  2490→\n  2491→    const varName = name.startsWith('--') ? name : `--${name}`\n  2492→    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  2493→  }\n  2494→\n  2495→  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n  2496→    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n  2497→      return watch(\n  2498→        valueRef,\n  2499→        (value) => {\n  2500→          setCSSVar(name, value)\n  2501→        },\n  2502→        { immediate: true }\n  2503→      )\n  2504→    })\n  2505→\n  2506→    cssVarWatchers.push(...stopHandles)\n  2507→\n  2508→    return () => {\n  2509→      stopHandles.forEach(stop => stop())\n  2510→    }\n  2511→  }\n  2512→\n  2513→  // ===============================\n  2514→  // CLEANUP\n  2515→  // ===============================\n  2516→  const cleanup = () => {\n  2517→    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n  2518→    isPlaying.value = false\n  2519→    isPaused.value = false\n  2520→\n  2521→    // Stop all RAF loops BEFORE state reset\n  2522→    pauseSequence?.()\n  2523→    pauseMotion?.()\n  2524→    pauseTimeline?.()\n  2525→\n  2526→    // Cleanup responsive system\n  2527→    cleanupResponsive?.()\n  2528→\n  2529→    // Now call stop() to cleanup other resources\n  2530→    stop()\n  2531→\n  2532→    // Remove all CSS variables\n  2533→    const targetEl = unref(target) as HTMLElement | undefined\n  2534→    if (targetEl) {\n  2535→      appliedCSSVars.forEach(varName => {\n  2536→        targetEl.style.removeProperty(varName)\n  2537→      })\n  2538→      appliedCSSVars.clear()\n  2539→    }\n  2540→\n  2541→    // Remove finish listeners\n  2542→    const anim = webAnimation?.animate.value\n  2543→    if (anim && finishListeners.has(anim)) {\n  2544→      const listener = finishListeners.get(anim)!\n  2545→      anim.removeEventListener('finish', listener)\n  2546→      finishListeners.delete(anim)\n  2547→    }\n  2548→\n  2549→    // Cleanup event listeners\n  2550→    stopListeners.forEach((unsubscribe) => unsubscribe())\n  2551→    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n  2552→\n  2553→    // Cancel animations\n  2554→    webAnimation?.cancel()\n  2555→\n  2556→    // Cleanup progress interval and watcher\n  2557→    if (activeProgressInterval.value !== null) {\n  2558→      clearInterval(activeProgressInterval.value)\n  2559→      activeProgressInterval.value = null\n  2560→    }\n  2561→    progressWatchStop?.() // Stop the progress watch itself\n  2562→\n  2563→    // Cleanup navigation listeners (Issue #3)\n  2564→    navigationCleanup.value?.()\n  2565→    navigationCleanup.value = null\n  2566→\n  2567→    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n  2568→    if (staggerAnimation?.activeTimeouts) {\n  2569→      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n  2570→      staggerAnimation.activeTimeouts.value = []\n  2571→    }\n  2572→    if (staggerAnimation?.activeAnimations) {\n  2573→      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n  2574→      staggerAnimation.activeAnimations.value = []\n  2575→    }\n  2576→    // Clear stagger loop timeout\n  2577→    if (stagger && staggerLoopTimeoutId !== null) {\n  2578→      clearTimeout(staggerLoopTimeoutId)\n  2579→      staggerLoopTimeoutId = null\n  2580→    }\n  2581→\n  2582→    // Reset state refs\n  2583→    if (motionPathAnimation) {\n  2584→      motionPathAnimation.progress.value = 0\n  2585→    }\n  2586→    if (timedSequence) {\n  2587→      timedSequence.currentIndex.value = 0\n  2588→      timedSequence.cycleIndex.value = 0\n  2589→    }\n  2590→\n  2591→    // Unregister consumer and cleanup state cache if no consumers remain\n  2592→    if (stateName && stateConsumers.has(stateName)) {\n  2593→      const consumers = stateConsumers.get(stateName)!\n  2594→      consumers.delete(consumerId)\n  2595→\n  2596→      // Issue #6 Fix: Use nextTick for atomic cleanup\n  2597→      cleanupStateName(stateName, consumers)\n  2598→    }\n  2599→  }\n  2600→\n  2601→  // Only register onUnmounted if we're in a component context\n  2602→  // getCurrentInstance returns null if called outside setup()\n  2603→  if (getCurrentInstance()) {\n  2604→    onUnmounted(cleanup)\n  2605→  }\n  2606→  // Note: If not in component context, caller must manually call cleanup()\n  2607→  // This is expected for tests and utilities that create animations dynamically\n  2608→\n  2609→  // ===============================\n  2610→  // RETURN API\n  2611→  // ===============================\n  2612→  return {\n  2613→    // Playback controls\n  2614→    play,\n  2615→    pause,\n  2616→    stop,\n  2617→    resume,\n  2618→\n  2619→    // State\n  2620→    isPlaying,\n  2621→    state,\n  2622→\n  2623→    // Events\n  2624→    emit,\n  2625→    on,\n  2626→\n  2627→    // Environment\n  2628→    canAnimate,\n  2629→    animationQuality,\n  2630→    shouldPauseAnimations,\n  2631→\n  2632→    // Web Animations\n  2633→    ...(webAnimation && {\n  2634→      animate: webAnimation.animate,\n  2635→      animateIn: webAnimation.animateIn,\n  2636→      animateOut: webAnimation.animateOut,\n  2637→    }),\n  2638→\n  2639→    // Timed Sequence\n  2640→    ...(timedSequence && {\n  2641→      sequence: timedSequence,\n  2642→    }),\n  2643→\n  2644→    // Scroll\n  2645→    ...(scrollAnimation && {\n  2646→      scroll: scrollAnimation,\n  2647→    }),\n  2648→\n  2649→    // Stagger\n  2650→    ...(staggerAnimation && {\n  2651→      stagger: staggerAnimation,\n  2652→    }),\n  2653→\n  2654→    // Motion Path\n  2655→    ...(motionPathAnimation && {\n  2656→      motionPath: motionPathAnimation,\n  2657→    }),\n  2658→\n  2659→    // Responsive (if enabled)\n  2660→    ...(responsiveSystem && {\n  2661→      responsive: responsiveSystem,\n  2662→    }),\n  2663→\n  2664→    // SVG ViewBox (if enabled)\n  2665→    ...(svgSystem && {\n  2666→      svg: svgSystem,\n  2667→    }),\n  2668→\n  2669→    // Grid Zones (if enabled)\n  2670→    ...(gridSystem && {\n  2671→      grid: gridSystem,\n  2672→    }),\n  2673→\n  2674→    // CSS Variables\n  2675→    setCSSVar,\n  2676→    getCSSVar,\n  2677→    syncCSSVars,\n  2678→\n  2679→    // Cleanup\n  2680→    cleanup,\n  2681→  }\n  2682→}\n  2683→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"0ee543f0-7ce4-44d5-9e14-248527db88ae","timestamp":"2025-10-09T00:19:43.827Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","content":"        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = toValue(scrollContainer)\n      if (!container) return 0\n\n      // Type guard to check if container is window\n      const isWindow = container === window\n      const scrollHeight = isWindow\n        ? document.documentElement.scrollHeight - (typeof window !== 'undefined' ? window.innerHeight : 0)\n        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = toValue(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","numLines":964,"startLine":1720,"totalLines":2683}}}
{"parentUuid":"0ee543f0-7ce4-44d5-9e14-248527db88ae","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01KWfRNJ2DE1Vw3bQSn7XPX3","type":"message","role":"assistant","content":[{"type":"text","text":"The issue is that the check on line 1723 already verifies that `anim.currentTime !== null`, so TypeScript should know it's not null. However, TypeScript's control flow analysis might not be seeing this properly. Let me add an explicit null guard:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":34637,"cache_read_input_tokens":138844,"cache_creation":{"ephemeral_5m_input_tokens":34637,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfcjZvDL8GZVaEVfahg","type":"assistant","uuid":"92a87bba-4d97-4ef4-a55b-492a3d3f06bb","timestamp":"2025-10-09T00:19:52.180Z"}
{"parentUuid":"92a87bba-4d97-4ef4-a55b-492a3d3f06bb","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01KWfRNJ2DE1Vw3bQSn7XPX3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011f6w2RAx5Rw7V3HiWbCbbh","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","old_string":"        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }","new_string":"        const timing = anim.effect?.getTiming()\n        const currentTime = anim.currentTime\n        if (timing && typeof timing.duration === 'number' && currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":34637,"cache_read_input_tokens":138844,"cache_creation":{"ephemeral_5m_input_tokens":34637,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfcjZvDL8GZVaEVfahg","type":"assistant","uuid":"ab595e39-42d9-45fe-bc94-b796309653d7","timestamp":"2025-10-09T00:19:54.670Z"}
{"parentUuid":"ab595e39-42d9-45fe-bc94-b796309653d7","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011f6w2RAx5Rw7V3HiWbCbbh","type":"tool_result","content":"The file /Users/natedamstra/socialaize/src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1718→          }\n  1719→          return\n  1720→        }\n  1721→\n  1722→        const timing = anim.effect?.getTiming()\n  1723→        const currentTime = anim.currentTime\n  1724→        if (timing && typeof timing.duration === 'number' && currentTime !== null) {\n  1725→          const progress = Math.max(0, Math.min(1, currentTime / timing.duration))\n  1726→          lifecycle.onProgress!(progress)\n  1727→        }\n  1728→      }, 16) // ~60fps\n  1729→\n  1730→      activeProgressInterval.value = progressInterval\n  1731→"}]},"uuid":"e535f491-7e7e-462b-a9eb-ab1794328c32","timestamp":"2025-10-09T00:19:54.773Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","oldString":"        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }","newString":"        const timing = anim.effect?.getTiming()\n        const currentTime = anim.currentTime\n        if (timing && typeof timing.duration === 'number' && currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = toValue(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<ReturnType<typeof setInterval> | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const element = toValue(target)\n            if (!element) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = toValue(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = toValue(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => toValue(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = toValue(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = toValue(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = toValue(scrollContainer)\n      if (!container) return 0\n\n      // Type guard to check if container is window\n      const isWindow = container === window\n      const scrollHeight = isWindow\n        ? document.documentElement.scrollHeight - (typeof window !== 'undefined' ? window.innerHeight : 0)\n        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = toValue(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1720,"oldLines":8,"newStart":1720,"newLines":9,"lines":["         }"," ","         const timing = anim.effect?.getTiming()","-        if (timing && typeof timing.duration === 'number' && anim.currentTime !== null) {","-          const progress = Math.max(0, Math.min(1, anim.currentTime / timing.duration))","+        const currentTime = anim.currentTime","+        if (timing && typeof timing.duration === 'number' && currentTime !== null) {","+          const progress = Math.max(0, Math.min(1, currentTime / timing.duration))","           lifecycle.onProgress!(progress)","         }","       }, 16) // ~60fps"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"e535f491-7e7e-462b-a9eb-ab1794328c32","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017qJAtX8ec5UuwKkC2KnZUS","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now let me fix the last remaining error - the sequence return type at line 1932. The issue is that `useCycleList` returns `Ref<T>` but the return type expects `ComputedRef<T | undefined>`. Let me fix that:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":557,"cache_read_input_tokens":173481,"cache_creation":{"ephemeral_5m_input_tokens":557,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfdXhp6YMx2r7ZF9Tsk","type":"assistant","uuid":"e337f6c2-3268-472c-a495-44b9d26a9e55","timestamp":"2025-10-09T00:20:02.009Z"}
{"parentUuid":"e337f6c2-3268-472c-a495-44b9d26a9e55","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017qJAtX8ec5UuwKkC2KnZUS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Hewk9jheY7bA31ZNH7vsnS","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","old_string":"    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }","new_string":"    timedSequence = {\n      currentIndex,\n      currentElement: computed(() => currentElement.value),\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":557,"cache_read_input_tokens":173481,"cache_creation":{"ephemeral_5m_input_tokens":557,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfdXhp6YMx2r7ZF9Tsk","type":"assistant","uuid":"d9b14e9e-df06-4b04-8c87-ffa395243bee","timestamp":"2025-10-09T00:20:04.175Z"}
{"parentUuid":"d9b14e9e-df06-4b04-8c87-ffa395243bee","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Hewk9jheY7bA31ZNH7vsnS","type":"tool_result","content":"The file /Users/natedamstra/socialaize/src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1927→        startTime.value = null\n  1928→      }\n  1929→    })\n  1930→\n  1931→    timedSequence = {\n  1932→      currentIndex,\n  1933→      currentElement: computed(() => currentElement.value),\n  1934→      cycleIndex,\n  1935→      next,\n  1936→      prev,\n  1937→      goTo,\n  1938→    }\n  1939→  }\n  1940→\n  1941→  // ===============================\n  1942→  // SCROLL-TRIGGERED ANIMATIONS"}]},"uuid":"4798a655-c747-4458-a476-4f86c5df2b2e","timestamp":"2025-10-09T00:20:04.324Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","oldString":"    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }","newString":"    timedSequence = {\n      currentIndex,\n      currentElement: computed(() => currentElement.value),\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = toValue(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<ReturnType<typeof setInterval> | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const element = toValue(target)\n            if (!element) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = toValue(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = toValue(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => toValue(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = toValue(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = toValue(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        const currentTime = anim.currentTime\n        if (timing && typeof timing.duration === 'number' && currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement,\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = toValue(scrollContainer)\n      if (!container) return 0\n\n      // Type guard to check if container is window\n      const isWindow = container === window\n      const scrollHeight = isWindow\n        ? document.documentElement.scrollHeight - (typeof window !== 'undefined' ? window.innerHeight : 0)\n        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = toValue(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1930,"oldLines":7,"newStart":1930,"newLines":7,"lines":[" ","     timedSequence = {","       currentIndex,","-      currentElement,","+      currentElement: computed(() => currentElement.value),","       cycleIndex,","       next,","       prev,"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"4798a655-c747-4458-a476-4f86c5df2b2e","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01JJtRNyMxooro59HqPHoPC9","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now let me run typecheck one more time to verify all the useAnimation errors are fixed:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":662,"cache_read_input_tokens":174038,"cache_creation":{"ephemeral_5m_input_tokens":662,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfeD7QFg5c23Fc2BJMH","type":"assistant","uuid":"8f057be7-db4d-45cb-8c92-b7fa4adf6ee0","timestamp":"2025-10-09T00:20:10.131Z"}
{"parentUuid":"8f057be7-db4d-45cb-8c92-b7fa4adf6ee0","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01JJtRNyMxooro59HqPHoPC9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PM1m2wKvay8E6HvojSVfQm","name":"Bash","input":{"command":"npm run typecheck 2>&1 | grep -A 2 \"useAnimation.ts.*error\" | head -30","description":"Check for remaining useAnimation errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":662,"cache_read_input_tokens":174038,"cache_creation":{"ephemeral_5m_input_tokens":662,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfeD7QFg5c23Fc2BJMH","type":"assistant","uuid":"31f3ee62-f318-4199-9ac4-71d789bdaf81","timestamp":"2025-10-09T00:20:11.210Z"}
{"parentUuid":"31f3ee62-f318-4199-9ac4-71d789bdaf81","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PM1m2wKvay8E6HvojSVfQm","type":"tool_result","content":"\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1962\u001b[0m:\u001b[93m24\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2367): \u001b[0mThis comparison appears to be unintentional because the types 'HTMLElement' and 'Window & typeof globalThis' have no overlap.\n\n\u001b[7m1962\u001b[0m       const isWindow = container === window\n--\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1958\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'Ref<HTMLElement | undefined, HTMLElement | undefined> | Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to parameter of type 'MaybeRefOrGetter<HTMLElement | undefined>'.\n  Type 'Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to type 'MaybeRefOrGetter<HTMLElement | undefined>'.\n\n--\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1725\u001b[0m:\u001b[93m52\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2362): \u001b[0mThe left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n\n\u001b[7m1725\u001b[0m           const progress = Math.max(0, Math.min(1, currentTime / timing.duration))","is_error":false}]},"uuid":"c076bc58-e632-4c7f-b036-fb03cf449696","timestamp":"2025-10-09T00:20:45.463Z","toolUseResult":{"stdout":"\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1962\u001b[0m:\u001b[93m24\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2367): \u001b[0mThis comparison appears to be unintentional because the types 'HTMLElement' and 'Window & typeof globalThis' have no overlap.\n\n\u001b[7m1962\u001b[0m       const isWindow = container === window\n--\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1958\u001b[0m:\u001b[93m33\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2345): \u001b[0mArgument of type 'Ref<HTMLElement | undefined, HTMLElement | undefined> | Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to parameter of type 'MaybeRefOrGetter<HTMLElement | undefined>'.\n  Type 'Ref<(Window & typeof globalThis) | undefined, (Window & typeof globalThis) | undefined>' is not assignable to type 'MaybeRefOrGetter<HTMLElement | undefined>'.\n\n--\n\u001b[96msrc/components/composables/useAnimation.ts\u001b[0m:\u001b[93m1725\u001b[0m:\u001b[93m52\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m ts(2362): \u001b[0mThe left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n\n\u001b[7m1725\u001b[0m           const progress = Math.max(0, Math.min(1, currentTime / timing.duration))","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"c076bc58-e632-4c7f-b036-fb03cf449696","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01RrQfjpAQMK6wnMRNac9xKK","type":"message","role":"assistant","content":[{"type":"text","text":"The `currentTime` issue persists because TypeScript still thinks it might be null even after the check. The real issue is that `anim.currentTime` returns `CSSNumberish | null` which includes non-number types. Let me fix this more properly:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":520,"cache_read_input_tokens":174700,"cache_creation":{"ephemeral_5m_input_tokens":520,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CTvfhG8oM7CKd2P1Dnx7n","type":"assistant","uuid":"b8b0e5ae-4334-4812-bdae-bc5364bc6b89","timestamp":"2025-10-09T00:20:52.376Z"}
{"parentUuid":"b8b0e5ae-4334-4812-bdae-bc5364bc6b89","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01RrQfjpAQMK6wnMRNac9xKK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JgZHcMoRxCedspmZ9Kz6bd","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","old_string":"        const timing = anim.effect?.getTiming()\n        const currentTime = anim.currentTime\n        if (timing && typeof timing.duration === 'number' && currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }","new_string":"        const timing = anim.effect?.getTiming()\n        const currentTime = anim.currentTime\n        if (timing && typeof timing.duration === 'number' && currentTime !== null && typeof currentTime === 'number') {\n          const progress = Math.max(0, Math.min(1, currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":520,"cache_read_input_tokens":174700,"cache_creation":{"ephemeral_5m_input_tokens":520,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CTvfhG8oM7CKd2P1Dnx7n","type":"assistant","uuid":"c7903415-12b2-41f5-9dc9-115144c11cc1","timestamp":"2025-10-09T00:20:55.134Z"}
{"parentUuid":"c7903415-12b2-41f5-9dc9-115144c11cc1","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JgZHcMoRxCedspmZ9Kz6bd","type":"tool_result","content":"The file /Users/natedamstra/socialaize/src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1718→          }\n  1719→          return\n  1720→        }\n  1721→\n  1722→        const timing = anim.effect?.getTiming()\n  1723→        const currentTime = anim.currentTime\n  1724→        if (timing && typeof timing.duration === 'number' && currentTime !== null && typeof currentTime === 'number') {\n  1725→          const progress = Math.max(0, Math.min(1, currentTime / timing.duration))\n  1726→          lifecycle.onProgress!(progress)\n  1727→        }\n  1728→      }, 16) // ~60fps\n  1729→\n  1730→      activeProgressInterval.value = progressInterval\n  1731→"}]},"uuid":"43cdf553-7e22-4288-a562-cae2c9435bbf","timestamp":"2025-10-09T00:20:55.341Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","oldString":"        const timing = anim.effect?.getTiming()\n        const currentTime = anim.currentTime\n        if (timing && typeof timing.duration === 'number' && currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }","newString":"        const timing = anim.effect?.getTiming()\n        const currentTime = anim.currentTime\n        if (timing && typeof timing.duration === 'number' && currentTime !== null && typeof currentTime === 'number') {\n          const progress = Math.max(0, Math.min(1, currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = toValue(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<ReturnType<typeof setInterval> | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const element = toValue(target)\n            if (!element) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = toValue(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = toValue(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => toValue(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = toValue(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = toValue(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        const currentTime = anim.currentTime\n        if (timing && typeof timing.duration === 'number' && currentTime !== null) {\n          const progress = Math.max(0, Math.min(1, currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement: computed(() => currentElement.value),\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = toValue(scrollContainer)\n      if (!container) return 0\n\n      // Type guard to check if container is window\n      const isWindow = container === window\n      const scrollHeight = isWindow\n        ? document.documentElement.scrollHeight - (typeof window !== 'undefined' ? window.innerHeight : 0)\n        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = toValue(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1721,"oldLines":7,"newStart":1721,"newLines":7,"lines":[" ","         const timing = anim.effect?.getTiming()","         const currentTime = anim.currentTime","-        if (timing && typeof timing.duration === 'number' && currentTime !== null) {","+        if (timing && typeof timing.duration === 'number' && currentTime !== null && typeof currentTime === 'number') {","           const progress = Math.max(0, Math.min(1, currentTime / timing.duration))","           lifecycle.onProgress!(progress)","         }"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"43cdf553-7e22-4288-a562-cae2c9435bbf","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01X1UzJugcG5UF4kPKwP4snm","type":"message","role":"assistant","content":[{"type":"text","text":"Good! Now let me fix the scroll container issue. The problem is that `toValue` doesn't work well with the union type that includes Window. I need to cast the scrollContainer parameter differently:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":773,"cache_read_input_tokens":175220,"cache_creation":{"ephemeral_5m_input_tokens":773,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfhy4RHTivr5pSnvAVk","type":"assistant","uuid":"2149195e-d54b-42f3-9cd0-f064523142c3","timestamp":"2025-10-09T00:21:02.159Z"}
{"parentUuid":"2149195e-d54b-42f3-9cd0-f064523142c3","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01X1UzJugcG5UF4kPKwP4snm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JW6twJGms5VHh5RAEynuMM","name":"Edit","input":{"file_path":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","old_string":"  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = toValue(scrollContainer)\n      if (!container) return 0\n\n      // Type guard to check if container is window\n      const isWindow = container === window\n      const scrollHeight = isWindow\n        ? document.documentElement.scrollHeight - (typeof window !== 'undefined' ? window.innerHeight : 0)\n        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight","new_string":"  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      // Handle Window vs HTMLElement types explicitly\n      const containerValue = scroll.container ? toValue(scroll.container) : (typeof window !== 'undefined' ? window : undefined)\n      if (!containerValue) return 0\n\n      const scrollHeight = containerValue === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : (containerValue as HTMLElement).scrollHeight - (containerValue as HTMLElement).clientHeight"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":773,"cache_read_input_tokens":175220,"cache_creation":{"ephemeral_5m_input_tokens":773,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfhy4RHTivr5pSnvAVk","type":"assistant","uuid":"7dd9aa9a-c00f-4541-9b47-aaad1302d552","timestamp":"2025-10-09T00:21:07.564Z"}
{"parentUuid":"7dd9aa9a-c00f-4541-9b47-aaad1302d552","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JW6twJGms5VHh5RAEynuMM","type":"tool_result","content":"The file /Users/natedamstra/socialaize/src/components/composables/useAnimation.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1947→        isScrolling: Ref<boolean>\n  1948→      }\n  1949→    | undefined\n  1950→\n  1951→  if (scroll) {\n  1952→    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n  1953→    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n  1954→\n  1955→    const scrollProgress = computed(() => {\n  1956→      if (!isMounted.value) return 0\n  1957→\n  1958→      // Handle Window vs HTMLElement types explicitly\n  1959→      const containerValue = scroll.container ? toValue(scroll.container) : (typeof window !== 'undefined' ? window : undefined)\n  1960→      if (!containerValue) return 0\n  1961→\n  1962→      const scrollHeight = containerValue === window\n  1963→        ? document.documentElement.scrollHeight - window.innerHeight\n  1964→        : (containerValue as HTMLElement).scrollHeight - (containerValue as HTMLElement).clientHeight\n  1965→\n  1966→      if (scrollHeight <= 0) return 0\n  1967→\n  1968→      const rawProgress = scrollY.value / scrollHeight"}]},"uuid":"9bf51539-1b18-4b15-969b-db8557aa1fb7","timestamp":"2025-10-09T00:21:07.679Z","toolUseResult":{"filePath":"/Users/natedamstra/socialaize/src/components/composables/useAnimation.ts","oldString":"  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = toValue(scrollContainer)\n      if (!container) return 0\n\n      // Type guard to check if container is window\n      const isWindow = container === window\n      const scrollHeight = isWindow\n        ? document.documentElement.scrollHeight - (typeof window !== 'undefined' ? window.innerHeight : 0)\n        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight","newString":"  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      // Handle Window vs HTMLElement types explicitly\n      const containerValue = scroll.container ? toValue(scroll.container) : (typeof window !== 'undefined' ? window : undefined)\n      if (!containerValue) return 0\n\n      const scrollHeight = containerValue === window\n        ? document.documentElement.scrollHeight - window.innerHeight\n        : (containerValue as HTMLElement).scrollHeight - (containerValue as HTMLElement).clientHeight","originalFile":"import { computed, reactive, ref, watch, unref, onUnmounted, nextTick, getCurrentInstance, type Ref, type ComputedRef, type CSSProperties } from 'vue'\nimport {\n  useElementVisibility,\n  useDocumentVisibility,\n  usePreferredReducedMotion,\n  useRafFn,\n  useEventBus,\n  useMounted,\n  useBattery,\n  useFps,\n  useIdle,\n  usePageLeave,\n  useAnimate,\n  useCycleList,\n  useScroll,\n  toValue,\n  type EventBusKey,\n  type MaybeRefOrGetter,\n  type UseAnimateKeyframes,\n  type UseAnimateOptions,\n} from '@vueuse/core'\n\n// Import existing presets and constants\nimport { ANIMATION_DURATION, EASING, FILL_MODE } from '@/constants/animations'\n\n// Export preset system for convenient animation configuration\nexport { preset, presets } from './useAnimationPresets'\n\nexport interface AnimationPreset {\n  keyframes: UseAnimateKeyframes\n  options: number | UseAnimateOptions\n}\n\nexport const animationPresets = {\n  slideUp: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideDown: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(-20px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeIn: {\n    keyframes: [\n      { opacity: 0 },\n      { opacity: 1 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  fadeOut: {\n    keyframes: [\n      { opacity: 1 },\n      { opacity: 0 }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleUp: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1.05)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleDown: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.8)' },\n      { opacity: 1, transform: 'scale(1)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.BOUNCE,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  scaleOut: {\n    keyframes: [\n      { opacity: 1, transform: 'scale(1)' },\n      { opacity: 0, transform: 'scale(0.8)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.EASE_OUT,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  staggerFadeIn: {\n    keyframes: [\n      { opacity: 0, transform: 'translateY(10px)' },\n      { opacity: 1, transform: 'translateY(0px)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  popIn: {\n    keyframes: [\n      { opacity: 0, transform: 'scale(0.5) rotate(-10deg)' },\n      { opacity: 1, transform: 'scale(1.05) rotate(2deg)' },\n      { opacity: 1, transform: 'scale(1) rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.SLOW,\n      easing: EASING.ELASTIC,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotate45: {\n    keyframes: [\n      { transform: 'rotate(0deg)' },\n      { transform: 'rotate(45deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  rotateBack: {\n    keyframes: [\n      { transform: 'rotate(45deg)' },\n      { transform: 'rotate(0deg)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SMOOTH,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInRight: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutRight: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideInLeft: {\n    keyframes: [\n      { opacity: 0, transform: 'translateX(-100%)' },\n      { opacity: 1, transform: 'translateX(0%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.NORMAL,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n\n  slideOutLeft: {\n    keyframes: [\n      { opacity: 1, transform: 'translateX(0%)' },\n      { opacity: 0, transform: 'translateX(-100%)' }\n    ],\n    options: {\n      duration: ANIMATION_DURATION.FAST,\n      easing: EASING.SHARP,\n      fill: FILL_MODE.FORWARDS\n    }\n  } as AnimationPreset,\n} as const\n\n/**\n * Web Animation Builder API options\n */\nexport interface CreateAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n  delay?: number\n  fill?: FillMode\n  onStart?: () => void\n  onComplete?: () => void\n  onCancel?: () => void\n}\n\n/**\n * Web Animation Builder API return type\n */\nexport interface CreateAnimationReturn {\n  play: () => Promise<void>\n  pause: () => void\n  cancel: () => void\n  reverse: () => void\n  seek: (time: number) => void\n  animation: Ref<Animation | undefined>\n  cleanup: () => void\n}\n\n/**\n * Web Animation Builder API\n *\n * Simplified API for creating and controlling Web Animations with proper lifecycle management.\n *\n * @example\n * ```ts\n * const fadeIn = createAnimation(elementRef, {\n *   preset: 'fadeIn',\n *   duration: 500,\n *   onComplete: () => console.log('Done!')\n * })\n *\n * await fadeIn.play()\n * fadeIn.seek(250) // Jump to 50%\n * fadeIn.reverse() // Play backward\n * ```\n */\n// Issue #5 Fix: WeakMap for listener tracking to prevent memory leaks\nconst createAnimationFinishListeners = new WeakMap<Animation, () => void>()\nconst createAnimationCancelListeners = new WeakMap<Animation, () => void>()\n\nexport function createAnimation(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: CreateAnimationOptions\n): CreateAnimationReturn {\n  const targetEl = computed(() => unref(target))\n  const animRef = ref<Animation>()\n\n  const play = async () => {\n    const el = targetEl.value\n    if (!el) return\n\n    // Cancel existing animation and remove listeners\n    if (animRef.value) {\n      const currentAnim = animRef.value\n\n      // Remove listeners BEFORE cancel to avoid race condition\n      const finishListener = createAnimationFinishListeners.get(currentAnim)\n      if (finishListener) {\n        currentAnim.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(currentAnim)\n      }\n      const cancelListener = createAnimationCancelListeners.get(currentAnim)\n      if (cancelListener) {\n        currentAnim.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(currentAnim)\n      }\n\n      currentAnim.cancel()\n      animRef.value = undefined\n    }\n\n    const preset = options.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n\n    // Fallback for unknown presets\n    const keyframes = options.keyframes || presetConfig?.keyframes || [\n      { opacity: 1 },\n      { opacity: 0 }\n    ]\n    const duration = options.duration || ANIMATION_DURATION.NORMAL\n\n    options.onStart?.()\n\n    const element = toValue(el)\n    if (!element) return\n\n    const anim = element.animate(keyframes as Keyframe[], {\n      duration,\n      easing: options.easing || EASING.EASE_OUT,\n      delay: options.delay || 0,\n      fill: options.fill || FILL_MODE.FORWARDS as FillMode\n    })\n\n    animRef.value = anim\n\n    // Attach listeners with { once: true } to auto-cleanup\n    if (options.onComplete) {\n      const listener = () => options.onComplete!()\n      anim.addEventListener('finish', listener, { once: true })\n      createAnimationFinishListeners.set(anim, listener)\n    }\n\n    if (options.onCancel) {\n      const listener = () => options.onCancel!()\n      anim.addEventListener('cancel', listener, { once: true })\n      createAnimationCancelListeners.set(anim, listener)\n    }\n\n    try {\n      await anim.finished\n    } catch {\n      // Animation was cancelled, ignore\n    }\n  }\n\n  const pause = () => animRef.value?.pause()\n\n  const cancel = () => animRef.value?.cancel()\n\n  const reverse = () => animRef.value?.reverse()\n\n  const seek = (time: number) => {\n    if (animRef.value) {\n      animRef.value.currentTime = time\n    }\n  }\n\n  const cleanup = () => {\n    if (animRef.value) {\n      const finishListener = createAnimationFinishListeners.get(animRef.value)\n      if (finishListener) {\n        animRef.value.removeEventListener('finish', finishListener)\n        createAnimationFinishListeners.delete(animRef.value)\n      }\n      const cancelListener = createAnimationCancelListeners.get(animRef.value)\n      if (cancelListener) {\n        animRef.value.removeEventListener('cancel', cancelListener)\n        createAnimationCancelListeners.delete(animRef.value)\n      }\n      animRef.value.cancel()\n      animRef.value = undefined\n    }\n  }\n\n  // Note: Don't use onUnmounted here - createAnimation may be called outside component context\n  // Caller is responsible for calling cleanup() manually\n\n  return { play, pause, cancel, reverse, seek, animation: animRef, cleanup }\n}\n\n/**\n * Helper function to calculate stagger delays\n */\nfunction calculateStaggerDelays(count: number, options: UseAnimationStaggerOptions): number[] {\n  const { delay, from = 'start', ease = 'linear', grid } = options\n  const delays: number[] = []\n\n  if (grid) {\n    // 2D grid stagger\n    const [cols, rows] = grid\n    for (let i = 0; i < count; i++) {\n      const col = i % cols\n      const row = Math.floor(i / cols)\n      const distance = from === 'center'\n        ? Math.sqrt(Math.pow(col - cols / 2, 2) + Math.pow(row - rows / 2, 2))\n        : from === 'end'\n          ? (cols - col) + (rows - row)\n          : col + row\n\n      delays.push(distance * delay)\n    }\n  } else {\n    // 1D linear stagger\n    for (let i = 0; i < count; i++) {\n      const position = from === 'start'\n        ? i\n        : from === 'end'\n          ? count - 1 - i\n          : Math.abs(i - count / 2)\n\n      let normalizedDelay = position * delay\n\n      // Apply easing\n      if (ease !== 'linear') {\n        const t = position / (count - 1 || 1)\n        let easedT = t\n\n        if (ease === 'ease-in') {\n          easedT = t * t\n        } else if (ease === 'ease-out') {\n          easedT = 1 - Math.pow(1 - t, 2)\n        } else if (ease.startsWith('cubic-bezier')) {\n          // Simple approximation for cubic-bezier - would need full implementation\n          easedT = t\n        }\n\n        normalizedDelay = easedT * delay * count\n      }\n\n      delays.push(normalizedDelay)\n    }\n  }\n\n  return delays\n}\n\n/**\n * Animation state cache for shared state management\n */\nconst stateCache = new Map<string, any>()\nconst initialStateCache = new Map<string, any>()\n\n/**\n * Reference counting for state cache cleanup\n */\nconst stateConsumers = new Map<string, Set<symbol>>()\n\n/**\n * Issue #6 Fix: Atomic state cache cleanup helper\n * Uses nextTick to ensure cleanup happens after all synchronous operations\n */\nfunction cleanupStateName(stateName: string, consumers: Set<symbol>) {\n  // Use nextTick to defer cleanup and double-check atomically\n  nextTick(() => {\n    if (consumers.size === 0) {\n      stateCache.delete(stateName)\n      initialStateCache.delete(stateName)\n      stateConsumers.delete(stateName)\n    }\n  })\n}\n\n/**\n * Event bus registry for shared event coordination\n */\nconst busRegistry = new Map<string, Map<string, ReturnType<typeof useEventBus>>>()\n\n/**\n * Global environment cache (singleton)\n */\nlet cachedEnvironment: {\n  prefersReducedMotion: Ref<'reduce' | 'no-preference'>\n  batteryInfo: ReturnType<typeof useBattery>\n  fps: Ref<number> | null\n  idle: { idle: Ref<boolean>; lastActive: Ref<number>; reset: () => void } | null\n  isPageLeft: Ref<boolean> | null\n} | null = null\n\n/**\n * Autoplay configuration\n */\nexport interface UseAnimationAutoplayOptions {\n  threshold?: number\n  enabled?: Ref<boolean>\n  includeNavigation?: boolean\n}\n\n/**\n * Event system configuration\n */\nexport interface UseAnimationEventsOptions {\n  busName?: string\n  emitOnStart?: string\n  emitOnStop?: string\n  listenForStop?: string\n}\n\n/**\n * Environment respect configuration\n */\nexport interface UseAnimationEnvironmentOptions {\n  reducedMotion?: boolean\n  battery?: boolean\n  fps?: boolean\n  idle?: boolean\n  pageLeave?: boolean\n}\n\n/**\n * Web Animations API configuration\n */\nexport interface UseAnimationWebAnimationOptions {\n  preset?: keyof typeof animationPresets\n  keyframes?: UseAnimateKeyframes\n  duration?: number\n  easing?: string\n}\n\n/**\n * Timed sequence configuration (for RAF-based element activation)\n */\nexport interface UseAnimationSequenceOptions<T = any> {\n  elements: T[] | Ref<T[]>\n  interval: number | Ref<number> // Duration per element (ms)\n  mode?: 'sequence' | 'loop' | 'stagger' | 'unison'\n  onActivate: (element: T, index: number, context: {\n    cycleIndex: number\n    elapsedInCycle: number\n    totalElapsed: number\n  }) => void\n  onCycleComplete?: () => void\n}\n\n/**\n * Scroll-triggered animation configuration\n */\nexport interface UseAnimationScrollOptions {\n  container?: Ref<HTMLElement | undefined>\n  threshold?: [number, number] // Start/end scroll % [0, 1]\n  mode?: 'toggle' | 'scrub'\n  offset?: { start?: number; end?: number }\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Stagger animation configuration\n */\nexport interface UseAnimationStaggerOptions {\n  children: string | HTMLElement[] | Ref<HTMLElement[]>\n  delay: number\n  from?: 'start' | 'end' | 'center'\n  ease?: 'linear' | 'ease-in' | 'ease-out' | string\n  grid?: [number, number]\n  resetOnRestart?: boolean // Whether to reset elements to initial state before restarting (default: true)\n  loop?: boolean // Whether to automatically restart the stagger after completion (default: false)\n  loopDelay?: number // Delay before restarting loop in ms (default: 0)\n}\n\n/**\n * Motion path configuration\n */\nexport interface UseAnimationMotionPathOptions {\n  type: 'circular' | 'elliptical' | 'custom'\n  radius?: number | { x: number; y: number }\n  startAngle?: number\n  duration: number\n  direction?: 'clockwise' | 'counterclockwise'\n  path?: string // SVG path for custom motion\n  autoRotate?: boolean // Whether to rotate element along the path (default: false)\n}\n\n/**\n * Animation timeline step\n */\nexport interface UseAnimationTimelineStep {\n  at: number | string\n  target?: Ref<HTMLElement | undefined>\n  action: 'play' | 'pause' | 'emit' | 'callback'\n  animation?: UseAnimationWebAnimationOptions\n  event?: string\n  callback?: () => void\n}\n\n/**\n * Animation timeline configuration\n */\nexport interface UseAnimationTimelineOptions {\n  steps: UseAnimationTimelineStep[]\n  loop?: boolean\n  duration?: number\n}\n\n/**\n * Enter/Exit animation configuration\n */\nexport interface UseAnimationEnterExitOptions {\n  trigger: Ref<boolean>\n  enter?: UseAnimationWebAnimationOptions\n  exit?: UseAnimationWebAnimationOptions\n  skipInitial?: boolean\n  onEnterStart?: () => void\n  onEnterComplete?: () => void\n  onExitStart?: () => void\n  onExitComplete?: () => void\n}\n\n/**\n * Lifecycle hook system configuration\n */\nexport interface UseAnimationLifecycleOptions {\n  beforePlay?: () => void | Promise<void>\n  afterPlay?: () => void\n  beforePause?: () => void\n  afterPause?: () => void\n  beforeStop?: () => void\n  afterStop?: () => void\n  beforeResume?: () => void\n  afterResume?: () => void\n  onCancel?: () => void\n  onProgress?: (progress: number) => void\n}\n\n/**\n * Main useAnimation options\n */\nexport interface UseAnimationOptions<T = any> {\n  // Auto-play configuration\n  autoplay?: boolean | UseAnimationAutoplayOptions\n\n  // Event system (replaces useAnimationBus)\n  events?: UseAnimationEventsOptions\n\n  // State management (replaces useAnimationState)\n  stateName?: string\n  initialState?: Record<string, any>\n\n  // Environment (replaces useAnimationEnvironment)\n  respectEnvironment?: boolean | UseAnimationEnvironmentOptions\n\n  // Priority system (simplified two-tier: critical vs normal)\n  critical?: boolean // If true, never auto-pause (for essential UI feedback like spinners, button states)\n\n  // Web Animations (replaces useAnimateElement)\n  animation?: UseAnimationWebAnimationOptions\n\n  // Timed sequence (NEW - replaces useTimedSequence)\n  sequence?: UseAnimationSequenceOptions<T>\n\n  // Scroll-triggered animations\n  scroll?: UseAnimationScrollOptions\n\n  // Stagger animations\n  stagger?: UseAnimationStaggerOptions\n\n  // Motion path animations\n  motionPath?: UseAnimationMotionPathOptions\n\n  // Animation timeline\n  timeline?: UseAnimationTimelineOptions\n\n  // Enter/Exit pattern\n  enterExit?: UseAnimationEnterExitOptions\n\n  // Lifecycle hooks\n  lifecycle?: UseAnimationLifecycleOptions\n\n  // Callbacks (deprecated in favor of lifecycle hooks, but kept for backward compatibility)\n  onStart?: () => void\n  onStop?: () => void\n  onComplete?: () => void\n\n  // Responsive animation support\n  responsive?: boolean | UseAnimationResponsiveOptions\n\n  // SVG ViewBox coordinate system (NEW)\n  svg?: UseAnimationSVGOptions\n\n  // CSS Grid zone layout (NEW)\n  grid?: UseAnimationGridOptions\n}\n\n/**\n * Responsive animation options\n */\nexport interface UseAnimationResponsiveOptions {\n  enabled?: boolean\n  baselineWidth?: number // Default: 1440\n  minScale?: number // Default: 0.5\n  maxScale?: number // Default: 1.5\n  debounce?: number // Default: 100ms\n  scalingMode?: 'container' | 'viewport' | 'svg' | 'grid' // Default: 'container'\n}\n\n/**\n * SVG ViewBox coordinate system options\n */\nexport interface UseAnimationSVGOptions {\n  viewBox: { width: number; height: number } // SVG coordinate space (e.g., { width: 1440, height: 400 })\n  preserveAspectRatio?: string // Default: 'xMidYMid meet'\n  anchors?: Record<string, { x: number; y: number }> // Named anchor points in SVG space\n}\n\n/**\n * Grid zone layout options\n */\nexport interface UseAnimationGridOptions {\n  columns: string // e.g., '1fr 2fr 1fr' or 'minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)'\n  rows?: string // Optional, default: '1fr'\n  gap?: string // e.g., 'clamp(1rem, 2cqw, 2rem)'\n  zones?: Record<string, { column: number; row?: number }> // Named zones (1-indexed)\n}\n\n/**\n * Responsive dimensions tracking\n */\nexport interface ResponsiveDimensions {\n  width: number\n  height: number\n  scale: number\n  aspectRatio: number\n}\n\n/**\n * Animation quality level\n */\nexport type AnimationQuality = 'none' | 'low' | 'medium' | 'high'\n\n/**\n * useAnimation return type\n */\nexport interface UseAnimationReturn<TState = any, TElement = any> {\n  // Playback controls\n  play: () => void\n  pause: () => void\n  stop: () => void\n  resume: () => void\n\n  // State access\n  isPlaying: Ref<boolean>\n  state: TState\n\n  // Event emitter\n  emit: <K extends string>(event: K, payload?: any) => void\n  on: <K extends string>(event: K, handler: (payload: any) => void) => () => void\n\n  // Environment info\n  canAnimate: ComputedRef<boolean>\n  animationQuality: ComputedRef<AnimationQuality>\n  shouldPauseAnimations: ComputedRef<boolean>\n\n  // Animation instance (if Web Animations enabled)\n  animate?: Ref<Animation | undefined>\n  animateIn?: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n  animateOut?: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n\n  // Sequence controls (if sequence enabled)\n  sequence?: {\n    currentIndex: Ref<number>\n    currentElement: ComputedRef<TElement | undefined>\n    cycleIndex: Ref<number>\n    next: () => void\n    prev: () => void\n    goTo: (index: number) => void\n  }\n\n  // Scroll controls (if scroll enabled)\n  scroll?: {\n    progress: ComputedRef<number>\n    isScrolling: Ref<boolean>\n  }\n\n  // Stagger controls (if stagger enabled)\n  stagger?: {\n    elements: Ref<HTMLElement[]>\n    triggerStagger: () => void\n    activeTimeouts?: Ref<Array<ReturnType<typeof setTimeout>>>\n    activeAnimations?: Ref<Animation[]>\n  }\n\n  // Motion path controls (if motionPath enabled)\n  motionPath?: {\n    progress: Ref<number>\n    setProgress: (progress: number) => void\n  }\n\n  // Responsive controls (if responsive enabled)\n  responsive?: {\n    dimensions: Ref<ResponsiveDimensions>\n    scaleValue: ComputedRef<(baseValue: number) => number>\n    getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n    getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n  }\n\n  // SVG ViewBox utilities (if svg enabled)\n  svg?: {\n    svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n    screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n    getAnchor: (name: string) => { x: number; y: number } | undefined\n    anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n    viewBoxString: ComputedRef<string>\n    svgScale: ComputedRef<{ x: number; y: number }>\n  }\n\n  // Grid zone utilities (if grid enabled)\n  grid?: {\n    getZoneRect: (zoneName: string) => DOMRect | undefined\n    getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n    zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n    gridTemplateColumns: ComputedRef<string>\n    gridTemplateRows: ComputedRef<string>\n    gridGap: ComputedRef<string>\n  }\n\n  // CSS variable utilities\n  setCSSVar: (name: string, value: string | number) => void\n  getCSSVar: (name: string) => string | undefined\n  syncCSSVars: (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>) => () => void\n\n  // Cleanup\n  cleanup: () => void\n}\n\n/**\n * Universal animation orchestrator that consolidates:\n * - useAnimationBus (event coordination)\n * - useAnimationState (state management)\n * - useAnimationEnvironment (environment detection)\n * - useAnimateElement (Web Animations API)\n *\n * @example Using animation presets\n * ```typescript\n * import { useAnimation, preset } from '@composables/useAnimation'\n *\n * // Use preset as-is\n * const orbitAnim = useAnimation(iconRef, preset('orbitingIcon'))\n *\n * // With overrides\n * const customOrbit = useAnimation(iconRef, preset('orbitingIcon', {\n *   motionPath: { radius: 120, duration: 3000 }\n * }))\n *\n * // Stagger animation preset\n * const stagger = useAnimation(containerRef, preset('staggerFade', {\n *   stagger: { children: '.custom-item', delay: 150 }\n * }))\n *\n * // Combine preset with other options\n * const enhanced = useAnimation(ref, preset('fadeInUp', {\n *   autoplay: { threshold: 0.5 },\n *   lifecycle: {\n *     afterPlay: () => console.log('Animation complete!')\n *   }\n * }))\n * ```\n *\n * @example Manual configuration (without presets)\n * ```typescript\n * const customAnim = useAnimation(ref, {\n *   animation: {\n *     keyframes: [\n *       { opacity: 0, transform: 'scale(0.8)' },\n *       { opacity: 1, transform: 'scale(1)' }\n *     ],\n *     duration: 600\n *   },\n *   autoplay: true\n * })\n * ```\n */\nexport function useAnimation<TState = any, TElement = any>(\n  target: MaybeRefOrGetter<HTMLElement | undefined>,\n  options: UseAnimationOptions<TElement> = {}\n): UseAnimationReturn<TState, TElement> {\n  const {\n    autoplay = false,\n    events,\n    stateName,\n    initialState,\n    respectEnvironment = true,\n    critical = false,\n    animation,\n    sequence,\n    scroll,\n    stagger,\n    motionPath,\n    timeline,\n    enterExit,\n    lifecycle,\n    onStart,\n    onStop,\n    onComplete,\n    responsive = false,\n    svg,\n    grid,\n  } = options\n\n  const isMounted = useMounted()\n\n  // Create unique consumer ID for reference counting\n  const consumerId = Symbol('animation-consumer')\n\n  // Pause state (separate from isPlaying to avoid breaking timeline timing)\n  const isPaused = ref(false)\n\n  // Track active progress interval for cleanup\n  const activeProgressInterval = ref<ReturnType<typeof setInterval> | null>(null)\n\n  // Parse autoplay options\n  const autoplayOptions: UseAnimationAutoplayOptions =\n    typeof autoplay === 'boolean'\n      ? { threshold: 0.25, enabled: ref(autoplay) }\n      : { threshold: autoplay.threshold || 0.25, enabled: autoplay.enabled || ref(true) }\n\n  // Parse environment options\n  const envOptions: UseAnimationEnvironmentOptions =\n    typeof respectEnvironment === 'boolean'\n      ? { reducedMotion: true, battery: true, fps: true, idle: true, pageLeave: true }\n      : {\n          reducedMotion: respectEnvironment.reducedMotion !== false,\n          battery: respectEnvironment.battery !== false,\n          fps: respectEnvironment.fps !== false,\n          idle: respectEnvironment.idle !== false, // Changed from === true to !== false (opt-out instead of opt-in)\n          pageLeave: respectEnvironment.pageLeave !== false,\n        }\n\n  // ===============================\n  // ENVIRONMENT DETECTION (replaces useAnimationEnvironment)\n  // ===============================\n  if (!cachedEnvironment) {\n    const prefersReducedMotion = usePreferredReducedMotion()\n    const batteryInfo = useBattery()\n    const fps = envOptions.fps ? useFps({ every: 10 }) : null\n    const idle = envOptions.idle\n      ? useIdle(5 * 60 * 1000) // 5 minutes\n      : null\n    const isPageLeft = envOptions.pageLeave ? usePageLeave() : null\n\n    cachedEnvironment = {\n      prefersReducedMotion,\n      batteryInfo,\n      fps,\n      idle,\n      isPageLeft,\n    }\n  }\n\n  const env = cachedEnvironment\n\n  // Computed environment flags\n  const reducedMotion = computed(\n    () => envOptions.reducedMotion && isMounted.value && env.prefersReducedMotion.value === 'reduce'\n  )\n\n  const batteryOptimization = computed(() => {\n    if (!envOptions.battery) return false\n    const level = env.batteryInfo.level.value\n    // Changed threshold from 0.2 to 0.2 (20%) for earlier auto-pause\n    return typeof level === 'number' ? level < 0.2 && !env.batteryInfo.charging.value : false\n  })\n\n  const lowFps = computed(() => envOptions.fps && env.fps ? env.fps.value < 30 : false)\n\n  const userIdle = computed(() => envOptions.idle && env.idle ? env.idle.idle.value : false)\n\n  const pageLeft = computed(() => envOptions.pageLeave && env.isPageLeft ? env.isPageLeft.value : false)\n\n  const canAnimate = computed(\n    () => !reducedMotion.value && !batteryOptimization.value && !lowFps.value\n  )\n\n  const shouldPauseAnimations = computed(\n    () => userIdle.value || pageLeft.value || (batteryOptimization.value && env.batteryInfo.level.value < 0.1)\n  )\n\n  const animationQuality = computed<AnimationQuality>(() => {\n    if (reducedMotion.value) return 'none'\n    if (batteryOptimization.value) return 'low'\n    if (lowFps.value) return 'medium'\n    return 'high'\n  })\n\n  // ===============================\n  // RESPONSIVE SUPPORT (NEW)\n  // ===============================\n  let responsiveSystem:\n    | {\n        dimensions: Ref<ResponsiveDimensions>\n        scaleValue: ComputedRef<(baseValue: number) => number>\n        getResponsiveRadius: ComputedRef<(baseRadius: number) => number>\n        getResponsiveOffset: ComputedRef<(baseOffset: { x: number; y: number }) => { x: number; y: number }>\n      }\n    | undefined\n\n  let cleanupResponsive: (() => void) | undefined\n\n  if (responsive) {\n    const responsiveOptions: UseAnimationResponsiveOptions =\n      typeof responsive === 'boolean'\n        ? { enabled: true, baselineWidth: 1440, minScale: 0.5, maxScale: 1.5, debounce: 100 }\n        : {\n            enabled: responsive.enabled !== false,\n            baselineWidth: responsive.baselineWidth || 1440,\n            minScale: responsive.minScale || 0.5,\n            maxScale: responsive.maxScale || 1.5,\n            debounce: responsive.debounce || 100,\n          }\n\n    if (responsiveOptions.enabled) {\n      const dimensions = ref<ResponsiveDimensions>({\n        width: 0,\n        height: 0,\n        scale: 1,\n        aspectRatio: 1,\n      })\n\n      let resizeObserver: ResizeObserver | null = null\n      let debounceTimer: ReturnType<typeof setTimeout> | null = null\n\n      const updateDimensions = (entries: ResizeObserverEntry[]) => {\n        if (debounceTimer) clearTimeout(debounceTimer)\n\n        debounceTimer = setTimeout(() => {\n          try {\n            const entry = entries[0]\n            if (!entry) return\n\n            const { width, height } = entry.contentRect\n\n            // Validate dimensions are positive numbers\n            if (!width || !height || width <= 0 || height <= 0) return\n\n            // Calculate scale factor relative to baseline\n            const rawScale = width / responsiveOptions.baselineWidth!\n            const clampedScale = Math.max(\n              responsiveOptions.minScale!,\n              Math.min(responsiveOptions.maxScale!, rawScale)\n            )\n\n            dimensions.value = {\n              width,\n              height,\n              scale: clampedScale,\n              aspectRatio: width / height || 1,\n            }\n          } catch (error) {\n            // Silently handle ResizeObserver errors to prevent crashes\n            console.warn('[useAnimation] ResizeObserver update failed:', error)\n          }\n        }, responsiveOptions.debounce)\n      }\n\n      // Setup ResizeObserver on mount\n      watch(\n        isMounted,\n        (mounted) => {\n          if (mounted) {\n            const element = toValue(target)\n            if (!element) {\n              console.warn('[useAnimation] Cannot setup responsive system: target element not found')\n              return\n            }\n\n            try {\n              // Check if ResizeObserver is supported\n              if (typeof ResizeObserver === 'undefined') {\n                console.warn('[useAnimation] ResizeObserver not supported in this browser')\n                return\n              }\n\n              resizeObserver = new ResizeObserver(updateDimensions)\n              resizeObserver.observe(element)\n\n              // Initial measurement\n              const rect = element.getBoundingClientRect()\n              if (rect.width > 0 && rect.height > 0) {\n                updateDimensions([\n                  {\n                    contentRect: rect,\n                    target: element,\n                  } as unknown as ResizeObserverEntry,\n                ])\n              }\n            } catch (error) {\n              console.error('[useAnimation] Failed to create ResizeObserver:', error)\n            }\n          }\n        },\n        { immediate: true }\n      )\n\n      // Helper functions\n      const scaleValue = computed(\n        () => (baseValue: number) => baseValue * dimensions.value.scale\n      )\n\n      const getResponsiveRadius = computed(\n        () => (baseRadius: number) => Math.round(scaleValue.value(baseRadius))\n      )\n\n      const getResponsiveOffset = computed(\n        () => (baseOffset: { x: number; y: number }) => ({\n          x: Math.round(scaleValue.value(baseOffset.x)),\n          y: Math.round(scaleValue.value(baseOffset.y)),\n        })\n      )\n\n      responsiveSystem = {\n        dimensions,\n        scaleValue,\n        getResponsiveRadius,\n        getResponsiveOffset,\n      }\n\n      // Cleanup function for ResizeObserver\n      cleanupResponsive = () => {\n        if (resizeObserver) {\n          resizeObserver.disconnect()\n          resizeObserver = null\n        }\n        if (debounceTimer) {\n          clearTimeout(debounceTimer)\n          debounceTimer = null\n        }\n      }\n\n      // Register cleanup on unmount if in component context\n      if (getCurrentInstance()) {\n        onUnmounted(cleanupResponsive)\n      }\n    }\n  }\n\n  // ===============================\n  // SVG VIEWBOX COORDINATE SYSTEM (NEW)\n  // ===============================\n  let svgSystem:\n    | {\n        svgToScreen: ComputedRef<(svgX: number, svgY: number) => { x: number; y: number }>\n        screenToSvg: ComputedRef<(screenX: number, screenY: number) => { x: number; y: number }>\n        getAnchor: (name: string) => { x: number; y: number } | undefined\n        anchorToStyle: ComputedRef<(anchorName: string, offsetX?: number, offsetY?: number) => CSSProperties>\n        viewBoxString: ComputedRef<string>\n        svgScale: ComputedRef<{ x: number; y: number }>\n      }\n    | undefined\n\n  if (svg) {\n    const viewBoxString = computed(() => `0 0 ${svg.viewBox.width} ${svg.viewBox.height}`)\n\n    // Calculate scale factor between SVG space and screen space\n    const svgScale = computed(() => {\n      const element = toValue(target)\n      if (!element) return { x: 1, y: 1 }\n\n      const rect = element.getBoundingClientRect()\n      return {\n        x: rect.width / svg.viewBox.width,\n        y: rect.height / svg.viewBox.height,\n      }\n    })\n\n    // Convert SVG coordinates to screen pixels\n    const svgToScreen = computed(\n      () => (svgX: number, svgY: number) => {\n        const scale = svgScale.value\n        return {\n          x: svgX * scale.x,\n          y: svgY * scale.y,\n        }\n      }\n    )\n\n    // Convert screen pixels to SVG coordinates\n    const screenToSvg = computed(\n      () => (screenX: number, screenY: number) => {\n        const scale = svgScale.value\n        return {\n          x: screenX / scale.x,\n          y: screenY / scale.y,\n        }\n      }\n    )\n\n    // Get anchor point coordinates\n    const getAnchor = (name: string) => {\n      return svg.anchors?.[name]\n    }\n\n    // Convert anchor to CSS positioning style with optional offset\n    const anchorToStyle = computed(\n      () =>\n        (anchorName: string, offsetX = 0, offsetY = 0): CSSProperties => {\n          const anchor = getAnchor(anchorName)\n          if (!anchor) {\n            console.warn(`[useAnimation] Anchor \"${anchorName}\" not found`)\n            return {}\n          }\n\n          const screenPos = svgToScreen.value(anchor.x, anchor.y)\n          const scale = Math.min(svgScale.value.x, svgScale.value.y) // Uniform scaling\n\n          return {\n            position: 'absolute',\n            left: `${screenPos.x + offsetX}px`,\n            top: `${screenPos.y + offsetY}px`,\n            transform: `scale(${scale})`,\n            transformOrigin: '0 0',\n          }\n        }\n    )\n\n    svgSystem = {\n      svgToScreen,\n      screenToSvg,\n      getAnchor,\n      anchorToStyle,\n      viewBoxString,\n      svgScale,\n    }\n  }\n\n  // ===============================\n  // CSS GRID ZONE SYSTEM (NEW)\n  // ===============================\n  let gridSystem:\n    | {\n        getZoneRect: (zoneName: string) => DOMRect | undefined\n        getZoneCenter: (zoneName: string) => { x: number; y: number } | undefined\n        zoneToStyle: ComputedRef<(zoneName: string) => CSSProperties>\n        gridTemplateColumns: ComputedRef<string>\n        gridTemplateRows: ComputedRef<string>\n        gridGap: ComputedRef<string>\n      }\n    | undefined\n\n  if (grid) {\n    const gridTemplateColumns = computed(() => grid.columns)\n    const gridTemplateRows = computed(() => grid.rows || '1fr')\n    const gridGap = computed(() => grid.gap || '0')\n\n    // Get the bounding rectangle of a grid zone\n    const getZoneRect = (zoneName: string): DOMRect | undefined => {\n      const element = toValue(target)\n      if (!element) return undefined\n\n      const zone = grid.zones?.[zoneName]\n      if (!zone) {\n        console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n        return undefined\n      }\n\n      // Query for the zone element using data attribute or class\n      const zoneEl = element.querySelector(`[data-zone=\"${zoneName}\"]`) as HTMLElement\n      if (!zoneEl) {\n        console.warn(`[useAnimation] Zone element for \"${zoneName}\" not found. Add data-zone=\"${zoneName}\" attribute.`)\n        return undefined\n      }\n\n      return zoneEl.getBoundingClientRect()\n    }\n\n    // Get the center point of a grid zone\n    const getZoneCenter = (zoneName: string): { x: number; y: number } | undefined => {\n      const rect = getZoneRect(zoneName)\n      if (!rect) return undefined\n\n      return {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      }\n    }\n\n    // Generate CSS grid positioning for a zone\n    const zoneToStyle = computed(\n      () =>\n        (zoneName: string): CSSProperties => {\n          const zone = grid.zones?.[zoneName]\n          if (!zone) {\n            console.warn(`[useAnimation] Zone \"${zoneName}\" not found`)\n            return {}\n          }\n\n          return {\n            gridColumn: String(zone.column),\n            gridRow: zone.row ? String(zone.row) : '1',\n          }\n        }\n    )\n\n    gridSystem = {\n      getZoneRect,\n      getZoneCenter,\n      zoneToStyle,\n      gridTemplateColumns,\n      gridTemplateRows,\n      gridGap,\n    }\n  }\n\n  // ===============================\n  // STATE MANAGEMENT (replaces useAnimationState)\n  // ===============================\n  let state: TState\n\n  if (stateName) {\n    // Register consumer for reference counting\n    if (!stateConsumers.has(stateName)) {\n      stateConsumers.set(stateName, new Set())\n    }\n    stateConsumers.get(stateName)!.add(consumerId)\n\n    // Get or create shared state\n    if (!stateCache.has(stateName)) {\n      const resolved = initialState || {}\n      const cloned = structuredClone(resolved)\n      stateCache.set(stateName, reactive({ isPlaying: false, ...cloned }))\n      initialStateCache.set(stateName, structuredClone(cloned))\n    }\n    state = stateCache.get(stateName) as TState\n  } else {\n    // Local state\n    state = reactive({ isPlaying: false, ...(initialState || {}) }) as TState\n  }\n\n  const isPlaying = computed({\n    get: () => (state as any).isPlaying,\n    set: (value: boolean) => {\n      ;(state as any).isPlaying = value\n    },\n  })\n\n  // ===============================\n  // EVENT SYSTEM (replaces useAnimationBus)\n  // ===============================\n  const busName = events?.busName || 'default'\n\n  if (!busRegistry.has(busName)) {\n    busRegistry.set(busName, new Map())\n  }\n  const eventBuses = busRegistry.get(busName)!\n\n  const getEventBus = (eventName: string) => {\n    const namespacedKey = `${busName}:${eventName}` as unknown as EventBusKey<any>\n    if (!eventBuses.has(eventName)) {\n      eventBuses.set(eventName, useEventBus(namespacedKey))\n    }\n    return eventBuses.get(eventName)!\n  }\n\n  const emit = <K extends string>(event: K, payload?: any) => {\n    const bus = getEventBus(event)\n    bus.emit(payload)\n  }\n\n  const on = <K extends string>(event: K, handler: (payload: any) => void) => {\n    const bus = getEventBus(event)\n    return bus.on(handler as any)\n  }\n\n  // Listen for stop events\n  const stopListeners: Array<() => void> = []\n  if (events?.listenForStop) {\n    const unsubscribe = on(events.listenForStop, () => {\n      stop()\n    })\n    stopListeners.push(unsubscribe)\n  }\n\n  // ===============================\n  // AUTO-PLAY LOGIC (replaces manual visibility watchers)\n  // ===============================\n  const targetElement = computed(() => toValue(target))\n  const elementVisible = autoplay\n    ? useElementVisibility(targetElement, { threshold: autoplayOptions.threshold })\n    : ref(false)\n  const documentVisible = autoplay ? useDocumentVisibility() : ref('visible')\n\n  // Navigation tracking (Astro-specific)\n  // Issue #3 Fix: Store cleanup function for use outside component context\n  const currentPath = ref(typeof window !== 'undefined' ? window.location.pathname : '')\n  const navigationCleanup = ref<(() => void) | null>(null)\n\n  if (autoplay && autoplayOptions.includeNavigation && typeof window !== 'undefined') {\n    const handleNavigationChange = () => {\n      const newPath = window.location.pathname\n      if (newPath !== currentPath.value) {\n        currentPath.value = newPath\n        stop()\n      }\n    }\n\n    window.addEventListener('popstate', handleNavigationChange)\n    if (typeof document !== 'undefined') {\n      document.addEventListener('astro:before-preparation', handleNavigationChange)\n      document.addEventListener('astro:page-load', handleNavigationChange)\n    }\n\n    // Store cleanup function for manual cleanup\n    navigationCleanup.value = () => {\n      window.removeEventListener('popstate', handleNavigationChange)\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('astro:before-preparation', handleNavigationChange)\n        document.removeEventListener('astro:page-load', handleNavigationChange)\n      }\n    }\n\n    onUnmounted(() => {\n      navigationCleanup.value?.()\n      navigationCleanup.value = null\n    })\n  }\n\n  const shouldAutoplay = computed(() => {\n    if (!autoplay) return false\n    if (!autoplayOptions.enabled?.value) return false\n    if (documentVisible.value !== 'visible') return false\n    if (!canAnimate.value) return false\n    return elementVisible.value\n  })\n\n  // ===============================\n  // WEB ANIMATIONS API (replaces useAnimateElement)\n  // ===============================\n  let webAnimation:\n    | {\n        animate: Ref<Animation | undefined>\n        play: () => void\n        pause: () => void\n        cancel: () => void\n        animateIn: (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n        animateOut: (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => Promise<void | Animation | undefined>\n      }\n    | undefined\n\n  // Skip container animation if stagger is configured (animation config used for children only)\n  if (animation && !stagger) {\n    const preset = animation.preset || 'fadeIn'\n    const presetConfig = animationPresets[preset]\n    const keyframes = animation.keyframes || presetConfig.keyframes\n    const baseOptions =\n      typeof presetConfig.options === 'object' ? presetConfig.options : { duration: presetConfig.options }\n\n    const baseDuration = animation.duration || (typeof baseOptions.duration === 'number' ? baseOptions.duration : ANIMATION_DURATION.NORMAL)\n\n    const effectiveDuration = computed(() => {\n      switch (animationQuality.value) {\n        case 'none':\n          return 0\n        case 'low':\n          return baseDuration * 0.3\n        case 'medium':\n          return baseDuration * 0.6\n        case 'high':\n          return baseDuration\n      }\n    })\n\n    const animationOptions = computed(\n      () =>\n        ({\n          ...baseOptions,\n          duration: effectiveDuration.value,\n          ...(animation.easing && { easing: animation.easing }),\n          immediate: false,\n          // onReady fires immediately, not when animation finishes - removed\n        }) as UseAnimateOptions\n    )\n\n    const webAnimAPI = useAnimate(target, keyframes, animationOptions.value)\n\n    const animateIn = async (customKeyframes?: UseAnimateKeyframes, customOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element && Array.isArray(keyframes) && keyframes.length > 0) {\n          const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      if (customKeyframes && webAnimAPI.animate.value) {\n        webAnimAPI.cancel()\n        const element = toValue(target)\n        if (element) {\n          const newAnimation = element.animate(customKeyframes as Keyframe[], {\n            ...animationOptions.value,\n            ...customOptions,\n          })\n          if (onComplete) newAnimation.addEventListener('finish', onComplete)\n          return newAnimation\n        }\n      } else {\n        webAnimAPI.play()\n      }\n    }\n\n    const animateOut = async (outKeyframes?: UseAnimateKeyframes, outOptions?: UseAnimateOptions) => {\n      if (!isMounted.value || !webAnimAPI.isSupported.value) return\n\n      if (animationQuality.value === 'none' || !canAnimate.value) {\n        const element = toValue(target)\n        if (element) {\n          const defaultOutKeyframes = [\n            { opacity: 1, transform: 'scale(1)' },\n            { opacity: 0, transform: 'scale(0.8)' },\n          ]\n          // Handle outKeyframes which might be a Ref or array\n          let finalFrame: Record<string, any> = defaultOutKeyframes[1]\n          if (outKeyframes && Array.isArray(outKeyframes) && outKeyframes.length > 0) {\n            finalFrame = outKeyframes[outKeyframes.length - 1] as Record<string, any>\n          }\n          Object.assign(element.style, finalFrame)\n        }\n        onComplete?.()\n        return\n      }\n\n      const defaultOutKeyframes = [\n        { opacity: 1, transform: 'scale(1)' },\n        { opacity: 0, transform: 'scale(0.8)' },\n      ]\n      const defaultOutDuration =\n        animationQuality.value === 'low'\n          ? ANIMATION_DURATION.FAST * 0.3\n          : animationQuality.value === 'medium'\n            ? ANIMATION_DURATION.FAST * 0.6\n            : ANIMATION_DURATION.FAST\n      const defaultOutOptions = {\n        duration: defaultOutDuration,\n        easing: EASING.EASE_OUT,\n        fill: FILL_MODE.FORWARDS as FillMode,\n      }\n      const element = toValue(target)\n      if (element) {\n        const anim = element.animate((outKeyframes || defaultOutKeyframes) as Keyframe[], {\n          ...defaultOutOptions,\n          ...outOptions,\n        })\n        if (onComplete) anim.addEventListener('finish', onComplete)\n        return anim\n      }\n    }\n\n    webAnimation = {\n      animate: webAnimAPI.animate,\n      play: webAnimAPI.play,\n      pause: webAnimAPI.pause,\n      cancel: webAnimAPI.cancel,\n      animateIn,\n      animateOut,\n    }\n  }\n\n  // ===============================\n  // FINISH LISTENER TRACKING\n  // ===============================\n  const finishListeners = new WeakMap<Animation, () => void>()\n\n  // ===============================\n  // PLAYBACK CONTROLS\n  // ===============================\n  const play = async () => {\n    // Lifecycle: beforePlay\n    if (lifecycle?.beforePlay) {\n      await lifecycle.beforePlay()\n    }\n\n    // Always set isPlaying to allow timeline/sequence to run\n    // (they coordinate child callbacks, not Web Animations)\n    isPlaying.value = true\n    onStart?.()\n    if (events?.emitOnStart) emit(events.emitOnStart)\n\n    // Only skip Web Animations if environment conditions don't allow\n    // Timeline and sequence still run to coordinate child components\n    if (canAnimate.value && animationQuality.value !== 'none') {\n      webAnimation?.play()\n\n      // Attach onComplete listener using addEventListener for proper replay support\n      const anim = webAnimation?.animate.value\n      if (anim && onComplete) {\n        // Remove previous listener if exists\n        const prevListener = finishListeners.get(anim)\n        if (prevListener) {\n          anim.removeEventListener('finish', prevListener)\n        }\n\n        // Add new listener\n        const finishHandler = () => {\n          if (isPlaying.value) {\n            onComplete()\n          }\n        }\n\n        anim.addEventListener('finish', finishHandler)\n        finishListeners.set(anim, finishHandler)\n      }\n    } else {\n      // Environment doesn't allow Web Animations, but timeline/sequence still run\n      // This allows child component coordination to work even in degraded environments\n      if (onComplete) {\n        // If there's no Web Animation, complete immediately\n        onComplete()\n      }\n    }\n\n    // Lifecycle: afterPlay\n    lifecycle?.afterPlay?.()\n  }\n\n  const pause = () => {\n    // Lifecycle: beforePause\n    lifecycle?.beforePause?.()\n\n    isPaused.value = true\n    webAnimation?.pause()\n\n    // Explicitly pause all RAF systems\n    if (timedSequence) pauseSequence?.()\n    if (motionPathAnimation) pauseMotion?.()\n    if (timeline) pauseTimeline?.()\n\n    // Lifecycle: afterPause\n    lifecycle?.afterPause?.()\n  }\n\n  const stop = () => {\n    // Lifecycle: beforeStop\n    lifecycle?.beforeStop?.()\n\n    isPlaying.value = false\n    isPaused.value = false // Reset pause state on stop\n    onStop?.()\n    if (events?.emitOnStop) emit(events.emitOnStop)\n\n    // Lifecycle: onCancel (if animation was cancelled)\n    lifecycle?.onCancel?.()\n\n    webAnimation?.cancel()\n\n    // Clear stagger timeouts and animations to prevent animations on stopped/unmounted components\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation && 'activeAnimations' in staggerAnimation) {\n      (staggerAnimation as any).activeAnimations.value.forEach((anim: Animation) => anim.cancel())\n      ;(staggerAnimation as any).activeAnimations.value = []\n    }\n\n    // Lifecycle: afterStop\n    lifecycle?.afterStop?.()\n  }\n\n  const resume = () => {\n    // Lifecycle: beforeResume\n    lifecycle?.beforeResume?.()\n\n    isPaused.value = false\n    if (isPlaying.value) {\n      webAnimation?.play()\n\n      // Resume RAF systems\n      if (timedSequence) resumeSequence?.()\n      if (motionPathAnimation) resumeMotion?.()\n      if (timeline) resumeTimeline?.()\n    }\n\n    // Lifecycle: afterResume\n    lifecycle?.afterResume?.()\n  }\n\n  // ===============================\n  // LIFECYCLE: PROGRESS TRACKING\n  // ===============================\n  // Issue #1 Fix: Use WeakMap for event listeners and proper cleanup\n  const progressEventListeners = new WeakMap<Animation, { finish: () => void; cancel: () => void }>()\n  let progressWatchStop: (() => void) | undefined\n\n  if (lifecycle?.onProgress && webAnimation?.animate) {\n    progressWatchStop = watch(() => webAnimation.animate.value, (anim, oldAnim) => {\n      // Remove old animation listeners BEFORE clearing interval\n      if (oldAnim) {\n        const oldListeners = progressEventListeners.get(oldAnim)\n        if (oldListeners) {\n          oldAnim.removeEventListener('finish', oldListeners.finish)\n          oldAnim.removeEventListener('cancel', oldListeners.cancel)\n          progressEventListeners.delete(oldAnim)\n        }\n      }\n\n      // Cleanup previous interval\n      if (activeProgressInterval.value !== null) {\n        clearInterval(activeProgressInterval.value)\n        activeProgressInterval.value = null\n      }\n\n      if (!anim) return\n\n      // Poll for progress updates\n      const progressInterval = setInterval(() => {\n        if (!anim || anim.playState === 'finished' || anim.playState === 'idle') {\n          if (activeProgressInterval.value !== null) {\n            clearInterval(activeProgressInterval.value)\n            activeProgressInterval.value = null\n          }\n          return\n        }\n\n        const timing = anim.effect?.getTiming()\n        const currentTime = anim.currentTime\n        if (timing && typeof timing.duration === 'number' && currentTime !== null && typeof currentTime === 'number') {\n          const progress = Math.max(0, Math.min(1, currentTime / timing.duration))\n          lifecycle.onProgress!(progress)\n        }\n      }, 16) // ~60fps\n\n      activeProgressInterval.value = progressInterval\n\n      // Cleanup on animation finish/cancel using WeakMap\n      const finishHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n        lifecycle.onProgress!(1) // Final progress\n      }\n      const cancelHandler = () => {\n        if (activeProgressInterval.value !== null) {\n          clearInterval(activeProgressInterval.value)\n          activeProgressInterval.value = null\n        }\n      }\n\n      anim.addEventListener('finish', finishHandler, { once: true })\n      anim.addEventListener('cancel', cancelHandler, { once: true })\n      progressEventListeners.set(anim, { finish: finishHandler, cancel: cancelHandler })\n    }, { immediate: true })\n  }\n\n  // ===============================\n  // WATCHERS\n  // ===============================\n\n  // Auto-play watcher\n  if (autoplay) {\n    watch(shouldAutoplay, (should) => {\n      if (should && !isPlaying.value) {\n        play()\n      } else if (!should && isPlaying.value) {\n        stop()\n      }\n    }, { immediate: true })\n  }\n\n  // Auto-pause on environment changes (unless animation is critical)\n  watch(shouldPauseAnimations, (shouldPause) => {\n    // Skip auto-pause for critical animations (e.g., loading spinners, essential UI feedback)\n    if (critical) return\n\n    if (shouldPause && isPlaying.value) {\n      pause()\n    } else if (!shouldPause && isPlaying.value) {\n      resume()\n    }\n  })\n\n  // ===============================\n  // TIMED SEQUENCE (NEW - replaces useTimedSequence)\n  // ===============================\n\n  // Declare RAF control functions at higher scope for pause/resume access\n  let pauseSequence: (() => void) | undefined\n  let resumeSequence: (() => void) | undefined\n  let pauseMotion: (() => void) | undefined\n  let resumeMotion: (() => void) | undefined\n  let pauseTimeline: (() => void) | undefined\n  let resumeTimeline: (() => void) | undefined\n\n  let timedSequence:\n    | {\n        currentIndex: Ref<number>\n        currentElement: ComputedRef<TElement | undefined>\n        cycleIndex: Ref<number>\n        next: () => void\n        prev: () => void\n        goTo: (index: number) => void\n      }\n    | undefined\n\n  if (sequence) {\n    const elements = computed(() => (Array.isArray(sequence.elements) ? sequence.elements : sequence.elements.value))\n    const interval = computed(() => (typeof sequence.interval === 'number' ? sequence.interval : sequence.interval.value))\n    const mode = sequence.mode || 'loop'\n\n    // Use VueUse's useCycleList for element cycling\n    const { state: currentElement, index: currentIndex, next, prev, go: goTo } = useCycleList(elements)\n\n    const cycleIndex = ref(0)\n    const startTime = ref<number | null>(null)\n    const currentCycleStartTime = ref(0)\n\n    // RAF loop for timed activation\n    const rafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          rafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (startTime.value === null) {\n          startTime.value = now\n          currentCycleStartTime.value = now\n        }\n\n        const totalElapsed = now - startTime.value\n        const elapsedSinceCycle = now - currentCycleStartTime.value\n        const elementsArray = elements.value\n\n        if (!elementsArray.length) {\n          rafControls.pause()\n          return\n        }\n\n        if (mode === 'loop' || mode === 'sequence') {\n          // Sequential activation: one element at a time\n          if (elapsedSinceCycle >= interval.value) {\n            const element = elementsArray[currentIndex.value]\n            const elapsedInCycle = elapsedSinceCycle\n\n            // Activate current element\n            sequence.onActivate(element, currentIndex.value, {\n              cycleIndex: cycleIndex.value,\n              elapsedInCycle,\n              totalElapsed,\n            })\n\n            // Move to next element\n            if (currentIndex.value === elementsArray.length - 1) {\n              // Cycle complete\n              cycleIndex.value++\n              sequence.onCycleComplete?.()\n\n              if (mode === 'sequence') {\n                // Stop after one sequence\n                stop()\n                return\n              }\n            }\n\n            next()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'stagger') {\n          // Stagger: activate elements with delays based on their index\n          const timePerElement = interval.value / elementsArray.length\n\n          elementsArray.forEach((element, index) => {\n            const activationTime = index * timePerElement\n            const nextActivationTime = (index + 1) * timePerElement\n\n            if (elapsedSinceCycle >= activationTime && elapsedSinceCycle < nextActivationTime) {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle - activationTime,\n                totalElapsed,\n              })\n            }\n          })\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        } else if (mode === 'unison') {\n          // Unison: activate all elements at once\n          if (elapsedSinceCycle < 50) {\n            // Activate within first frame\n            elementsArray.forEach((element, index) => {\n              sequence.onActivate(element, index, {\n                cycleIndex: cycleIndex.value,\n                elapsedInCycle: elapsedSinceCycle,\n                totalElapsed,\n              })\n            })\n          }\n\n          // Check for cycle complete\n          if (elapsedSinceCycle >= interval.value) {\n            cycleIndex.value++\n            sequence.onCycleComplete?.()\n            currentCycleStartTime.value = now\n          }\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseSequence = rafControls.pause\n    resumeSequence = rafControls.resume\n\n    // Auto-start/stop sequence with animation\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        rafControls.resume()\n      } else {\n        rafControls.pause()\n        startTime.value = null\n      }\n    })\n\n    timedSequence = {\n      currentIndex,\n      currentElement: computed(() => currentElement.value),\n      cycleIndex,\n      next,\n      prev,\n      goTo,\n    }\n  }\n\n  // ===============================\n  // SCROLL-TRIGGERED ANIMATIONS\n  // ===============================\n  let scrollAnimation:\n    | {\n        progress: ComputedRef<number>\n        isScrolling: Ref<boolean>\n      }\n    | undefined\n\n  if (scroll) {\n    const scrollContainer = scroll.container || ref(typeof window !== 'undefined' ? window : undefined)\n    const { y: scrollY, isScrolling } = useScroll(scrollContainer as any)\n\n    const scrollProgress = computed(() => {\n      if (!isMounted.value) return 0\n\n      const container = toValue(scrollContainer)\n      if (!container) return 0\n\n      // Type guard to check if container is window\n      const isWindow = container === window\n      const scrollHeight = isWindow\n        ? document.documentElement.scrollHeight - (typeof window !== 'undefined' ? window.innerHeight : 0)\n        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight\n\n      if (scrollHeight <= 0) return 0\n\n      const rawProgress = scrollY.value / scrollHeight\n      const [thresholdStart, thresholdEnd] = scroll.threshold || [0, 1]\n\n      // Apply offsets\n      const offsetStart = scroll.offset?.start || 0\n      const offsetEnd = scroll.offset?.end || 0\n      const adjustedProgress = (rawProgress * scrollHeight - offsetStart) / (scrollHeight - offsetStart - offsetEnd)\n\n      // Clamp between threshold values with division-by-zero protection\n      const denominator = thresholdEnd - thresholdStart\n      const normalizedProgress = denominator > 0\n        ? (adjustedProgress - thresholdStart) / denominator\n        : 0 // Default to 0 if thresholds are equal\n\n      const clampedProgress = Math.max(0, Math.min(1, normalizedProgress))\n\n      // Safety check for NaN\n      return isNaN(clampedProgress) ? 0 : clampedProgress\n    })\n\n    // Watch progress and trigger callbacks\n    watch(scrollProgress, (progress) => {\n      if (scroll.mode === 'toggle') {\n        const [thresholdStart] = scroll.threshold || [0, 1]\n        if (progress >= thresholdStart && !isPlaying.value) {\n          play()\n        } else if (progress < thresholdStart && isPlaying.value) {\n          stop()\n        }\n      }\n\n      // Single call for all modes (toggle, scrub, or undefined)\n      scroll.onProgress?.(progress)\n    })\n\n    scrollAnimation = {\n      progress: scrollProgress,\n      isScrolling,\n    }\n  }\n\n  // ===============================\n  // STAGGER ANIMATIONS\n  // ===============================\n  let staggerAnimation:\n    | {\n        elements: Ref<HTMLElement[]>\n        triggerStagger: () => void\n        activeTimeouts: Ref<Array<ReturnType<typeof setTimeout>>>\n        activeAnimations: Ref<Animation[]>\n      }\n    | undefined\n\n  let staggerLoopTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  if (stagger) {\n    const staggerElements = ref<HTMLElement[]>([])\n    // Issue #4 Fix: Use ReturnType<typeof setTimeout> for cross-platform compatibility\n    const activeTimeouts = ref<Array<ReturnType<typeof setTimeout>>>([])\n    const activeAnimations = ref<Animation[]>([]) // Track animations for cleanup\n    const initialElementStates = new WeakMap<HTMLElement, { opacity: string; transform: string }>() // Store initial states\n\n    const updateStaggerElements = () => {\n      if (!isMounted.value) return\n\n      const targetEl = toValue(target)\n      if (!targetEl) return\n\n      if (typeof stagger.children === 'string') {\n        staggerElements.value = Array.from(targetEl.querySelectorAll(stagger.children))\n      } else if (Array.isArray(stagger.children)) {\n        staggerElements.value = stagger.children\n      } else {\n        staggerElements.value = unref(stagger.children) || []\n      }\n    }\n\n    const triggerStagger = async () => {\n      // Clear any existing timeouts to prevent overlapping animations\n      activeTimeouts.value.forEach(id => clearTimeout(id))\n      activeTimeouts.value = []\n\n      // Clear any existing animations\n      activeAnimations.value.forEach(anim => anim.cancel())\n      activeAnimations.value = []\n\n      // Wait for DOM to be ready\n      await nextTick()\n      updateStaggerElements()\n\n      const elements = staggerElements.value\n\n      if (!elements.length) {\n        return\n      }\n\n      // Reset elements to initial state if resetOnRestart is enabled (default: true)\n      const shouldReset = stagger.resetOnRestart !== false\n      if (shouldReset) {\n        elements.forEach(el => {\n          // Capture initial state on first run\n          if (!initialElementStates.has(el)) {\n            const computedStyle = getComputedStyle(el)\n            initialElementStates.set(el, {\n              opacity: computedStyle.opacity,\n              transform: computedStyle.transform\n            })\n          }\n\n          // Reset to initial state\n          const initialState = initialElementStates.get(el)\n          if (initialState) {\n            el.style.opacity = initialState.opacity\n            el.style.transform = initialState.transform\n          }\n        })\n\n        // Small delay to ensure style reset applies before animation starts\n        await new Promise(resolve => setTimeout(resolve, 16)) // ~1 frame at 60fps\n      }\n\n      const delays = calculateStaggerDelays(elements.length, stagger)\n\n      elements.forEach((el, index) => {\n        const delay = delays[index]\n\n        const timeoutId = setTimeout(() => {\n          // Skip animation if quality is none or cannot animate\n          if (!canAnimate.value || animationQuality.value === 'none') {\n            // Apply final state immediately without animation\n            if (animation) {\n              const preset = animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = animation.keyframes || presetConfig.keyframes\n              if (Array.isArray(keyframes) && keyframes.length > 0) {\n                const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n                Object.assign(el.style, finalFrame)\n              }\n            }\n            return\n          }\n\n          if (animation) {\n            const preset = animation.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = animation.keyframes || presetConfig.keyframes\n            const duration = animation.duration || ANIMATION_DURATION.NORMAL\n            const effectiveDuration = duration * (\n              animationQuality.value === 'low' ? 0.3 :\n              animationQuality.value === 'medium' ? 0.6 : 1\n            )\n            const easing = animation.easing || EASING.EASE_OUT\n\n            // Use Web Animations API for consistency and proper control\n            const anim = el.animate(keyframes as Keyframe[], {\n              duration: Math.max(1, effectiveDuration), // Ensure minimum 1ms duration\n              easing: easing,\n              fill: 'forwards' as FillMode\n            })\n\n            activeAnimations.value.push(anim)\n\n            // Add completion callback for last element\n            if (index === elements.length - 1) {\n              anim.addEventListener('finish', () => {\n                emit('stagger-complete')\n\n                // Handle loop if enabled\n                if (stagger.loop && isPlaying.value) {\n                  const loopDelay = stagger.loopDelay || 0\n                  staggerLoopTimeoutId = setTimeout(() => {\n                    if (isPlaying.value) {\n                      triggerStagger()\n                    }\n                  }, loopDelay)\n                }\n              })\n            }\n          }\n        }, delay)\n\n        // Track timeout ID for cleanup\n        activeTimeouts.value.push(timeoutId)\n      })\n    }\n\n    // Auto-trigger on mount or play\n    watch([isMounted, isPlaying], ([mounted, playing]) => {\n      if (mounted && playing && autoplay) {\n        nextTick(() => triggerStagger())\n      } else if (!playing) {\n        // Clear loop timeout when stopping\n        if (staggerLoopTimeoutId !== null) {\n          clearTimeout(staggerLoopTimeoutId)\n          staggerLoopTimeoutId = null\n        }\n      }\n    }, { immediate: true })\n\n    staggerAnimation = {\n      elements: staggerElements,\n      triggerStagger,\n      activeTimeouts,\n      activeAnimations\n    }\n  }\n\n  // ===============================\n  // MOTION PATH ANIMATIONS\n  // ===============================\n  let motionPathAnimation:\n    | {\n        progress: Ref<number>\n        setProgress: (progress: number) => void\n      }\n    | undefined\n\n  if (motionPath) {\n    const motionProgress = ref(0)\n    const motionStartTime = ref<number | null>(null)\n\n    const setProgress = (progress: number) => {\n      motionProgress.value = Math.max(0, Math.min(1, progress))\n      updateMotionPathPosition()\n    }\n\n    const updateMotionPathPosition = () => {\n      const targetEl = unref(target)\n      if (!targetEl) return\n\n      const progress = motionProgress.value\n\n      if (motionPath.type === 'circular') {\n        const radius = typeof motionPath.radius === 'number'\n          ? motionPath.radius\n          : motionPath.radius?.x || 100\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radius\n        const y = Math.sin(angle) * radius\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'elliptical') {\n        const radiusX = typeof motionPath.radius === 'object'\n          ? motionPath.radius.x\n          : motionPath.radius || 100\n        const radiusY = typeof motionPath.radius === 'object'\n          ? motionPath.radius.y\n          : motionPath.radius || 60\n\n        const startAngle = (motionPath.startAngle || 0) * (Math.PI / 180)\n        const direction = motionPath.direction === 'counterclockwise' ? -1 : 1\n        const angle = startAngle + (direction * 2 * Math.PI * progress)\n\n        const x = Math.cos(angle) * radiusX\n        const y = Math.sin(angle) * radiusY\n\n        // Set CSS custom properties for flexibility\n        setCSSVar('--motion-x', `${x}px`)\n        setCSSVar('--motion-y', `${y}px`)\n\n        if (motionPath.autoRotate) {\n          const rotation = -angle * (180 / Math.PI)\n          setCSSVar('--motion-rotation', `${rotation}deg`)\n        } else {\n          setCSSVar('--motion-rotation', '0deg')\n        }\n\n      } else if (motionPath.type === 'custom' && motionPath.path) {\n        // For custom SVG paths - would need more complex implementation\n        // This is a placeholder for now\n        console.warn('Custom motion paths not yet fully implemented')\n      }\n    }\n\n    // Animation loop for motion path\n    const motionRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          motionRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n        if (motionStartTime.value === null) {\n          motionStartTime.value = now\n        }\n\n        const elapsed = now - motionStartTime.value\n        motionProgress.value = (elapsed % motionPath.duration) / motionPath.duration\n\n        updateMotionPathPosition()\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseMotion = motionRafControls.pause\n    resumeMotion = motionRafControls.resume\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle (initialization happens in RAF)\n        motionRafControls.resume()\n      } else {\n        motionRafControls.pause()\n        motionStartTime.value = null\n      }\n    })\n\n    motionPathAnimation = {\n      progress: motionProgress,\n      setProgress,\n    }\n  }\n\n  // ===============================\n  // ANIMATION TIMELINE\n  // ===============================\n  if (timeline) {\n    const timelineStartTime = ref<number | null>(null)\n    const executedSteps = new Set<number>()\n\n    const timelineRafControls = useRafFn(\n      (args) => {\n        if (!isPlaying.value || isPaused.value) {\n          timelineRafControls.pause()\n          return\n        }\n\n        const now = args.timestamp\n\n        // Initialize on first RAF callback instead of relying on watch\n        if (timelineStartTime.value === null) {\n          timelineStartTime.value = now\n        }\n\n        const elapsed = now - timelineStartTime.value\n        const duration = timeline.duration || Infinity\n\n        timeline.steps.forEach((step, index) => {\n          if (executedSteps.has(index)) return\n\n          const stepTime = typeof step.at === 'number' ? step.at : 0 // Handle string labels later\n\n          if (elapsed >= stepTime) {\n            executeTimelineStep(step)\n            executedSteps.add(index)\n          }\n        })\n\n        if (timeline.loop && elapsed >= duration) {\n          // Reset for loop\n          timelineStartTime.value = now\n          executedSteps.clear()\n        }\n      },\n      { immediate: false }\n    )\n\n    // Assign pause/resume to outer scope for use in pause()/resume() functions\n    pauseTimeline = timelineRafControls.pause\n    resumeTimeline = timelineRafControls.resume\n\n    const executeTimelineStep = (step: UseAnimationTimelineStep) => {\n      switch (step.action) {\n        case 'play':\n          if (step.target) {\n            // Animate a different target\n            const targetEl = unref(step.target)\n            if (targetEl && step.animation) {\n              const preset = step.animation.preset || 'fadeIn'\n              const presetConfig = animationPresets[preset]\n              const keyframes = step.animation.keyframes || presetConfig.keyframes\n              const duration = step.animation.duration || ANIMATION_DURATION.NORMAL\n\n              targetEl.animate(keyframes as Keyframe[], {\n                duration,\n                easing: step.animation.easing || EASING.EASE_OUT,\n                fill: FILL_MODE.FORWARDS as FillMode,\n              })\n            }\n          } else {\n            play()\n          }\n          break\n        case 'pause':\n          pause()\n          break\n        case 'emit':\n          if (step.event) {\n            emit(step.event)\n          }\n          break\n        case 'callback':\n          step.callback?.()\n          break\n      }\n    }\n\n    watch(isPlaying, (playing) => {\n      if (playing) {\n        // Reset state for new cycle\n        executedSteps.clear()\n        timelineRafControls.resume()\n      } else {\n        timelineRafControls.pause()\n        timelineStartTime.value = null\n      }\n    })\n  }\n\n  // ===============================\n  // ENTER/EXIT PATTERN\n  // ===============================\n  if (enterExit) {\n    const hasEntered = ref(false)\n\n    // Set initial state based on trigger value\n    watch(isMounted, (mounted) => {\n      if (mounted && !enterExit.trigger.value && enterExit.exit) {\n        const targetEl = unref(target) as HTMLElement | undefined\n        if (targetEl) {\n          const preset = enterExit.exit.preset || 'fadeOut'\n          const presetConfig = animationPresets[preset]\n          const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n\n          // Apply final exit state immediately without animation\n          if (Array.isArray(keyframes) && keyframes.length > 0) {\n            const finalFrame = keyframes[keyframes.length - 1] as Record<string, any>\n            Object.assign(targetEl.style, finalFrame)\n          }\n        }\n      }\n    }, { immediate: true })\n\n    watch(enterExit.trigger, async (shouldEnter, wasEntered) => {\n      if (!isMounted.value) return\n\n      if (shouldEnter && !wasEntered) {\n        // Enter animation\n        enterExit.onEnterStart?.()\n\n        if (!enterExit.skipInitial || hasEntered.value) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.enter) {\n            const preset = enterExit.enter.preset || 'fadeIn'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.enter.keyframes || presetConfig.keyframes\n            const duration = enterExit.enter.duration || ANIMATION_DURATION.NORMAL\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.enter.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        hasEntered.value = true\n        enterExit.onEnterComplete?.()\n\n      } else if (!shouldEnter && wasEntered) {\n        // Exit animation\n        enterExit.onExitStart?.()\n\n        if (!enterExit.skipInitial) {\n          const targetEl = unref(target) as HTMLElement | undefined\n          if (targetEl && enterExit.exit) {\n            const preset = enterExit.exit.preset || 'fadeOut'\n            const presetConfig = animationPresets[preset]\n            const keyframes = enterExit.exit.keyframes || presetConfig.keyframes\n            const duration = enterExit.exit.duration || ANIMATION_DURATION.FAST\n\n            const anim = targetEl.animate(keyframes as Keyframe[], {\n              duration,\n              easing: enterExit.exit.easing || EASING.EASE_OUT,\n              fill: FILL_MODE.FORWARDS as FillMode,\n            })\n\n            await anim.finished\n          }\n        }\n\n        enterExit.onExitComplete?.()\n      }\n    }, { immediate: !enterExit.skipInitial })\n  }\n\n  // ===============================\n  // CSS VARIABLE INTEGRATION\n  // ===============================\n  const cssVarWatchers: Array<() => void> = []\n  const appliedCSSVars = new Set<string>()\n\n  const setCSSVar = (name: string, value: string | number) => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    targetEl.style.setProperty(varName, String(value))\n    appliedCSSVars.add(varName)\n  }\n\n  const getCSSVar = (name: string): string | undefined => {\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (!targetEl) return undefined\n\n    const varName = name.startsWith('--') ? name : `--${name}`\n    return getComputedStyle(targetEl).getPropertyValue(varName) || undefined\n  }\n\n  const syncCSSVars = (vars: Record<string, Ref<string | number> | ComputedRef<string | number>>): (() => void) => {\n    const stopHandles = Object.entries(vars).map(([name, valueRef]) => {\n      return watch(\n        valueRef,\n        (value) => {\n          setCSSVar(name, value)\n        },\n        { immediate: true }\n      )\n    })\n\n    cssVarWatchers.push(...stopHandles)\n\n    return () => {\n      stopHandles.forEach(stop => stop())\n    }\n  }\n\n  // ===============================\n  // CLEANUP\n  // ===============================\n  const cleanup = () => {\n    // Issue #2 Fix: Set playback flags BEFORE stopping RAF to prevent race conditions\n    isPlaying.value = false\n    isPaused.value = false\n\n    // Stop all RAF loops BEFORE state reset\n    pauseSequence?.()\n    pauseMotion?.()\n    pauseTimeline?.()\n\n    // Cleanup responsive system\n    cleanupResponsive?.()\n\n    // Now call stop() to cleanup other resources\n    stop()\n\n    // Remove all CSS variables\n    const targetEl = unref(target) as HTMLElement | undefined\n    if (targetEl) {\n      appliedCSSVars.forEach(varName => {\n        targetEl.style.removeProperty(varName)\n      })\n      appliedCSSVars.clear()\n    }\n\n    // Remove finish listeners\n    const anim = webAnimation?.animate.value\n    if (anim && finishListeners.has(anim)) {\n      const listener = finishListeners.get(anim)!\n      anim.removeEventListener('finish', listener)\n      finishListeners.delete(anim)\n    }\n\n    // Cleanup event listeners\n    stopListeners.forEach((unsubscribe) => unsubscribe())\n    cssVarWatchers.forEach((unsubscribe) => unsubscribe())\n\n    // Cancel animations\n    webAnimation?.cancel()\n\n    // Cleanup progress interval and watcher\n    if (activeProgressInterval.value !== null) {\n      clearInterval(activeProgressInterval.value)\n      activeProgressInterval.value = null\n    }\n    progressWatchStop?.() // Stop the progress watch itself\n\n    // Cleanup navigation listeners (Issue #3)\n    navigationCleanup.value?.()\n    navigationCleanup.value = null\n\n    // Issue #4 Fix: Clear stagger timeouts in cleanup, not just stop()\n    if (staggerAnimation?.activeTimeouts) {\n      staggerAnimation.activeTimeouts.value.forEach(id => clearTimeout(id))\n      staggerAnimation.activeTimeouts.value = []\n    }\n    if (staggerAnimation?.activeAnimations) {\n      staggerAnimation.activeAnimations.value.forEach(anim => anim.cancel())\n      staggerAnimation.activeAnimations.value = []\n    }\n    // Clear stagger loop timeout\n    if (stagger && staggerLoopTimeoutId !== null) {\n      clearTimeout(staggerLoopTimeoutId)\n      staggerLoopTimeoutId = null\n    }\n\n    // Reset state refs\n    if (motionPathAnimation) {\n      motionPathAnimation.progress.value = 0\n    }\n    if (timedSequence) {\n      timedSequence.currentIndex.value = 0\n      timedSequence.cycleIndex.value = 0\n    }\n\n    // Unregister consumer and cleanup state cache if no consumers remain\n    if (stateName && stateConsumers.has(stateName)) {\n      const consumers = stateConsumers.get(stateName)!\n      consumers.delete(consumerId)\n\n      // Issue #6 Fix: Use nextTick for atomic cleanup\n      cleanupStateName(stateName, consumers)\n    }\n  }\n\n  // Only register onUnmounted if we're in a component context\n  // getCurrentInstance returns null if called outside setup()\n  if (getCurrentInstance()) {\n    onUnmounted(cleanup)\n  }\n  // Note: If not in component context, caller must manually call cleanup()\n  // This is expected for tests and utilities that create animations dynamically\n\n  // ===============================\n  // RETURN API\n  // ===============================\n  return {\n    // Playback controls\n    play,\n    pause,\n    stop,\n    resume,\n\n    // State\n    isPlaying,\n    state,\n\n    // Events\n    emit,\n    on,\n\n    // Environment\n    canAnimate,\n    animationQuality,\n    shouldPauseAnimations,\n\n    // Web Animations\n    ...(webAnimation && {\n      animate: webAnimation.animate,\n      animateIn: webAnimation.animateIn,\n      animateOut: webAnimation.animateOut,\n    }),\n\n    // Timed Sequence\n    ...(timedSequence && {\n      sequence: timedSequence,\n    }),\n\n    // Scroll\n    ...(scrollAnimation && {\n      scroll: scrollAnimation,\n    }),\n\n    // Stagger\n    ...(staggerAnimation && {\n      stagger: staggerAnimation,\n    }),\n\n    // Motion Path\n    ...(motionPathAnimation && {\n      motionPath: motionPathAnimation,\n    }),\n\n    // Responsive (if enabled)\n    ...(responsiveSystem && {\n      responsive: responsiveSystem,\n    }),\n\n    // SVG ViewBox (if enabled)\n    ...(svgSystem && {\n      svg: svgSystem,\n    }),\n\n    // Grid Zones (if enabled)\n    ...(gridSystem && {\n      grid: gridSystem,\n    }),\n\n    // CSS Variables\n    setCSSVar,\n    getCSSVar,\n    syncCSSVars,\n\n    // Cleanup\n    cleanup,\n  }\n}\n","structuredPatch":[{"oldStart":1955,"oldLines":14,"newStart":1955,"newLines":13,"lines":["     const scrollProgress = computed(() => {","       if (!isMounted.value) return 0"," ","-      const container = toValue(scrollContainer)","-      if (!container) return 0","+      // Handle Window vs HTMLElement types explicitly","+      const containerValue = scroll.container ? toValue(scroll.container) : (typeof window !== 'undefined' ? window : undefined)","+      if (!containerValue) return 0"," ","-      // Type guard to check if container is window","-      const isWindow = container === window","-      const scrollHeight = isWindow","-        ? document.documentElement.scrollHeight - (typeof window !== 'undefined' ? window.innerHeight : 0)","-        : (container as HTMLElement).scrollHeight - (container as HTMLElement).clientHeight","+      const scrollHeight = containerValue === window","+        ? document.documentElement.scrollHeight - window.innerHeight","+        : (containerValue as HTMLElement).scrollHeight - (containerValue as HTMLElement).clientHeight"," ","       if (scrollHeight <= 0) return 0"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"9bf51539-1b18-4b15-969b-db8557aa1fb7","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0175dFEa3Yhfd148M4XF4V5w","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now let me run typecheck one final time to verify all useAnimation errors are fixed:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":872,"cache_read_input_tokens":175993,"cache_creation":{"ephemeral_5m_input_tokens":872,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfitYq6dDL8mkjHseG5","type":"assistant","uuid":"5b4b82b5-177e-4c31-b1b2-f2a8dbe9e996","timestamp":"2025-10-09T00:21:13.503Z"}
{"parentUuid":"5b4b82b5-177e-4c31-b1b2-f2a8dbe9e996","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0175dFEa3Yhfd148M4XF4V5w","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015XKThqGLo61bUF5B6fKRNH","name":"Bash","input":{"command":"npm run typecheck 2>&1 | grep \"useAnimation.ts.*error\" | wc -l","description":"Count remaining useAnimation errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":872,"cache_read_input_tokens":175993,"cache_creation":{"ephemeral_5m_input_tokens":872,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CTvfitYq6dDL8mkjHseG5","type":"assistant","uuid":"2eddfe8b-f62c-41dc-9e3c-1e210409dec2","timestamp":"2025-10-09T00:21:14.357Z"}
{"parentUuid":"2eddfe8b-f62c-41dc-9e3c-1e210409dec2","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015XKThqGLo61bUF5B6fKRNH","type":"tool_result","content":"       0","is_error":false}]},"uuid":"0c1fc41e-8358-4e41-9056-e8bdb4540471","timestamp":"2025-10-09T00:21:43.710Z","toolUseResult":{"stdout":"       0","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"0c1fc41e-8358-4e41-9056-e8bdb4540471","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01XgM43xbYxDYL7TD5K5J7CD","type":"message","role":"assistant","content":[{"type":"text","text":"Excellent! All useAnimation errors are now fixed! Let me update the todo list and mark the task as complete:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":326,"cache_read_input_tokens":176865,"cache_creation":{"ephemeral_5m_input_tokens":326,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CTvfmXvS6xSecLvoWSfTf","type":"assistant","uuid":"fecfd8e9-f201-4ce4-a184-3c0dc2f0a8e5","timestamp":"2025-10-09T00:21:49.810Z"}
{"parentUuid":"fecfd8e9-f201-4ce4-a184-3c0dc2f0a8e5","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01XgM43xbYxDYL7TD5K5J7CD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013A8N3V1JtkSA6fGBw8xN6K","name":"TodoWrite","input":{"todos":[{"content":"Fix scroll container type errors (Window vs HTMLElement union)","status":"completed","activeForm":"Fixed scroll container type errors"},{"content":"Fix timeout and progress calculation types","status":"completed","activeForm":"Fixed timeout and progress calculation types"},{"content":"Fix sequence return type","status":"completed","activeForm":"Fixed sequence return type"},{"content":"Run typecheck and verify all useAnimation errors are fixed","status":"completed","activeForm":"Ran typecheck and verified all useAnimation errors are fixed"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":326,"cache_read_input_tokens":176865,"cache_creation":{"ephemeral_5m_input_tokens":326,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CTvfmXvS6xSecLvoWSfTf","type":"assistant","uuid":"c1434a74-78be-47b6-86fd-7805625ad2dc","timestamp":"2025-10-09T00:21:51.631Z"}
{"parentUuid":"c1434a74-78be-47b6-86fd-7805625ad2dc","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013A8N3V1JtkSA6fGBw8xN6K","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"51d47fbf-faca-4d83-8b49-d350430b188b","timestamp":"2025-10-09T00:21:51.742Z","toolUseResult":{"oldTodos":[{"content":"Fix scroll container type errors (Window vs HTMLElement union) - Lines 1957, 1960, 1961","status":"in_progress","activeForm":"Fixing scroll container type errors"},{"content":"Fix timeout and progress calculation types (2 errors) - Lines 1729, 1724","status":"pending","activeForm":"Fixing timeout and progress calculation types"},{"content":"Fix sequence return type (line 1932)","status":"pending","activeForm":"Fixing sequence return type"},{"content":"Run typecheck and verify all useAnimation errors are fixed","status":"pending","activeForm":"Running typecheck and verifying all useAnimation errors are fixed"}],"newTodos":[{"content":"Fix scroll container type errors (Window vs HTMLElement union)","status":"completed","activeForm":"Fixed scroll container type errors"},{"content":"Fix timeout and progress calculation types","status":"completed","activeForm":"Fixed timeout and progress calculation types"},{"content":"Fix sequence return type","status":"completed","activeForm":"Fixed sequence return type"},{"content":"Run typecheck and verify all useAnimation errors are fixed","status":"completed","activeForm":"Ran typecheck and verified all useAnimation errors are fixed"}]}}
{"parentUuid":"51d47fbf-faca-4d83-8b49-d350430b188b","isSidechain":false,"userType":"external","cwd":"/Users/natedamstra/socialaize","sessionId":"35000f96-35e4-432d-80b5-8293259edef7","version":"2.0.11","gitBranch":"feat-landing-docs","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01DifBuscQgaavuemo6dZuek","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! All type errors in `useAnimation.ts` have been successfully fixed! Here's a summary of what was done:\n\n## Summary of Fixes\n\n### 1. **Element Access Pattern Errors** ✅\n- **Issue**: Using `unref()` with `MaybeRefOrGetter` types which include getter functions\n- **Solution**: Replaced `unref()` with `toValue()` from VueUse, which properly handles `MaybeRefOrGetter` types including refs, raw values, and getter functions\n- **Locations**: Lines 323, 1066, 1161, 1252, 1484, 1495, 1513, 1545, 2033, 1381\n\n### 2. **Nullable Function Guards** ✅\n- **Issue**: Calling potentially undefined functions without optional chaining\n- **Solution**: Added optional chaining operator `?.()` to all RAF control functions\n- **Locations**: Lines 1631-1633, 1676-1678 (pause/resume functions)\n\n### 3. **Scroll Container Type Errors** ✅\n- **Issue**: `toValue()` with union type `Ref<HTMLElement | Window>` causing type conflicts\n- **Solution**: Explicitly handled Window vs HTMLElement types by checking scroll.container before using toValue\n- **Locations**: Lines 1959-1964\n\n### 4. **Timeout Type Error** ✅\n- **Issue**: `setInterval()` returns `Timeout` but variable typed as `number`\n- **Solution**: Changed type from `number` to `ReturnType<typeof setInterval>`\n- **Location**: Line 915\n\n### 5. **Progress Calculation Type Error** ✅\n- **Issue**: `anim.currentTime` can be `null` or non-number `CSSNumberish` types\n- **Solution**: Added explicit type guard checking both `!== null` and `typeof === 'number'`\n- **Location**: Line 1724\n\n### 6. **Sequence Return Type Error** ✅\n- **Issue**: `useCycleList().state` returns `Ref<T>` but expected `ComputedRef<T | undefined>`\n- **Solution**: Wrapped `currentElement` in a computed to match the expected return type\n- **Location**: Line 1933\n\nAll 26 original type errors in `useAnimation.ts` have been successfully resolved! The file now passes TypeScript type checking."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":250,"cache_read_input_tokens":177191,"cache_creation":{"ephemeral_5m_input_tokens":250,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CTvfn84GP8RXh24KvBfFy","type":"assistant","uuid":"6e9f6457-1672-41e3-aedf-800f64926561","timestamp":"2025-10-09T00:22:08.053Z"}
